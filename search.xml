<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解Paxos &amp; Raft</title>
      <link href="/2020/09/27/2020-09-27/"/>
      <url>/2020/09/27/2020-09-27/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>共识算法：在分布式系统中多个节点对某事达成一致</p><p>通过多副本的方式确保高可用，单副本损坏率x，则多副本可靠性理论值：n 副本 = 1 - x^n </p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><h3 id="主从异步复制"><a href="#主从异步复制" class="headerlink" title="主从异步复制"></a>主从异步复制</h3><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/raft/image-20201014104658374.png" style="zoom:80%;"><h3 id="主从同步复制"><a href="#主从同步复制" class="headerlink" title="主从同步复制"></a>主从同步复制</h3><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/raft/image-20201014104732907.png" style="zoom:80%;"><h3 id="主从半同步复制"><a href="#主从半同步复制" class="headerlink" title="主从半同步复制"></a>主从半同步复制</h3><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/raft/image-20201014104756657.png" style="zoom:80%;"><p>之前的认知里感觉主从半同步复制用的较多，需要注意其缺点是任何从库可能都不完整，那么从库在处理后续读请求时可能产生问题，因此诞生了多数派读/写</p><h3 id="多数派写"><a href="#多数派写" class="headerlink" title="多数派写"></a>多数派写</h3><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/raft/image-20201014105051104.png" style="zoom:80%;"><p>多数派写，后写入优胜，最后1次写入覆盖先前写入，所有写入操作需要有1个全局顺序：时间戳</p><p>多数派读，即以大多数节点的val为最终读取的结果</p><p>优点：</p><ol><li>数据的高可靠：没有数据丢失</li><li>高可用，最多允许挂（N-1）/2</li><li>数据完整性有保证</li></ol><p>一致性：最终一致性</p><h4 id="多数派读写缺陷"><a href="#多数派读写缺陷" class="headerlink" title="多数派读写缺陷"></a>多数派读写缺陷</h4><p>​    事务性：1. 非原子更新；2. 脏读；3. 更新丢失的问题</p><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/raft/1" alt></p><p>在上述演进下诞生了Paxos，这也解释了经典的Paxos为什么需要两个阶段，第一阶段确定写入的多数派节点（或者确定讨论的提案号），第二阶段确定提案的具体value</p><h1 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h1><ul><li>一个可靠的存储系统: 基于多数派读写.<ul><li>容忍消息丢失和乱序</li></ul></li><li>每个paxos实例用来存储一个值.</li><li>用2轮RPC来确定一个值.</li><li>一个值‘确定’后不能被修改. ‘确定’指被多数派接受写入.</li><li>强一致性</li><li>前提：不解决拜占庭将军问题，即要求信道和存储是可靠的</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li><p>Classic Paxos</p><p>1个实例(确定1个值)写入需要2轮RPC.</p></li><li><p>Multi Paxos</p><p>约为1轮RPC，确定1个值(第1次RPC做了合并).</p></li><li><p>Fast Paxos</p><p>没冲突：1轮RPC确定一个值.</p><p>有冲突：2轮RPC确定一个值</p></li></ol><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>Proposer: 发起paxos的进程.</p><p>Acceptor: 存储节点，接受、处理和存储消息.</p><p>Quorum(Acceptor的多数派) : n/2+1个Acceptors.</p><p>Round：1轮包含2个阶段：Phase-1 &amp; Phase-2</p><p>每1轮的编号 (rnd): 单调递增；后写胜出；全局唯一(用于区分Proposer);</p><h2 id="Classic-Paxos"><a href="#Classic-Paxos" class="headerlink" title="Classic Paxos"></a>Classic Paxos</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/raft/2.png" alt></p><h3 id="异常写入处理"><a href="#异常写入处理" class="headerlink" title="异常写入处理"></a>异常写入处理</h3><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/raft/3" alt></p><h2 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi-Paxos"></a>Multi-Paxos</h2><p>通过选择一个proposer作为leader降低多个proposer引起冲突的频率，合并阶段一从而将一次决议的平均消息代价缩小到最优的两次（将多个paxos实例的phase-1合并到1个RPC；使得这些paxos只需要运行phase-2即可），实际上就算有多个leader存在，算法还是安全的，只是退化为经典的paxos算法。</p><p>应用:chubby zookeeper megastore spanner</p><h2 id="Fast-Paxos"><a href="#Fast-Paxos" class="headerlink" title="Fast-Paxos"></a>Fast-Paxos</h2><p>● Proposer直接发送phase-2.</p><p>● Fast Paxos的rnd是0.0保证它一定小于任何一个Classic rnd ，所以可以在出现冲突时安全的回退到Classic Paxos.</p><p>● Acceptor只在v是空时才接受Fast phase-2请求</p><p>● 如果发成冲突，回退到Classic Paxos，开始用一个 rnd &gt; 0来运行。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>讲解一个知识点最好的方式，其实是抽丝剥茧，一层一层深入。</p><ol><li><p>为什么要多个acceptor？单个有什么问题。（单个无法保证高可用）</p></li><li><p>为什么进而演进到两阶段？（避免多数派读写在事务性方面的缺点，如并发写场景下的更新丢失问题）</p></li><li><p>为什么propose阶段还需要一个唯一递增ID，这个设计解决了什么问题。（1. 保证日志的安全性，即不能改变已经确定的值，2. 保序）</p></li><li><p>思想有了，paxos怎么应用到实际工程中？（一般都用优化后的multi-paxos，不同的实现会有些差异，如zk的zab）</p></li></ol><p>这样才可能把一种知识的来龙去脉讲得透彻，而不是一上来就是 paxos 两阶段，先propose后accpet，算法倒是懂了但怎么用呢？这不是传道受业最佳的方法。</p><blockquote><ol><li><p><a href="http://drmingdrmer.github.io/tech/distributed/2015/11/11/paxos-slide.html深度好文，大部分的slides就是出自这一篇，关键的逻辑写的很清晰" target="_blank" rel="noopener">http://drmingdrmer.github.io/tech/distributed/2015/11/11/paxos-slide.html深度好文，大部分的slides就是出自这一篇，关键的逻辑写的很清晰</a></p></li><li><p><a href="https://blog.csdn.net/wolf_love666/article/details/92832811" target="_blank" rel="noopener">https://blog.csdn.net/wolf_love666/article/details/92832811</a></p><p>举了一个两阶段提交的case比较详细</p></li></ol></blockquote><h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><p>节点的三种state，同一时间只能是其中的一个角色</p><ul><li><p>Leader（领导者）：负责日志的同步管理，处理来自客户端的请求，与Follower保持heartBeat的联系；</p></li><li><p>Follower（追随者）：刚启动时所有节点为Follower状态，响应Leader的日志同步请求，响应客户端请求，把请求到Follower的事务转发给Leader；</p></li><li><p>Candidate（候选者）：负责选举投票，Follower节点与Leader之间的心跳超时则Follower转为Candidate发起选举，选举出Leader后从Candidate转为Leader（得到多数选票）或Follower；</p></li></ul><h2 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h2><p>two timeout settings which control elections</p><ul><li>election timeout：amount of time a follower waits until becoming a candidate, is randomized to be between 150ms and 300ms.</li><li>election term: After the election timeout the follower becomes a candidate and starts a new election term(term + 1)<ul><li>标识leader的合法性：实际上raft协议在leader选举阶段，由于老leader可能也还存活，也会存在不只一个leader的情形，<strong>只是不存在term一样的两个leader</strong>，因为选举算法要求leader得到同一个term的多数派的同意，同时赞同的成员会承诺不接受term更小的任何消息。这样可以根据term大小来区分谁是合法的leader（避免出现两个leader,非法的节点也能依据此感知到并更改自身的状态）</li><li>当某节点收到的请求中Term比当前Term小时则拒绝该请求</li><li>在一个Term期间每个节点只能投票一次</li></ul></li></ul><h3 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h3><ol><li>After the election timeout the follower becomes a candidate and starts a new election term(term + 1)</li><li>vote fot itself and sends out Request Vote messages to other nodes.</li><li>If the receiving node hasn’t voted yet in this term then it votes for the candidate …(先到先得，同时比较当前的日志是否比自己的新) and the node resets its election timeout.</li><li>Once a candidate has a majority of votes it becomes leader.（多数派保证了在一个term中至多只有一个leader会被选举出来）</li><li>The leader begins sending out Append Entries messages to its followers.（通过心跳的形式，开始发送同步日志）</li><li>Followers then respond to each Append Entries message.</li><li>这个term会持续直到下一次follower接受心跳超时变为candidate</li></ol><h3 id="一个term中无leader诞生的场景"><a href="#一个term中无leader诞生的场景" class="headerlink" title="一个term中无leader诞生的场景"></a>一个term中无leader诞生的场景</h3><p>two nodes become candidates at the same time then a split vote can occur.</p><ol><li><p>比如一共4个节点，2个节点同时变为candidates，发起投票，根据同一term中先到先得又各自获得一个选票，均达不到多数，导致该轮无leader诞生</p></li><li><p>The nodes will wait for a new election and try again.（因为各自的election timeout是随机值，只要下一轮不是同时开始则可顺利选举出leader）</p></li></ol><h2 id="Log-Replication"><a href="#Log-Replication" class="headerlink" title="Log Replication"></a>Log Replication</h2><p>Once we have a leader elected we need to replicate all changes to our system to all nodes.（通过心跳发送Append Entries）</p><p>当Leader选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过Leader处理，这些事务请求或说成命令也就是这里说的日志，我们都知道要保证节点的一致性就要保证每个节点都按顺序执行相同的操作序列，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><ol><li>第一阶段：当leader接收到客户端的日志（事务请求）后先把该日志追加到本地的Log中，然后通过heartbeat把该Entry同步给其他Follower，Follower接收到日志后记录日志然后向Leader发送ACK</li><li>第二阶段：leader得到多数followe对请求的响应后将该日志设置为已提交并追加到本地磁盘中，通知客户端同时在下个heartbeat中Leader将通知所有的Follower将该日志存储在自己的本地磁盘中。</li></ol><h3 id="网络分区处理"><a href="#网络分区处理" class="headerlink" title="网络分区处理"></a>网络分区处理</h3><p>Raft can even stay consistent in the face of network partitions.</p><ol><li>比如现在5个节点ABCDE，出现了网络分区，AB / CDE，这时候根据选举有可能会出现两个leader，比如原来的leader是B,CDE中根据多数派又能选举出一个leader C（term+1）</li><li>这时候客户端发起写入请求，两个master都收到了，那么B对应只有2个节点，无法满足多数写，所以不会进入commit，但另一边C满足多数写，成功commit</li><li>之后网络分区恢复，根据term的规则，由于C的term高，所以B收到心跳后把自己转变为follower，同时回滚自己未提交的log并同步leader的log，Our log is now consistent across our cluster.</li></ol><p>这是复杂一点的情况出现2个master，如果原来的leader处在分区后的多数派一边，则分区后少数派这边就不会选举出新的leader，之后恢复后依然能重新同步原来leader的log，保持一致</p><blockquote><p> ref：<a href="http://thesecretlivesofdata.com/raft/#home" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/#home</a></p></blockquote><h2 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h2><p>在Raft协议中，所有的日志条目都只会从Leader节点往Follower节点写入，且Leader节点上的日志只会增加，绝对不会删除或者覆盖。</p><p>这意味着Leader节点必须包含所有已经提交的日志，即能被选举为Leader的节点一定需要包含所有的已经提交的日志。因为日志只会从Leader向Follower传输，所以如果被选举出的Leader缺少已经Commit的日志，那么这些已经提交的日志就会丢失，显然这是不符合要求的。</p><p>这就是Leader选举的限制：</p><ul><li><p>选举安全性（Election Safety）：每个Term只能选举出一个Leader</p></li><li><p>Leader完整性（Leader Completeness）：能被选举成为Leader的节点，一定包含了所有已经提交的日志条目。</p></li></ul><p>回看算法基础中的RequestVote RPC：</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>Candidate的任期</td></tr><tr><td>candidateId</td><td>Candidate的ID</td></tr><tr><td>lastLogIndex</td><td>Candidate最后一条日志的索引</td></tr><tr><td>lastLogTerm</td><td>Candidate最后一条日志的任期</td></tr></tbody></table><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期，用于Candidate更新自己的任期</td></tr><tr><td>voteGranted</td><td>true表示给Candidate投票</td></tr></tbody></table><p>请求中的lastLogIndex和lastLogTerm即用于保证Follower投票选出的Leader一定包含了已经被提交的所有日志条目。</p><ol><li>Candidate需要收到超过版本的节点的选票来成为Leader</li><li>已经提交的日志条目至少存在于超过半数的节点上</li><li>那么这两个集合一定存在交集（至少一个节点），<strong>且Follower只会投票给日志条目比自己的“新”的Candidate</strong>，那么被选出的节点的日志一定包含了交集中的节点已经Commit的日志</li></ol><p>日志比较规则（即上面“新”的含义）：Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p><blockquote><p> ref：<a href="https://www.cnblogs.com/hzmark/p/raft_3.html" target="_blank" rel="noopener">https://www.cnblogs.com/hzmark/p/raft_3.html</a></p><p> Raft paper翻译：<a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</a></p></blockquote><h2 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a>Zab</h2><p>zab是基于multi-paxos实现的，但感觉目前的实现版本和raft的思路更接近</p><ul><li>选举：投票给日志最全的节点，也是通过任期+事务id进行判断，只不过zab的实现里把他俩用一个64位的zxid一起表示，高32位代表epoch（即任期term），低32位代表事务id，思路和raft一致</li><li>两阶段提交：同raft</li><li>日志恢复：有两个争议版本：<ul><li>单向，leader有最全的数据，recovery的具体实现也只是leader到follower的单向同步。因为zab跟raft一样，都有顺序commit，日志连续的语义（zab里叫primary order）。</li><li>双向，zab的zookeeper实现中 ，一个prospective leader需要将自己的log更新为quorum里面最新的log,然后才好在synchronization阶段将quorum里的其他机器的log都同步到一致.</li><li>个人倾向于单向的方式，因为我理解zab的选主流程已经能同raft一样保证日志的连续性，可能是不同时期的zk实现方式不同导致的争议</li></ul></li></ul><h1 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h1><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>问题较为复杂时可以把问题分解为几个小问题来处理，Raft也使用了分而治之的思想把算法流程分为三个子问题：选举（Leader election）、日志复制（Log replication）、安全性（Safety）三个子问题</p><h4 id="leader地位"><a href="#leader地位" class="headerlink" title="leader地位"></a>leader地位</h4><p>Raft协议比paxos的优点是容易理解，容易实现。它强化了leader的地位（Basic-Paxos没有leader的概念，在Multi-Paxos中进行了优化，通过选择一个proposer作为leader降低多个proposer引起冲突的频率），把整个协议可以清楚的分割成两个部分，通过选出一个leader来简化日志副本的管理，并利用日志的连续性做了一些简化：（1）Leader在时。由Leader向Follower同步日志 （2）Leader挂掉了，选一个新Leader，Leader选举算法。</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>raft协议的Leader选举算法，新选举出的Leader已经拥有全部的可以被提交的日志，而multi-paxos择不需要保证这一点，这也意味multi-paxos需要额外的流程从其它节点获取已经被提交的日志。因此raft协议日志可以简单的只从leader流向follower在raft协议中，而multi-paxos则需要额外的流程补全已提交的日志。</p><p>Raft协议强调日志的连续性，multi-paxos则允许日志有空洞<strong>。</strong>日志的连续性蕴含了这样一条性质：如果两个不同节点上相同序号的日志，只要term相同，那么这两条日志必然相同，且这和这之前的日志必然也相同的，这使得leader想follower同步日志时，比对日志非常的快速和方便；同时Raft协议中日志的commit（提交）也是连续的，一条日志被提交，代表这条日志之前所有的日志都已被提交，一条日志可以被提交，代表之前所有的日志都可以被提交。日志的连续性使得Raft协议中，知道一个节点的日志情况非常简单，只需要获取它最后一条日志的序号和term。可以举个列子，A,B,C三台机器，C是Leader，term是3，A告诉C它们最后一个日志的序列号都是4，term都是3，那么C就知道A肯定有序列号为1,2,3,4的日志，而且和C中的序列号为1,2,3,4的日志一样，这是raft协议日志的连续性所强调的，好了那么Leader知道日志1，2，3，4已经被多数派（A,C)拥有了，可以提交了。同时，这也保证raft协议在leader选举的时候，一个多数派里必然存在一个节点拥有全部的已提交的日志，这是由于最后一条被commit的日志，至少被多数派记录，而由于日志的连续性，拥有最后一条commit的日志也就意味着拥有全部的commit日志，即至少有一个多数派拥有所有已commit的日志。并且只需要从一个多数集中选择最后出最后一条日志<strong>term最大且序号最大</strong>的节点作为leader，新leader必定是拥有全部已commit的日志</p><p>而对于multi-paxos来说，日志是有空洞的，每个日志需要单独被确认是否可以commit，也可以单独commit。因此当新leader产生后，它只好重新对每个未提交的日志进行确认，已确定它们是否可以被commit，甚至于新leader可能缺失可以被提交的日志，需要通过Paxos阶段一向其它节点学习到缺失的可以被提交的日志，当然这都可以通过向一个多数派询问完成</p><p>小结一下就是</p><ul><li><p>选主方式：raft比较last_log_index以及last_log_term保证选出的leader已经拥有最完整的数据，zab（multi-paxos）仅通过节点标识选主，所以需要之后的recovery过程，不过实现中zab也采用了类似于raft的选主方式</p></li><li><p>恢复方向：raft单向，仅从leader到follower补齐log；multi-paxos双向，leader需要从follower接收数据来生成initial history</p></li></ul><p>本质上，两者是一样的。一个日志被多数派拥有，那么它就可以被提交，但是Leader需要通过某种方式得知这一点，同时为了已经被提交的日志不被新leader覆写，新leader需要拥有所有已经被提交的日志之后才能正常工作，并且需要重新提交所有未commit的日志<strong>。两者的区别在于Leader确认提交和获取所有可以被提交日志的方式上，而方式上的区别又是由于是日志是否连续造成的，Raft协议利用日志连续性，简化了这个过程</strong>。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ol><li>Raft和Paxos一样只要保证n/2+1节点正常就能够提供服务；</li><li>经典的paxos，从一个提案被提出到被接受分为两个阶段，第一个阶段去询问值，第二阶段根据询问的结果提出值。这两个阶段是无法分割的，两个阶段的每个细节都是精心设计的，相互关联，共同保障了协议的一致性。而VR,ZAB,Raft这些强调<strong>合法leader的唯一性</strong>协议，它们直接从leader的角度描述协议的流程，也从leader的角度出发论证正确性。<strong>但是实际上它们使用了和Paxos完全一样的原理来保证协议的安全性</strong>，当同时存在多个节点同时尝试成为leader或者不知一个节点认为自己时leader时，本质上它们和经典Paxos中多个proposer并存的情形没什么不同。</li><li>安全性保障都是利用了<strong>同一个性质：两个多数派集合之间存在一个公共成员</strong>。</li></ol><blockquote><p><a href="https://www.zhihu.com/question/36648084" target="_blank" rel="noopener">https://www.zhihu.com/question/36648084</a></p><p><a href="https://www.zhihu.com/question/28242561" target="_blank" rel="noopener">https://www.zhihu.com/question/28242561</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 共识算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「又一个人生的分叉口——研发or算法」</title>
      <link href="/2020/07/11/2020-07-11/"/>
      <url>/2020/07/11/2020-07-11/</url>
      
        <content type="html"><![CDATA[<p>眼看秋招提前批一个个开启，还没选定方向的自己是真的有些着急了，害，以前听前辈说不建议算法和研发都搞的原因是容易两个都不精，结果现在大概都能进到心仪的公司，但要挑一个作为职业生涯的起点，委实是个难题。</p><p>困扰了快一个月了，选到自闭，最近一个月平均每10天会有条相关的pyq🤦‍♂️</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/hestitate.png" style="zoom:30%;"><p>拖拖拉拉的可真不是我的风格，不准备再拖下去了，昨天老板得知我想换去工程也找我聊了一小时，今天冷静下来再好好梳理下利害关系，确定下来后，就不再回头啦</p><blockquote><p> 其实心里已经有答案了，只是想确认自己是否真的想清楚了，也想给有类似困惑的学弟学妹们一些启示</p></blockquote><h1 id="About-算法"><a href="#About-算法" class="headerlink" title="About 算法"></a>About 算法</h1><p>老板当时是这样劝我继续做算法的，梳理如下：</p><p>a.客观的角度：</p><ol><li>算法更有挑战，对应人才开的价格更高，看看阿里星有多少是算法多少是研发</li><li>算法的价值更大，很多工程问题是由算法引发出来的</li><li>公司更重视，算法比工程晋升容易</li><li>算法肯定存在不确定性，但是，都是有套路的，掌握方法大概率是能出成果的<ol><li>也正是因为这个不确定性，能够拉开和别人的差异，能够做出亮眼工作</li><li>刚起步没有掌握套路时，确实容易有比较强的挫败感</li></ol></li></ol><p>b.主观的角度：</p><ol><li>老板说他见过很多从算法工程/数据/业务工程想转算法的同学，但算法转研发的我是第一个<ol><li>给我说了大部分人想转算法的原因是：需求做多了，确定性很强，和别人能力差异不明显，想转算法的都是自认为聪明的/数理基础好的</li></ol></li><li>算法换到工程还容易些，但工程到算法很难，举了个社招的例子，做算法工程的老哥如果面工程能拿7，到他这面算法最多给到6，让我好好想清楚</li></ol><p>然后说完了又说我是适合做算法的，我又追问了具体的原因，他说有这些素质的人适合做算法，答：</p><ol><li>数理基础好的，包括推理、逻辑分析</li><li>发散性思维好的</li></ol><p>结合自己工作的情况，确实这两点对做算法而言很重要，思维是否足够发散决定了能否在现有领域提出新的idea，而数理基础则是讨论这个idea可行性的必要保障</p><p>最后老板说，假如我真的想转工程，建议我不要做偏业务的，挑战小，难拿到亮眼工作，要做也做偏底层些的，比如引擎，但这和我自己的技术栈/过往经历又不太搭，底层一般都是C/C++</p><h1 id="About-工程"><a href="#About-工程" class="headerlink" title="About 工程"></a>About 工程</h1><p>在这阐述下我的一些想法吧，针对上面提到的几个点：</p><ol><li><p>a1确实是现状，但要想拿到更高薪水与发表的paper质量密切相关，竞赛的话语权并不重，只要0 paper基本就告别这些啦，而且即使实习可以投出一篇顶会paper，但因为时间的关系也并不能在秋招结束之前得到结果</p><ol><li>再从薪资的角度出发，现在低级别算法和研发的差距越来越小，以阿里为例，去年同级别的校招算法只比开发高了1k，5%，一年下来可能也就少一个月工资，这点差距去个绩效好的部门分分钟抹平</li></ol></li><li><p>a2不置可否</p></li><li><p>a3晋升的话，可能确实算法比较容易，不过个人自身的影响因素可能更大（嗯，老板影响也很大），从我的角度出发还是做自己擅长的吧</p><ol><li><p>这里有个点是说，算法的老板感觉并不在意工程上的实现，所以我工程的优势发挥不上，但反过来，工程的老板不一样，如果你能发掘出一些算法能用的上的地方，稍微搞一搞，这不就好起来了嘛</p><blockquote><p><strong>从老板的角度出发，算法会点工程没啥，工程会点算法就挺不错</strong></p></blockquote></li></ol></li><li><p>a4的不确定性这，确实双刃剑，做的好的人可以很快与其他人拉开差距，但做的不好的呢？我现在了解到算法内部的竞争还挺激烈的，都说面算法神仙打架，那进来了之后呢？大家都是顶会/顶赛/顶校，是要和神仙打一辈子架的，做过那么多算法相关的事也大概有数在和同行竞争的时候是否能够脱颖而出</p><blockquote><p>校招面试不是终点，仅仅只是个起点👊</p></blockquote></li><li><p>b1的话，首先大流的选择并不一定是对的（羊群效应），其次我老板作为算法的leader，他能接触到的当然都以工程转算法为主，算法转工程找的也是别家工程的老板不是。。。</p><ol><li>后来我反驳说我有个也是阿里的学长干了一年算法，后面跳去了工程，老板回我：你接触的人都还和你差不多岁数，可能他们自己也还有和你一样的迷惑，是不准确的哦，emm这个说法也有道理</li></ol></li><li><p>b2，社招之后无论是算法转工程还是工程转算法都难，代价都很大，校招决定了之后就别回头了吧</p></li><li><p>其实最让我在意/犹豫的是老板说的最后一个点：偏业务的工程挑战小，难拿亮眼工作，这个我现在能想到的解法就是，首先不去太没挑战的部门，其次用自己的算法能力去赋能，去创造差距</p><ol><li>感觉这话说的也有点片面，这不等于否认了做研发的高p们嘛😌</li></ol></li></ol><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>从写作的文风也能看出心里偏向的选项了，每一点都在试图找反驳的点，害，心里想干啥还没点数吗</p><p>大概最想让我转工程的原因有两个吧，按优先级排序如下：</p><ol><li>我的算法能力可以赋能工程，而反过来却不行，再直白些，我觉得我做工程能取得的成绩会大于算法</li><li>工程的确定性，或者绩效/晋升的确定性</li><li>也算给自己找个后路，要是以后30+了想跳去外企，研发比较容易，外企在国内的算法很少</li></ol><blockquote><p> 其实迟迟下不了决心的很大原因还是  当大家都想去算法，而你放弃了这个大家都追求的选项，这个是很难的，几乎所有人听闻都会问你为什么，而研发转算法就不会有人过问。。。现实哈哈，想到自己以前保研选学校，大家都说去交大，然后我偏偏选了更容易的选项，不过我觉得当时的决定非常地正确，至少从现在来看是如此</p></blockquote><p>害，选来选去，我觉得说不后悔是不可能的，没有走过的路永远会更好，至少follow your heart吧</p><p>最后贴一个老哥的回复，深感赞同：</p><blockquote><p>说一下我的看法吧，仅供参考。<br>算法的特点是投入大风险高，赢者通吃。算法对数学能力，开发能力，独立研究能力都有很高的要求，同时对于平台（实验室或者公司）的依赖性也更强。能力强，能把算法落地到项目中的算法工程师在市场上溢价很高，供不应求，但是普通水平的算法工程师在市场上处境比同等水平的开发工程师要更加艰难。<br>举个例子的话，开发进谷歌微软，你只需要题刷得够溜就可以了，算法的话，得有好的实验室或者好的论文背景，同时刷题也不能拉下。<br>对于秋招来说，公司之间的差别比岗位之间的差别要更大，一线外企互联网，一线国内互联网，国企银行，等等，这些公司内部的开发与算法工程师之间的差别要远远小于这些公司之间同一岗位的差别，无论是生活方式还是工资水平。<br>在这个时间点上，哪个方向自己更有把握去自己心仪的公司就选哪个方向好了，至于工作的挑战性，更多的取决于你所处的平台，自身的能力，以及对于工作的态度，而非岗位，不需要太过纠结，除非你有明确的个人喜好。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「20春招总结」</title>
      <link href="/2020/05/30/2020-05-30/"/>
      <url>/2020/05/30/2020-05-30/</url>
      
        <content type="html"><![CDATA[<h1 id="「20春招总结」"><a href="#「20春招总结」" class="headerlink" title="「20春招总结」"></a>「20春招总结」</h1><p>时间真的飞快，转眼又是一年春招，写下这篇回顾小结的时候，已经在蚂蚁入职了一周，还是挺感慨的，由于种种权限的原因，目前做的事和自己想的并不完全一样，也不知是好是坏，现在再看去年的春招小结，还是历历在目，去年面的工程，今年面的算法，也算有得有失吧</p><blockquote></blockquote><h3 id="弥补遗憾？"><a href="#弥补遗憾？" class="headerlink" title="弥补遗憾？"></a>弥补遗憾？</h3><p>还记得去年阿里在简历面被各种怼，现在估计当时的面试官给的评级是B+吧，虽然非应届影响挺大，但当时面试官给我的整体感觉就不好（于是今年就再也没投cbu旗下的部门了。。。）</p><p>几家公司体验下来阿里的面试体验依然是最糟糕的，各种流程各种鱼塘各种等，前前后后等了大概一个月，相比之下头条3天面完所有流程，腾讯1周，没收到意向书之前真的是心累，到了hr面都不能松口气的那种。当时阿里刚hr面，头条和wx的offer都来了，我都不敢拒，然后要先2选1，还专门在牛客上发了个贴：</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/offer%E6%AF%94%E8%BE%83.png" style="zoom:50%;"><p>现在回过头看，我的速度已经算快了，每一面的间隔都是1周左右，hr面之后一周收到的意向书，最近听到不少hr面之后一个月才收到的，也是刺激</p><p>今年阿里许多部门有提前批面试的说法，通过了可以免一些正式的流程，因为去年的失利，有些忌惮，我还参加了挺多部门的提前面试的，这里不太建议大家参加太多部门的提前批，我个人觉得3-4个部门足够了，一来虽说是双向选择，但如果一个部门交流了很多轮最后不选心里真的过不去，毕竟浪费了对方那么多的时间嘛，二来从积累面试经验的角度来说几轮下来其实经验已经很丰富了，面的多了最大的问题是到最后确认流程的时候，能犹豫好几天，到时候各个部门的老板电话你，wx你，短信你，钉钉你，八仙过海各画大饼，我一没见过世面的小实习生哪里顶得住。</p><p>这里选部门给大家的建议是，最好是找有直系学长学姐在的部门，他们会告诉你实话，其次多参考参考<strong>脉脉</strong>，还是能够排一些雷的，比如广为流传的三个坑部门。。。。</p><blockquote><p>咳，当时不知道脉脉，血亏</p></blockquote><p>个人觉得这时候实习选部门就很重要，因为春招的实习能够转正，也就是秋招的第一个offer，很大概率是你之后会长期工作的部门，而且这个公司你走了转正流程意味着秋招你不能再选择其他部门投递，想换部门一个可行的方法是放弃转正，问了学长说只要双方的老板都同意就能换</p><blockquote><p>我在选部门之前就把怎么换部门的后路给问清楚也是没谁了😷。。。。</p></blockquote><p>感觉阿里的内推人非常重要，靠不靠谱太关键了，我当时的内推人就很靠谱，各种信息秒回，面试推进也很积极，虽然后来很可惜因为方向问题不是我的老板，希望以后还有机会，这几天观察下来确实是个很nice的老板。</p><blockquote><p>打个广告，究极靠谱的内推人，3年8的阿里星本星：<a href="https://www.nowcoder.com/discuss/389136；https://www.nowcoder.com/discuss/389152" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/389136；https://www.nowcoder.com/discuss/389152</a></p></blockquote><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>翻了自己的pyq，4.18收到阿里意向书宣告了今年的春招结束，还是挺可惜的当时没能及时写点东西，等到现在入职以后心境又不一样了，很多当时想说的想写的，现在也没了兴致。</p><p>整个春招从1月开始准备，到3月集中面试，再到4月结束，投递的都是精挑细选后想去的公司里想去的部门，蚂蚁的支付宝、腾讯的wxg、头条的广告，作为一个0 paper的同学，来面算法岗风险其实挺大的，好在竞赛还算有点成绩，幸运的都拿到了算法岗offer。刚看了眼腾讯的暑期实习的数据，算法岗竞争真的激烈，看了几个技术岗的数据发现后端报录比7:1是最高的</p><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E6%8A%A5%E5%BD%95%E6%AF%942.png" style="zoom:50%;"><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E6%8A%A5%E5%BD%95%E6%AF%941.png" style="zoom:55%;"></p><p>这个时候又想起去年横扫算法研发offer 的胡神最后也没选择干算法，我到现在也不确定自己是不是真的适合做算法，以后是不是真的要走这条路，这是我想干的事情吗？</p><blockquote><p> 希望这次3个月的实习能带给我答案。</p></blockquote><p>现在每天干的事主要做算法的调研，整天都在看各种recsys的paper，目标是发一篇paper，也不知道我这没怎么搞过科研的菜鸡能不能写得出来，不管怎样还是不想辜负mentor和老板的期待呢🤜</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/2020offer.jpeg" style="zoom:50%;"><p>拭目以待</p><p>不得不说，跳出舒适圈的过程还是痛苦的</p><p>以最近一首喜欢的歌的歌词做结尾</p><p>时间会回答成长，成长会回答梦想，梦想会回答生活，生活回答你我的模样   ——《入海》</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.25阿里笔试的一些思考</title>
      <link href="/2020/03/26/2020-03-26/"/>
      <url>/2020/03/26/2020-03-26/</url>
      
        <content type="html"><![CDATA[<p>阿里今年新增加了所有人都要完成的笔试，我参加的是3.25下午的场次，结果做的不是很好，痛定思痛，确实暴露了一些问题，之后的反思如下：</p><hr><h1 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h1><p>首先回顾一下两道题目与做题时的心路历程：</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>截图来源：<a href="https://www.nowcoder.com/discuss/391503?type=0&amp;order=0&amp;pos=10&amp;page=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/391503?type=0&amp;order=0&amp;pos=10&amp;page=1</a></p><p><img src="https://uploadfiles.nowcoder.com/images/20200325/8531865_1585126580649_EF059361283FE473A2B5A281654A181C" alt></p><p>最开始拿到这道题其实我脑海里有好多种思路：</p><ol><li>一是把它转换成图论中的最短路径的问题求解，相当于每一列都要选择一个节点，构成通路，路之间的边权就是对应的绝对值；</li><li>二是贪心、dp好像也都能做</li></ol><p>这样大概思考了5分钟，决定用贪心解（也反思了为什么会优先选择用贪心做，见下文）🤦‍♂️。。。</p><blockquote><p>笔试完后一位大佬前辈和我说，一般能用dp解的如果用贪心都是错的，确实如此</p></blockquote><p>于是乎我当时笔试时写的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    row, col = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    ans = <span class="number">99999999</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        pre = matrix[idx][<span class="number">0</span>]</span><br><span class="line">        single = <span class="number">0</span></span><br><span class="line">        test = [pre]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, col):</span><br><span class="line">            a = abs(pre - matrix[<span class="number">0</span>][i])</span><br><span class="line">            b = abs(pre - matrix[<span class="number">1</span>][i])</span><br><span class="line">            c = abs(pre - matrix[<span class="number">2</span>][i])</span><br><span class="line">            tmp_min = min(min(a,b),c)</span><br><span class="line">            single += tmp_min</span><br><span class="line">            <span class="keyword">if</span> tmp_min == a:</span><br><span class="line">                pre = matrix[<span class="number">0</span>][i]</span><br><span class="line">            <span class="keyword">elif</span> tmp_min == b:</span><br><span class="line">                pre = matrix[<span class="number">1</span>][i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = matrix[<span class="number">2</span>][i]</span><br><span class="line">            test.append(pre)</span><br><span class="line">        ans = min(ans, single)</span><br><span class="line">        <span class="keyword">if</span> single == ans:</span><br><span class="line">            print(test)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>当时的贪心策略是每次选择与上一次abs距离最小的点作为下一次的点，其实贪心无法保证每次都得到最优解，一是这个问题无法通过反证法证明它具有贪心选择性质，二来很容易就能举出反例，如如5 6 2 2 2 2 2，那此时第二列就不会选到和5最接近的，而会选和2最接近的，所以正解应该用dp，可以保证每次都是全局最优解</p><blockquote><p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p></blockquote><p>当时用贪心写完代码再调试完过了测试case大概已经过去了20+分钟，第一次提交发现只过了5%，又提交了一次发现到10%了，于是开始怀疑是不是时间复杂度上刚好卡在一些case 的边缘，于是开始优化代码（当时并没有意识到是贪心不一定得到全局的最优解）。。。。又折腾了一会儿时间复杂度已经是o(3n)了，还是10%，决定放弃。此时时间已经过去了40分钟了。。。导致在后面第二题并不难的只是代码量较大的情况下，没能写完😵</p><p>结束之后看见讨论说第一题应该用dp，于是自己又去推dp的式子。。。不到3分钟就推出来了，然后很顺利地写完了代码，前前后后不超过20分钟，如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dp[i][j]表示以第i行第j列为最后个数字的最小邻差</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    row, col = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">99999999</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(col)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(row)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, col):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="comment"># 相比于贪心，最大的区别在这里，这样才能保证得到全局最优解</span></span><br><span class="line">            dp[j][i] = min(dp[j][i], dp[<span class="number">0</span>][i<span class="number">-1</span>]+abs(matrix[j][i] - matrix[<span class="number">0</span>][i<span class="number">-1</span>]))</span><br><span class="line">            dp[j][i] = min(dp[j][i], dp[<span class="number">1</span>][i<span class="number">-1</span>]+abs(matrix[j][i] - matrix[<span class="number">1</span>][i<span class="number">-1</span>]))</span><br><span class="line">            dp[j][i] = min(dp[j][i], dp[<span class="number">2</span>][i<span class="number">-1</span>]+abs(matrix[j][i] - matrix[<span class="number">2</span>][i<span class="number">-1</span>]))</span><br><span class="line">    ans = <span class="number">9999999</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">        ans = min(ans, dp[i][col<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="viterbi-算法"><a href="#viterbi-算法" class="headerlink" title="viterbi 算法"></a>viterbi 算法</h3><p>这道题确实可以用最短路的思想求解，具体的求法就是用viterbi 算法。</p><p><strong>维特比算法</strong> (Viterbi algorithm) 是机器学习中应用非常广泛的动态规划算法，在求解<a href="https://mp.csdn.net/postedit/87867916" target="_blank" rel="noopener">隐马尔科夫</a>、条件随机场的预测以及seq2seq模型概率计算等问题中均用到了该算法。实际上，维特比算法不仅是很多自然语言处理的解码算法，也是现代数字通信中使用最频繁的算法。</p><blockquote><p>好吧，因为不是NLP方向，所以对这块不熟。维特比算法其实就是上面的dp思想，我想NLP方向的小伙伴刷到这道题应该都笑出声了吧，一模一样</p></blockquote><p>具体的算法细节可以查看<a href="https://www.zhihu.com/question/20136144?sort=created" target="_blank" rel="noopener">如何通俗地讲解 viterbi 算法？</a></p><p>这里就放一个非常清晰地转化为最短路去做的示意图吧，连行数都能对上😰只不过在隐马的场景下求解的是最大的概率，而在这道题求解的是最小的和，max和min的区别吧（隐马简单来说就是通过已知的可以观察到的序列，和一些已知的状态转换之间的概率情况，通过综合状态之间的转移概率和前一个状态的情况计算出概率最大的状态转换路径，从而推断出隐含状态的序列的情况。）</p><p><img src="https://pic4.zhimg.com/80/v2-accc8823ff890dd98620f6617e0cfe28_1440w.jpg" alt></p><hr><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>没写完的第二题思路相对固定，一看就是老老实实模拟。</p><p>题目描述：<br>给定一个矩阵n*m，每行每列都是等差数列，但是有部分值是被隐藏了的，数值为0即是被隐藏了。<br>根据输入的值i，j，判断这个位置上的值是否可以被推导出来，可以就输出，否则输出Unknown</p><p>输入描述：<br>第一行三个整数，代表n、m、q<br>接下来n行，代表二维数组矩阵A[n*m]<br>接下来q行，每行两个整数i，j，访问矩阵中的可能值A[i][j]</p><p>输出描述：<br>输出q行<br>若能推导出来对应位置的矩阵元素值，返回该值<br>若无法推导出来，返回Unknown</p><p>示例输入：<br>2 3 6<br>1 0 3<br>0 0 0<br>1 1<br>1 2<br>1 3<br>2 1<br>2 2<br>2 3<br>12<br>34<br>56<br>78<br>910</p><p>示例输出：<br>12<br>3Unkown<br>Unkown<br>Unkown</p><p>结束后又花了十分钟左右才写完，如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(matrix, down_row, down_col)</span>:</span></span><br><span class="line">    row, col = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    next_row, next_col = set(), set()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> down_row: <span class="keyword">continue</span></span><br><span class="line">        val = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] != placeholder:</span><br><span class="line">                val.append((j, matrix[i][j]))</span><br><span class="line">                <span class="keyword">if</span> len(val) &gt; <span class="number">1</span>:</span><br><span class="line">                    d = (val[<span class="number">1</span>][<span class="number">1</span>] - val[<span class="number">0</span>][<span class="number">1</span>]) / (val[<span class="number">1</span>][<span class="number">0</span>] - val[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                    next_row.add((i, val[<span class="number">0</span>][<span class="number">1</span>] - val[<span class="number">0</span>][<span class="number">0</span>] * d, d))  <span class="comment"># (行号,首相，公差)</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(col):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> down_col: <span class="keyword">continue</span></span><br><span class="line">        val = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">if</span> matrix[j][i] != placeholder:</span><br><span class="line">                val.append((j, matrix[j][i]))</span><br><span class="line">                <span class="keyword">if</span> len(val) &gt; <span class="number">1</span>:</span><br><span class="line">                    d = (val[<span class="number">1</span>][<span class="number">1</span>] - val[<span class="number">0</span>][<span class="number">1</span>]) / (val[<span class="number">1</span>][<span class="number">0</span>] - val[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                    next_col.add((i, val[<span class="number">0</span>][<span class="number">1</span>] - val[<span class="number">0</span>][<span class="number">0</span>] * d, d))  <span class="comment"># (列号,首相，公差)</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> next_col, next_row</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span></span><br><span class="line">    row, col = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    down_row, down_col = set(), set()</span><br><span class="line">    next_col, next_row = search(matrix, down_row, down_col)</span><br><span class="line">    <span class="keyword">while</span> next_col <span class="keyword">or</span> next_row:</span><br><span class="line">        <span class="comment"># 先填所有的行</span></span><br><span class="line">        <span class="keyword">if</span> next_row:</span><br><span class="line">            <span class="keyword">for</span> idx, a, d <span class="keyword">in</span> next_row:</span><br><span class="line">                matrix[idx] = [a + i * d <span class="keyword">for</span> i <span class="keyword">in</span> range(col)]</span><br><span class="line">                down_row.add(idx)</span><br><span class="line">        <span class="comment"># 再填所有的列</span></span><br><span class="line">        <span class="keyword">if</span> next_col:</span><br><span class="line">            <span class="keyword">for</span> idx, a, d <span class="keyword">in</span> next_col:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">                    matrix[i][idx] = a + i * d</span><br><span class="line">                down_col.add(idx)</span><br><span class="line">        <span class="comment"># print(down_row, down_col)</span></span><br><span class="line">        next_col, next_row = search(matrix, down_row, down_col)</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line"></span><br><span class="line">placeholder = <span class="number">-99999999999</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n, m, q = map(int, input().split())</span><br><span class="line">    matrix = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        matrix.append(list(map(int, input().replace(<span class="string">'0'</span>, str(placeholder)).split())))</span><br><span class="line">    matrix = helper(matrix)</span><br><span class="line">    <span class="comment"># print(matrix)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(q):</span><br><span class="line">        a,b = map(int, input().split())</span><br><span class="line">        a -= <span class="number">1</span></span><br><span class="line">        b -= <span class="number">1</span></span><br><span class="line">        ans = matrix[a][b] <span class="keyword">if</span> matrix[a][b] != placeholder <span class="keyword">else</span> <span class="string">"Unknown"</span></span><br><span class="line">        print(ans)</span><br></pre></td></tr></table></figure><p>后来看了讨论说只用扫描三次即可填充完整个等差矩阵，行列行/列行列都可以。见：<a href="https://blog.csdn.net/qq_27003337/article/details/105100534" target="_blank" rel="noopener">https://blog.csdn.net/qq_27003337/article/details/105100534</a></p><p>再看了看我自己写的，复杂度其实是一样的，只不过每次我都会判断下一次是否产生能够更新的行/列，没有的话结束循环，算了下这道题从开始写到最后写完过测试的case共花时40分钟左右，确实代码量比较大</p><p>网上很多通过90%case 的，问题应该在于原本矩阵中的0，有时候它就真的是0，所以在一开始我直接用大于数据范围的值去填充，这样就不会出现误判了</p><p>这题委实没啥难的，模拟就完事了，好可惜，没能写完</p><blockquote><p>早知道先写第二题了Orz,这样过个90%也还过得去</p></blockquote><hr><h2 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h2><p>回顾完了心路历程，有一些感悟：</p><ol><li><p>当得知第一题用dp可以解的时候，3分钟就推出了递推式，但笔试时不确定用哪种方法时，就没想到了。这个很有意思，换句话说这道题如果出现在面试的场景就一定能写出来，因为面试时你会和面试官交流你的思路，面试官会及时纠正错误的思路，所以你下笔的时候思路一定是正确的。说到底还是刷的题不够多吧，现在虽然可以独立解决dp类中上难度的问题，但是对这个问题究竟采用何种方法的选择上还需多加训练</p></li><li><p>当时也反思了为什么笔试的时候想到过用dp，最后却没用呢，可能有点先入为主的思想，之前阿里的两场笔试我也做了，难度中上吧，大体的方向如下：</p><ol><li>第一场的第一题dfs模拟，第二题sort之后直接LCS的dp；</li><li>第二场第一题找规律推公式加快速幂，第二题多加了个状态的bfs</li></ol><p>然后有个前辈给所有的题目大概分了个类，他原话这样写的：</p><blockquote><p>阿里笔试考的太宽泛了，你可以先把基础的模板题都做做。从基础算法，如二分，前缀和，排序；到基础数据结构，单调栈，单调队列，字符串哈希，trie，树状数组；再到贪心动规，贪心的可以刷点区间覆盖题，动规的太多了，背包dp，状压dp，区间dp等等；然后是搜索题，bfs刷点迷宮题，dfs刷树遍历的，然后就是图论的，最短路，二分图，强联通都做做，剩下就是数学题了，快速幂，逆元，筛素数</p></blockquote><p>于是乎第三场我在做之前就觉得有比较大的概率会考察贪心，毕竟dfs，bfs，dp，快速幂都考过了。。。。。这也导致了在第一题没有考虑的非常全面的情况下直接上手撸了贪心的算法，先入为主的思想太危险了，以后需要避免，这样的心理暗示容易出问题。</p></li><li><p>时间管理，没有控制好每道题的时间分配，导致最后只有20分钟，然后第二题乍一看比较长的时候就有点慌了，整个心理状态就不一样，越急越容易出bug，bug越多写得越慢，如此恶性循环。当题目数量少的时候和多的时候又是不同的管理策略，以后需要严格设定每道题的止损时间，这次如果在30min时开始做第二题，或许就能顺利写完了。</p></li></ol><hr><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>感慨一下阿里的笔试风格确实很独特，题目都是好题，值得推敲，不过这种1小时2道middle+难度的题对大家要求非常高，如果按面试的编程准备多半是做不出的。而且没有简单的题帮助你快速进入状态了，而做笔试其实挺吃状态的。</p><p>回忆了下之前保研也好，找实习也好，打的leetcode周赛也好，经历过的大大小小的笔试，这次是做的最差的，哎，痛定思痛，这下真是给后面的面试带来了很大的压力啊🤯本来面蚂蚁就是个比较激进的策略，现在难度又更上一层楼了，服了自己。。。。</p><p>现在回过头来看看，那天真的特别的忙，下午阿里笔试，晚上鹅厂微信的复试，真的是累炸，白天准备笔试，笔试完之后的两三个小时再准备准备面试，其实做完笔试心态已经有点崩了，幸好迅速调整了过来，投入到了晚上的面试，有惊无险，面完系统的状态就更新了，下一轮说是终面的面委会，听起来很厉害的样子，想起去年自己面pcg 的时候两轮技术就offer了，没有经历过这个状态，有点激动又有点紧张，不愧是wxg，不知道和阿里的交叉面是不是类似的。</p><p>各种意义上来讲下周都非常的关键，或许是备战春招的最后一周了，调整好状态，再复习一轮，在笔试失利的巨大劣势下，反败为胜，打好最后的仗💪</p><blockquote><p>稳住， 我们能赢</p></blockquote><p>最后贴上某(～￣(OO)￣)ブ给我画的锦鲤2.0</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E9%94%A6%E9%B2%A42020.jpg " style="zoom:36%;"><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>最后还是幸运地成功顶住了压力，都拿到了offer，具体见「20春招总结」啦~🎏</p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle NFL Big Data Bowl Resume</title>
      <link href="/2020/01/09/2020-01-09/"/>
      <url>/2020/01/09/2020-01-09/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>先贴上比赛地址：<a href="https://www.kaggle.com/c/nfl-big-data-bowl-2020" target="_blank" rel="noopener">https://www.kaggle.com/c/nfl-big-data-bowl-2020</a></p><p>比赛大意是在美式橄榄球比赛中🏉，需要对进攻方每一轮跑动推进的码数进行预测，比较在意的是这个问题的评价指标很奇特，用到了分级概率函数，具体见<a href="https://baike.baidu.com/item/%E8%BF%9E%E7%BB%AD%E5%88%86%E7%BA%A7%E6%A6%82%E7%8E%87%E8%AF%84%E5%88%86/23690953?fr=aladdin" target="_blank" rel="noopener">连续分级概率评分</a>，相应的，我们既可以把它处理成199个分类的多分类问题，也可以处理成回归问题，这里操作的空间就很大了。同时最后的B榜来源于12月到1月即将举办的比赛，是未来的数据，这带来了更大的挑战。</p><p>此外该赛题是kernal based，选手最后提交的是一个.ipynb的可运行jupyter文件，也就是说每次预测会重新跑这段代码，训练新的模型并进行预测，而比赛对应的训练集也会随着比赛的进行，B榜的更新而更新，会把新的比赛数据加入到训练集之中，这带来的挑战是需要我们为增量的数据预留好空间和时间复杂度（单个kernal可执行时间需小于4小时，最大内存16G）</p><hr><h1 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a>DATA</h1><p>先附上原始数据的数据词典，对于美式橄榄球不熟悉的可以参考 <a href="https://baike.baidu.com/item/%E7%BE%8E%E5%BC%8F%E6%A9%84%E6%A6%84%E7%90%83/934574?fr=aladdin" target="_blank" rel="noopener">美式橄榄球</a></p><p>数据源：<a href="https://www.kaggle.com/c/nfl-big-data-bowl-2020/data" target="_blank" rel="noopener">https://www.kaggle.com/c/nfl-big-data-bowl-2020/data</a></p><ul><li><p><code>GameId</code> - a unique game identifier 比赛ID</p></li><li><p><code>PlayId</code> - a unique play identifier 一场比赛中所有play的ID（每次play都有可能得分）</p></li><li><p><code>Team</code> - home or away 队名</p></li><li><p><code>X</code> - player position along the long axis of the field. See figure below.</p></li><li><p><code>Y</code> - player position along the short axis of the field. See figure below.<br><img src="https://www.googleapis.com/download/storage/v1/b/kaggle-user-content/o/inbox%2F3258%2F7542d363a19fa3eea77708e6b90bc420%2FFig1.png?generation=1570562067917019&alt=media" alt="img"></p><blockquote><p>NFL和NCAA使用的标准球场是一个长360英尺（120码或109.7米）、宽160英尺（53.33码或48.8米）的长方形草坪（有些室内赛会使用仿草地毯），较长的边界称为边线（sideline），较短的边界称为端线（end line）。端线前的标示线称为得分线（goal line），球场每侧端线与得分线之间有一个纵深10码（9.1米）的得分区叫做端区（end zone，也称达阵区），端区的四角各有一个约有1英尺长的橙色长方体标柱（pylon）。两侧得分线相距100码（91.44米），之间的区域也就是比赛区（playing field）。比赛区上距离得分线每5码（4.6米）距离标划一条码线（yard line，或称5码线），每10码标示数字，直到50码线到达中场（midfield）。在球场中间和两侧与边线平行排列划有横向的短标示线，称为码标（hash marks，或称整码线），其中接近边线的码标线称为界内线（inbounds line）。任何球员都必须在码标线上或之间进行发球。</p></blockquote></li><li><p><code>S</code> - speed in yards/second 此时的速度</p></li><li><p><code>A</code> - acceleration in yards/second^2 加速度</p></li><li><p><code>Dis</code> - distance traveled from prior time point, in yards</p></li><li><p><code>Orientation</code> - orientation of player (deg) 玩家面对的方向</p></li><li><p><code>Dir</code> - angle of player motion (deg) 玩家移动的方向</p></li><li><p><img src="https://www.googleapis.com/download/storage/v1/b/kaggle-user-content/o/inbox%2F75976%2F277b02ac1a245d56362715d8a550fb74%2Forientation.png?generation=1571665174994396&alt=media" alt="img"></p></li><li><p><code>NflId</code> - a unique identifier of the player 运动员ID</p></li><li><p><code>DisplayName</code> - player’s name 运动员name</p></li><li><p><code>JerseyNumber</code> - jersey number 运动员号码</p></li><li><p><code>Season</code> - year of the season</p></li><li><p><code>YardLine</code> - the yard line of the line of scrimmage 发球的码线</p></li><li><p><code>Quarter</code> - game quarter (1-5, 5 == overtime) 比赛所处的时间</p></li><li><p><code>GameClock</code> - time on the game clock </p></li><li><p><code>PossessionTeam</code> - team with possession 当前拥有控球权的队伍</p></li><li><p><code>Down</code> - the down (1-4)</p><blockquote><p>进攻方有四次机会向前方（防守方的端区）累计推进10码，每次机会称为一“<strong>档</strong>” 进攻（down，即被对方拦截放倒一次的机会）。当进攻方成功的在四档进攻内推进了10码以上，便可获得新的四档进攻机会——称为获得新的 “<strong>首档</strong>”（1st down，也称<strong>首攻</strong>）。通过不断获得新的首攻，进攻方可以进行连续的系列进攻向前不断推进，直至得分。而防守方的目的也很简单——就是尽可能阻止对方在四档进攻内推进足够的距离，逼迫其交换控球权。</p></blockquote></li><li><p><code>Distance</code> - yards needed for a first down 距离新的首攻所需要的码数</p></li><li><p><code>FieldPosition</code> - which side of the field the play is happening on play发生在哪个球队的半场</p></li><li><p><code>HomeScoreBeforePlay</code> - home team score before play started 主队已经获得的比分</p></li><li><p><code>VisitorScoreBeforePlay</code> - visitor team score before play started 客队已经获得的比分</p></li><li><p><code>NflIdRusher</code> - the <code>NflId</code> of the rushing player 进攻方持球选手ID</p></li><li><p><code>OffenseFormation</code> - offense formation</p></li><li><p><code>OffensePersonnel</code> - offensive team positional grouping 进攻队员</p></li><li><p><code>DefendersInTheBox</code> - number of defenders lined up near the line of scrimmage, spanning the width of the offensive line</p></li><li><p><code>DefensePersonnel</code> - defensive team positional grouping 防守队员</p></li><li><p><code>PlayDirection</code> - direction the play is headed</p></li><li><p><code>TimeHandoff</code> - UTC time of the  handoff 传球时间</p></li><li><p><code>TimeSnap</code> - UTC time of the snap 发球的时间</p></li><li><p><strong><code>Yards</code> - the yardage gained on the play (you are predicting this)</strong> 得分，即最后预测的y</p></li><li><p><code>PlayerHeight</code> - player height (ft-in)</p></li><li><p><code>PlayerWeight</code> - player weight (lbs)</p></li><li><p><code>PlayerBirthDate</code> - birth date (mm/dd/yyyy)</p></li><li><p><code>PlayerCollegeName</code> - where the player attended college</p></li><li><p><code>Position</code> - the player’s position (the specific role on the field that they typically play)</p></li><li><p><code>HomeTeamAbbr</code> - home team abbreviation 主队缩写</p></li><li><p><code>VisitorTeamAbbr</code> - visitor team abbreviation</p></li><li><p><code>Week</code> - week into the season 赛季的第几周</p></li><li><p><code>Stadium</code> - stadium where the game is being played</p></li><li><p><code>Location</code> - city where the game is being player</p></li><li><p><code>StadiumType</code> - description of the stadium environment 体育馆类型</p></li><li><p><code>Turf</code> - description of the field surface 场地类型</p></li><li><p><code>GameWeather</code> - description of the game weather</p></li><li><p><code>Temperature</code> - temperature (deg F)</p></li><li><p><code>Humidity</code> - humidity 湿度</p></li><li><p><code>WindSpeed</code> - wind speed in miles/hour</p></li><li><p><code>WindDirection</code> - wind direction</p></li></ul><hr><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ol><li><p>play的特征和每个球员的特征如何统一进模型中</p><ol><li><p>NN可以对不同size 的特征进行处理,可以分别将球员特征进行embeding</p></li><li><p>play的特征中加入rusher的特征作为球员特征</p></li><li><p>play的特征中加入每一个球员的所有特征，不建议（球员特征多的时候*22 引入大量噪声），更好的方案是对球员进行聚合（agg）形成特征</p></li></ol></li><li><p>多分类问题如何形成评价指标</p><ol><li><p>连续分级概率评分（Continuous Ranked Probability Score, CRPS），按CRPS评价概率模型所得的（优劣）结果与按MAE评价概率模型的数学期望所得的结果等价，train model时用mae</p></li><li><blockquote><p>值得注意的是sklearn中的MAE是负值，原因：因为有些score是越大越好，比如roc_auc,但有些越小越好比如各种loss，为了统一，sklearn为最小化的值加了负号转化为最大化的问题，这里需要相应地修改网格里的初始化参数</p></blockquote></li></ol></li><li><p>整个数据集虽然有五十几万，但每场play都对应了22个球员，整理下来play的数据量只有23171 * 72，会造成过拟合，怎么避免</p></li><li><p>预测上的难点，最后的B榜训练集会加入未来一个月新的比赛数据，kernal based比赛需要做好时间和空间复杂度的控制</p></li><li><p>关于运动员的运动方向，进攻方可能向左可能向右，此时需要对yard进行转换，处理时有个trick是将X,y,角度都进行翻转，保证进攻方的方向始终是一致的以便于特征的处理</p></li></ol><h1 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h1><p>梳理一下问题其实就是，一个rusher，10个队友，11个防守方的竞赛，rusher会尽一切努力冲破防守方防线，对应地防守方会不顾一切跑向rusher以阻止他，队友也需要跑向rusher以协助进攻，因此不难发现距离的特征会很重要。故我们的特征工程主要围绕这一变量展开：</p><ol><li>将进攻方向进行统一，转换对应的yardline、x、y、orientation、direction</li><li>每个play加入rusher的相关特征</li><li>增加球员特征的统计特征agg<br> <code>min&#39;, &#39;max&#39;, &#39;mean&#39;, &#39;std&#39;, &#39;skew&#39;, &#39;median&#39;, q80, q30, pd.DataFrame.kurt, &#39;mad&#39;,np.ptp</code></li><li>将球员分为进攻方和防守方，分别进行距离rusher距离、x、y的聚合统计</li><li>尝试穿越特征：计算队伍历史场均推进，后在lb上未有明显提高，放弃（考虑效果不好的原因：1.测试集队伍和训练集可能不同，有缺失值；2.场均推进受进攻方和防守方共同影响，仅仅根据进攻方计算的推进距离会有失真）</li></ol><blockquote><p>第一名的特征思路总结地更好，见<a href="https://www.kaggle.com/c/nfl-big-data-bowl-2020/discussion/119400#latest-685747" target="_blank" rel="noopener">https://www.kaggle.com/c/nfl-big-data-bowl-2020/discussion/119400#latest-685747</a></p></blockquote><h1 id="model"><a href="#model" class="headerlink" title="model"></a>model</h1><ol><li><p>NN：</p><ol><li><p>分别处理category和dense的NN，效果一般<img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/kaggle/NFL/NN_struct.png" alt="NN_struct" style="zoom: 50%;"></p></li><li><p>用最简单的全连接的NN,自定义损失函数，通过early stopping和dropout降低过拟合</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRPSCallback</span><span class="params">(Callback)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, validation, predict_batch_size=<span class="number">20</span>, include_on_batch=False)</span>:</span></span><br><span class="line">        super(CRPSCallback, self).__init__()</span><br><span class="line">        self.validation = validation</span><br><span class="line">        self.predict_batch_size = predict_batch_size</span><br><span class="line">        self.include_on_batch = include_on_batch</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_batch_begin</span><span class="params">(self, batch, logs=&#123;&#125;)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_train_begin</span><span class="params">(self, logs=&#123;&#125;)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="string">'CRPS_score_val'</span> <span class="keyword">in</span> self.params[<span class="string">'metrics'</span>]):</span><br><span class="line">            self.params[<span class="string">'metrics'</span>].append(<span class="string">'CRPS_score_val'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_batch_end</span><span class="params">(self, batch, logs=&#123;&#125;)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (self.include_on_batch):</span><br><span class="line">            logs[<span class="string">'CRPS_score_val'</span>] = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_epoch_end</span><span class="params">(self, epoch, logs=&#123;&#125;)</span>:</span></span><br><span class="line">        logs[<span class="string">'CRPS_score_val'</span>] = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (self.validation):</span><br><span class="line">            X_valid, y_valid = self.validation[<span class="number">0</span>], self.validation[<span class="number">1</span>]</span><br><span class="line">            y_pred = self.model.predict(X_valid)</span><br><span class="line">            y_true = np.clip(np.cumsum(y_valid, axis=<span class="number">1</span>), <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            y_pred = np.clip(np.cumsum(y_pred, axis=<span class="number">1</span>), <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            val_s = ((y_true - y_pred) ** <span class="number">2</span>).sum(axis=<span class="number">1</span>).sum(axis=<span class="number">0</span>) / (<span class="number">199</span> * X_valid.shape[<span class="number">0</span>])</span><br><span class="line">            val_s = np.round(val_s, <span class="number">8</span>)</span><br><span class="line">            logs[<span class="string">'CRPS_score_val'</span>] = val_s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span><span class="params">(x_tr, y_tr, x_val, y_val)</span>:</span></span><br><span class="line">    inp = Input(shape=(x_tr.shape[<span class="number">1</span>],))</span><br><span class="line">    <span class="comment"># x = Dense(2048, input_dim=X.shape[1], activation='elu')(inp)</span></span><br><span class="line">    <span class="comment"># x = BatchNormalization()(x)</span></span><br><span class="line">    <span class="comment"># x = Dropout(0.5)(x)</span></span><br><span class="line">    <span class="comment"># x = Dense(1024, activation='elu')(x)</span></span><br><span class="line">    x = Dense(<span class="number">1024</span>, input_dim=X.shape[<span class="number">1</span>], activation=<span class="string">'elu'</span>)(inp)</span><br><span class="line">    x = BatchNormalization()(x)</span><br><span class="line">    x = Dropout(<span class="number">0.5</span>)(x)</span><br><span class="line">    x = Dense(<span class="number">512</span>, activation=<span class="string">'elu'</span>)(x)</span><br><span class="line">    x = BatchNormalization()(x)</span><br><span class="line">    x = Dropout(<span class="number">0.5</span>)(x)</span><br><span class="line">    x = Dense(<span class="number">256</span>, activation=<span class="string">'elu'</span>)(x)</span><br><span class="line">    x = BatchNormalization()(x)</span><br><span class="line">    x = Dropout(<span class="number">0.5</span>)(x)</span><br><span class="line">    <span class="keyword">if</span> classify_type &lt; <span class="number">128</span>:</span><br><span class="line">        x = Dense(<span class="number">256</span>, activation=<span class="string">'elu'</span>)(x)</span><br><span class="line">        x = BatchNormalization()(x)</span><br><span class="line">        x = Dropout(<span class="number">0.5</span>)(x)</span><br><span class="line"></span><br><span class="line">    out = Dense(classify_type, activation=<span class="string">'softmax'</span>)(x)</span><br><span class="line">    model = Model(inp, out)</span><br><span class="line">    optadam = Adam(lr=<span class="number">0.001</span>)</span><br><span class="line">    model.compile(optimizer=optadam, loss=<span class="string">'categorical_crossentropy'</span>, metrics=[])</span><br><span class="line"></span><br><span class="line">    es = EarlyStopping(monitor=<span class="string">'CRPS_score_val'</span>,</span><br><span class="line">                       mode=<span class="string">'min'</span>,</span><br><span class="line">                       restore_best_weights=<span class="literal">True</span>,</span><br><span class="line">                       verbose=<span class="literal">False</span>,</span><br><span class="line">                       patience=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">    mc = ModelCheckpoint(<span class="string">'best_model.h5'</span>, monitor=<span class="string">'CRPS_score_val'</span>, mode=<span class="string">'min'</span>,</span><br><span class="line">                         save_best_only=<span class="literal">True</span>, verbose=<span class="literal">False</span>, save_weights_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    bsz = <span class="number">1024</span></span><br><span class="line">    steps = x_tr.shape[<span class="number">0</span>] / bsz</span><br><span class="line"></span><br><span class="line">    model.fit(x_tr, y_tr, callbacks=[CRPSCallback(validation=(x_val, y_val)), es, mc], epochs=<span class="number">100</span>, batch_size=bsz,</span><br><span class="line">              verbose=<span class="literal">False</span>)</span><br><span class="line">    model.load_weights(<span class="string">"best_model.h5"</span>)</span><br><span class="line"></span><br><span class="line">    y_pred = model.predict(x_val)</span><br><span class="line">    y_valid = y_val</span><br><span class="line">    y_true = np.clip(np.cumsum(y_valid, axis=<span class="number">1</span>), <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    y_pred = np.clip(np.cumsum(y_pred, axis=<span class="number">1</span>), <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    val_s = ((y_true - y_pred) ** <span class="number">2</span>).sum(axis=<span class="number">1</span>).sum(axis=<span class="number">0</span>) / (<span class="number">199</span> * x_val.shape[<span class="number">0</span>])</span><br><span class="line">    crps = np.round(val_s, <span class="number">8</span>)</span><br><span class="line">    gc.collect()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model, crps</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Lgbm：<br>预测多标签方法：最本质的区别在于这里的多标签概率的平滑怎么做，第一种直接用lgbm的api意味着让程序自动进行平滑，而第二种手动展开则只通过得到的预测值，自己制定规则展开，第三种介于一二两种之间，通过手动制定分桶的规则，在每个分桶中自动进行平滑。最后采取了第一种方式。</p><ol><li><p>直接用lgbm的api：<a href="https://www.kaggle.com/enzoamp/nfl-lightgbm/code" target="_blank" rel="noopener">https://www.kaggle.com/enzoamp/nfl-lightgbm/code</a></p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;objective&apos;:&apos;multiclass&apos;,</span><br><span class="line">&quot;metric&quot;: &apos;multi_logloss&apos;,</span><br><span class="line">&apos;num_class&apos;: 199,</span><br></pre></td></tr></table></figure></li><li><p>用LGBMRegressor,得到预测值后加函数展开， <a href="https://www.kaggle.com/newbielch/lgbm-regression-view" target="_blank" rel="noopener">https://www.kaggle.com/newbielch/lgbm-regression-view</a><br><a href="https://www.kaggle.com/apiao1/model-lgbm-regression/notebook?scriptVersionId=23357454" target="_blank" rel="noopener">https://www.kaggle.com/apiao1/model-lgbm-regression/notebook?scriptVersionId=23357454</a><br>V4 cv:0.01360 lb:0.01412(不及原文的成绩，原文的cv0.01349,lb0.01401) 应该过拟合很严重，调参应该有较好结果</p></li><li><p>LGBMClassifier + 平滑， <a href="https://www.kaggle.com/mrkmakr/lgbm-multiple-classifier" target="_blank" rel="noopener">https://www.kaggle.com/mrkmakr/lgbm-multiple-classifier</a><br><a href="https://www.kaggle.com/apiao1/model-lgbm-multipleclassifier?scriptVersionId=23397574" target="_blank" rel="noopener">https://www.kaggle.com/apiao1/model-lgbm-multipleclassifier?scriptVersionId=23397574</a><br>V7 效果不好，cv:0.020105, lb:0.02159 ,猜测哪里有bug,(原文：cv:0.013140205432501861，lb:0.01384)</p></li></ol></li></ol><ol start="3"><li><p>RF：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = RandomForestRegressor(bootstrap=<span class="literal">False</span>, max_features=<span class="number">0.3</span>, min_samples_leaf=<span class="number">15</span>, min_samples_split=<span class="number">7</span>,n_estimators=<span class="number">250</span>, n_jobs=<span class="number">-1</span>, random_state=<span class="number">2019</span>)</span><br><span class="line">model.fit(tr_x, tr_y)</span><br></pre></td></tr></table></figure></li></ol><p>关于ensemble：</p><ol><li>效果不理想，采用NN和lgbm的stacking分数与单模型NN相同</li><li>最后的提交用了两个版本，NN-传统的blending,NN和lgb-简单的stacking</li></ol><h1 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h1><ol><li><p>推进距离（Yards）一定小于此时距离得分的距离(Yards_limit)，据此进行后验的处理</p></li><li><p>对训练集统计发现样本标签的分布为-14至99，在-99至-14区间没有任何正例样本，固把预测类别标签缩小至-14到99的范围内</p></li><li><p>NN对数据的变化很敏感，所以可以尝试多次k折的数据分割，用不同的随机数种子去做，本地得到的cv更低</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">losses = []</span><br><span class="line">  models = []</span><br><span class="line">  mean_crps_csv = []</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">      kfold = KFold(<span class="number">9</span>, random_state=<span class="number">2019</span> + <span class="number">17</span> * k, shuffle=<span class="literal">True</span>)</span><br><span class="line">      j = <span class="number">0</span></span><br><span class="line">      crps_csv = []</span><br><span class="line">      <span class="keyword">for</span> k_fold, (tr_inds, val_inds) <span class="keyword">in</span> enumerate(kfold.split(yards)):</span><br><span class="line">          j += <span class="number">1</span></span><br><span class="line">          <span class="keyword">if</span> j &gt; <span class="number">3</span>:</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">          tr_x, tr_y = X[tr_inds], y[tr_inds]</span><br><span class="line">          val_x, val_y = X[val_inds], y[val_inds]</span><br><span class="line">          model, crps = get_model(tr_x, tr_y, val_x, val_y)</span><br><span class="line">          models.append(model)</span><br><span class="line">          <span class="comment"># print("the %d fold crps is %f" % ((k_fold + 1), crps))</span></span><br><span class="line">          crps_csv.append(crps)</span><br><span class="line">      mean_crps_csv.append(np.mean(crps_csv))</span><br><span class="line">      print(<span class="string">"9 folder crps is %f"</span> % np.mean(crps_csv))</span><br><span class="line">   </span><br><span class="line">  print(<span class="string">"mean crps is %f"</span> % np.mean(mean_crps_csv))</span><br></pre></td></tr></table></figure></li><li><p>用贝叶斯调参效果比传统的网格和优化后的启发式网格效果都要更好</p></li></ol><h1 id="What-didn’t-work"><a href="#What-didn’t-work" class="headerlink" title="What didn’t work"></a>What didn’t work</h1><ol><li>没有尝试用CNN处理（事实上确实有效）</li><li>只计算了球员们的相对距离，没有将位置关系和速度加速度转化成相对值，只是做了方向度量上的统一</li><li>没有找到一个稳定的cv评价方式，cv与lb之间变化不一致，导致后期筛选特征很没谱非常乏力</li><li>不同年份的数据权重，2018年数据权重高于2017年数据。</li><li>不同的数据划分方式，尝试根据比赛年份进行groupKfold</li></ol><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><ol><li>打kaggle确实要组队，一个人又要调模型又要做特征真的太花精力了，而且缺少人一起讨论，后期思维就局限了，不利于提升</li><li>队友也挺重要的，这次比赛的队友白天都在上班太忙了Orz</li><li>一个好的baseline能省去不少功夫，由于参加的早（距结束一个月开始做），中间换了好多baseline浪费了很多时间，推荐距离结束14-21天开始为宜</li><li>特征为王</li><li>事先找到一个和lb变化一致的cv事半功倍</li><li>kaggle 的代码工程化思维实在太弱了，大部分都是面向过程，改baseline的时候实在太难过了</li></ol><hr><p>算是kaggle的首战吧，确实投入了很多时间，之前一直处于银牌，很可惜lb最后一天掉出了银牌区，就差两名，最后一天也奋战到深夜（第二天还要早起确定最后的提交），把我能尝试的都尝试了，算是尽了人事，静待最后的结果吧~</p><p>1月6日B榜最后的结果，届时大家会开源自己的代码，到时候进一步对照代码学习提升，明天开始和新队友打新的比赛啦</p><h1 id="冠军方案小结"><a href="#冠军方案小结" class="headerlink" title="冠军方案小结"></a>冠军方案小结</h1><p>刚看了几个高分的方案，其中冠军方案用了CNN进行实现，而且不是传统意义上对图像进行处理，令人印象深刻。<a href="https://www.kaggle.com/c/nfl-big-data-bowl-2020/discussion/119400" target="_blank" rel="noopener">https://www.kaggle.com/c/nfl-big-data-bowl-2020/discussion/119400</a></p><p>再梳理一遍整个大赛的动机：</p><ul><li>一个冲刺者，其目标是尽可能向前冲</li><li>11名试图阻止冲锋队的防守球员</li><li>剩下的10名进攻球员试图阻止防守者阻止或应对冲锋队员</li></ul><p>从中可以得到对预测结果影响较大的排序依次为：rusher -&gt; defender -&gt; offender。画出某个play时场上队员的分布如下：<img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/kaggle/NFL/nfl_1.png" alt></p><p>在比赛的前期只考虑了rusher与defender 的特征，那么它看起来就像是一个简单的游戏，如下图，其中一个玩家试图逃跑，而其他11个玩家试图抓住他。我们假设在比赛开始时，无论防守者的位置如何，每位防守者都将集中精力尽快阻止进攻者，而每位防守者都有机会做到这一点。防守者铲球的机会（以及铲球的估计位置）取决于他们的相对位置，移动速度和运动方向。通过使用相对位置和速度在各个防御者上进行卷积的想法，然后在顶部应用池化压缩。</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/kaggle/NFL/nfl_2.png "><p>之后加入了队友相关的特征，也采用类似的处理。</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>最终的模型结构CNN如下：</p><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/kaggle/NFL/nfl_3.png" alt></p><p>将所有的数据重塑为进攻与防守的张量，且仅用了5个相关的特征，分别是：防守方的加速度、防守方相对于rusher的加速度、位置，进攻方相对于防守方的位置、加速度。考虑到如此处理后整个初始数据集是个10*11*5的三维矩阵，通过CNN的特性恰到好处的进行了压缩与Embeding。</p><blockquote><p>So the first block of convolutions learns to work with defense-offense pairs of players, using geometric features relative to rusher. The combination of multiple layers and activations before pooling was important to capture the trends properly. The second block of convolutions learns the necessary information per defense player before the aggregation. And the third block simply consists of dense layers and the usual things around them. 3 out of 5 input vectors do not depend on the offense player, hence they are constant across “off” dimension of the tensor.</p></blockquote><p>在pooling部分用的是加权组合，即0.7*maxpooling + 0.3 * avgpooling</p><h3 id="数据增强和TTA"><a href="#数据增强和TTA" class="headerlink" title="数据增强和TTA"></a>数据增强和TTA</h3><p>对我们来说真正有效的方法是为Y坐标添加增强和TTA。我们假设在镜像的世界中，运行将具有相同的结果。对于训练，我们应用50％增强来翻转Y坐标（以及由此产生的所有各个相对特征）。对于TTA，我们做同样的事情，我们有50-50的翻转和非翻转推论混合。</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>我们很早就决定最好在内核中进行所有拟合，特别是因为在重新运行中我们还有2019年可用的数据。因此，我们还决定早点花时间优化运行时间，因为我们也知道，在拟合神经网络时，用不同的种子打包多次运行非常重要，因为这通常会显着提高准确性，并消除了一些运气因素。</p><p>如上所述，我们使用Pytorch进行拟合。Kaggle内核有2个具有4个内核的CPU，其中两个内核是真实内核，另外两个是用于超线程的虚拟内核。一次运行使用所有4个内核时，就运行时而言，它并不是最佳选择，因为您无法在合适的情况下对每个操作进行多处理。因此，我们要做的是禁用Python的所有多线程和多处理（MKL，Pytorch等），并在bag级别上进行手动多处理。这意味着我们可以同时拟合4个模型，与在所有4个内核上拟合单个模型相比，可以获得更多的运行时间。</p><p>我们的最终潜艇每个保守地适合8个模型，潜艇的总运行时间低于8500秒。</p><h3 id="CNN伪代码"><a href="#CNN伪代码" class="headerlink" title="CNN伪代码"></a>CNN伪代码</h3><p>评论部分的伪代码，<del>源代码尚未开源</del>，已开源，见更新部分：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputdenseplayers = Input(shape=(<span class="number">11</span>,<span class="number">10</span>,<span class="number">10</span>), name = <span class="string">"numericalplayersfeature_input"</span>)</span><br><span class="line"></span><br><span class="line">x = Conv2D(<span class="number">128</span>, kernelsize=(<span class="number">1</span>,<span class="number">1</span>), strides=(<span class="number">1</span>,<span class="number">1</span>), activation=<span class="literal">None</span>)(inputdense_players)</span><br><span class="line"></span><br><span class="line">x = Activation(<span class="string">'relu'</span>)(x)</span><br><span class="line"></span><br><span class="line">x = Conv2D(<span class="number">160</span>, kernel_size=(<span class="number">1</span>,<span class="number">1</span>), strides=(<span class="number">1</span>,<span class="number">1</span>), activation=<span class="literal">None</span>)(x)</span><br><span class="line"></span><br><span class="line">x = Activation(<span class="string">'relu'</span>)(x)</span><br><span class="line"></span><br><span class="line">x = Conv2D(<span class="number">128</span>, kernel_size=(<span class="number">1</span>,<span class="number">1</span>), strides=(<span class="number">1</span>,<span class="number">1</span>), activation=<span class="literal">None</span>)(x)</span><br><span class="line"></span><br><span class="line">x = Activation(<span class="string">'relu'</span>)(x)</span><br><span class="line"></span><br><span class="line">xmax = MaxPooling2D(pool_size=(<span class="number">1</span>,<span class="number">10</span>))(x)</span><br><span class="line"></span><br><span class="line">xmax = Lambda(<span class="keyword">lambda</span> x1 : x1*<span class="number">0.3</span>)(xmax)</span><br><span class="line"></span><br><span class="line">xavg = AvgPool2D(pool_size=(<span class="number">1</span>,<span class="number">10</span>))(x)</span><br><span class="line"></span><br><span class="line">xavg = Lambda(<span class="keyword">lambda</span> x1 : x1*<span class="number">0.7</span>)(xavg)</span><br><span class="line"></span><br><span class="line">x = Add()([xmax, xavg])</span><br><span class="line"></span><br><span class="line">x = Lambda(<span class="keyword">lambda</span> y : K.squeeze(y,<span class="number">2</span>))(x)</span><br><span class="line"></span><br><span class="line">x = Conv1D(<span class="number">128</span>, kernel_size=<span class="number">1</span>, strides=<span class="number">1</span>, activation=<span class="literal">None</span>)(x)</span><br><span class="line"></span><br><span class="line">x = Activation(<span class="string">'relu'</span>)(x)</span><br><span class="line"></span><br><span class="line">x = BatchNormalization()(x)</span><br><span class="line"></span><br><span class="line">x = Conv1D(<span class="number">160</span>, kernel_size=<span class="number">1</span>, strides=<span class="number">1</span>, activation=<span class="literal">None</span>)(x)</span><br><span class="line"></span><br><span class="line">x = Activation(<span class="string">'relu'</span>)(x)</span><br><span class="line"></span><br><span class="line">x = BatchNormalization()(x)</span><br><span class="line"></span><br><span class="line">x = Conv1D(<span class="number">96</span>, kernel_size=<span class="number">1</span>, strides=<span class="number">1</span>, activation=<span class="literal">None</span>)(x)</span><br><span class="line"></span><br><span class="line">x = Activation(<span class="string">'relu'</span>)(x)</span><br><span class="line"></span><br><span class="line">x = BatchNormalization()(x)</span><br><span class="line"></span><br><span class="line">xmax = MaxPooling1D(pool_size=<span class="number">11</span>)(x)</span><br><span class="line"></span><br><span class="line">xmax = Lambda(<span class="keyword">lambda</span> x1 : x1*<span class="number">0.3</span>)(xmax)</span><br><span class="line"></span><br><span class="line">xavg = AvgPool1D(pool_size=<span class="number">11</span>)(x)</span><br><span class="line"></span><br><span class="line">xavg = Lambda(<span class="keyword">lambda</span> x1 : x1*<span class="number">0.7</span>)(xavg)</span><br><span class="line"></span><br><span class="line">x = Add()([xmax, xavg])</span><br><span class="line"></span><br><span class="line">x = Lambda(<span class="keyword">lambda</span> y : K.squeeze(y,<span class="number">1</span>))(x)</span><br><span class="line"></span><br><span class="line">x = Dense(<span class="number">96</span>)(x)</span><br><span class="line"></span><br><span class="line">x = Activation(<span class="string">'relu'</span>)(x)</span><br><span class="line"></span><br><span class="line">x = BatchNormalization()(x)</span><br><span class="line"></span><br><span class="line">x = Dense(<span class="number">256</span>, activation=<span class="string">"relu"</span>)(x)</span><br><span class="line"></span><br><span class="line">x = Activation(<span class="string">'relu'</span>)(x)</span><br><span class="line"></span><br><span class="line">x = BatchNormalization()(x)</span><br><span class="line"></span><br><span class="line">outreg = Dense(<span class="number">1</span>, activation=<span class="string">'relu'</span>, name = <span class="string">"mainop_2"</span>)(x)</span><br><span class="line"></span><br><span class="line">outsoft = Dense(<span class="number">199</span>, activation=<span class="string">'softmax'</span>, name = <span class="string">"mainop_1"</span>)(x)</span><br><span class="line"></span><br><span class="line">model = Model(inputs = [inputdenseplayers], outputs = [outsoft, outreg])</span><br></pre></td></tr></table></figure><ul><li>we have another BN after the first pooling and before the first Conv1D</li><li>The Conv1D dimensions are 160-96-96 (I wrote that wrongly below)</li><li>After the very last linear layer we have Relu-LayerNorm-Dropout(0.3)</li><li>There is no regression output (and loss is crps afterwards)</li></ul><p>对应上面的伪代码和整个模型的架构，其维度变化如下所示：</p><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/kaggle/NFL/NFL_CNN.jpeg" alt></p><h1 id="1-16更新"><a href="#1-16更新" class="headerlink" title="1.16更新"></a>1.16更新</h1><p>冠军方案的源代码已开源：<a href="https://www.kaggle.com/philippsinger/nfl-playing-surface-analytics-the-zoo" target="_blank" rel="noopener">https://www.kaggle.com/philippsinger/nfl-playing-surface-analytics-the-zoo</a></p><p>真的是让人膜拜的方案，遗憾的是他们的方案在b榜运行失败了，没有最终成绩。更让我意识到kernal based比赛代码鲁棒性的重要性。</p><p>最后的b榜结果也出来了，6%铜牌，可惜了差一点银牌，再接再厉💪</p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kaggle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年终复盘</title>
      <link href="/2019/12/31/2019-12-31/"/>
      <url>/2019/12/31/2019-12-31/</url>
      
        <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />    <label for="pass">Please enter the password to read the blog.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+px7rhp/bjZ1qlTQiTd7azYfGK7kjjPwW0cOT58xfqkR/mi17zhSCku656JqOCxG+vKmDpOD9q+hQLoDhiinAAJZtTvUkdBDlDRWBmwO78dI7J2IYu9dvnMFy2lZsWlSY6pBLKPNtsScmJw5oL34fM65dSXC+iVGWIofi53wBotrvesLV53v6c3uRKC9FTj+RFySSzJVxeAqeicadBfVjSzDXyu73IkJa332R/PnFicv993DNogtajkhmifVRKw/9NgDysnnYQTxcT3oATNpHu/tUAAm25WcvWBFHD7aGxM3tOAoxWX5WdkyFT9dZC5s9sc2i9sjArvmoGf4hsSXbMHuvPbZxfF7pqzk20rjRcpLELpmsiJ1HLwdJseJPhDswof8zsh9HfoMOyvyUMoJMurwAY5jAxCjYHzo+xm7dQFhPxr7aT/SYGeDREeLFW1QAyHfihTrKlPykM2yOb2s00EQPKn5sIOP6OxVNtibKIF/qzYA0rFb2OVt+OWKGJhTXdnO2I6rSJBIm9mUuSfzKmwazlPae7C719aOHEMIQpnBdjzTjORIsfEygFuca0wuOEU4oz7RF1Q87B9H75ZPLEdqnCYUkt5QVkkRGZvi2Wx1W4fC9CAcIMdoqUA5Wok0aMDhIZPKfHLxx+NYkMl1lGfZi9fTcfN3TPuPzIHV7dI8MAc7WCWgIRZspv72GskXxzs1fOueRrGC65Ia32b/zvkSU4IPMR3U3pD4vaPy2FJ437C+w+A7KXmkqFosgo6stgMLxld0TRQJ4j1iNrguLGXvGT+RoW6XBhpJT41jLT1z3uXXWl+nU5xJfZHlInV5pq7gsVnV56edHGSVjVC1RofeSf1ewFZQ7zB4vHX0pAga+93bQKtNW/xFW9rh3B670efkT+bJe/4QXVvLNdBGZHhw9gerN/yIYwQcuAMng55+y0sKEJDv1pOPoGtxxR5L3MHKwgbVPqP54E1qmuqLt1x3sqyY42Ro5UASvc1G479yN6vfqfzXQZ+O5Fj/nKQqZEm38DtLE1GiYia9hNcSoXLIzXsTYDK4bGRL7rjPLSDuLWxS747mG3DEDOx8SZTWFoiTWLsDfPvZ6bnKZw3hDozs0thYMFYYyl/xgV0np/UmGlQe/q47LQ8UAEihvVyXfAFc3SNbtR4ZlQHgPgrS7Rcemsx4es1CbwRVQy9L0s9H0kF/Zt4upyWpqrPnsbaoSxQ7mR0P6/nCAgghDP9GoeL6Ji2lC9rJVhZNeDLsphDvMuu5n8kIEopTun0NqmR/sihE7n04LMzK8nG0J6o+VDQjLCijZSHlUtw2mLOg+J7epFfqvuEaN1z1+R6hNnthCw29y6xd83dV5c8XBi4a2+ihoHCf7F29LYdM8CaDPAzXWAAP072O6xyxmwQRyB0d1SGhtUAjBYJ/vw2s8K9oct9Pt5vTS/eCM/H+a6TZX7TaVW1vsMCGmo3iWVdOB/s+r1c5kuLZme5riOsDGeiTuXDdMjzkvxny0tCgs8watg5pDkNkxO6s8iMR0LZSHstBVGqA9u62Q7HU0gBknBl4bMmAAeLWnNqEEFpI2JqnjBF3mX7P9iB4Cid8BctHlTy4taICuTSIChvUWx1tXW+Bm0EgwXm+eBown9NuQyIzRvbpfSxE9EVKQqZ7KvdHDwLLVMt73NyJj846EigDnfDXig+lZYpED5K5+GffcwtMqxBYLDgvP2SsAeuwm6N+exFhlRZLDYTxY7A+xQVm+UxD0CBSz8PqW9ctzwFgTpJL4DQVDCnAINIsBBm08LbGqc00P6DkPxFo42/zAFZjd9QQqMwFZQtME/8JRmlvrJmOSu0fXA9Tii7LItJSmZZFMOeF/BzI7NMyr0fPZjCuIyAW1VQGxFmNdg9JVx7qf1FyWN4kciH6TNzgM1puZzBrcsRzwmJ4okzPPRP4aiep0dABqaJo/EYjlimzomk2xEw6HZaMuOfb9bVN27ZlmtH3OzwMjlc0jem9jBDVn1gYz8g1voPFbHi+I+Ut8rUtaRoaCs7Qh57cmSzcVLq4WaiF53cMjAtQYZOIVgdixDT5BZqo/7qBuILwYfD1Hq5w1qcJe/QBZn6pMm05+WuzqcMcX8sA7OLGaSJs8nkucydRUYIMD/PwVfH4sk9nKR2JW4eXDF+HL+pmfUClhtYzlsOpkb+Kgb44kuw+yHipmhmIOTIGQvl4DYxk5UOlE4QiKxjalQ+k2DwVQRRFWV43FKzE6Ei5Ovx19YW5d9WT2WWU4rM27iWNZTP28+LlDX7JhqdhTJqu+Dkfb5fog1noSu+BxetTN1VvWkyU1s5B24mQoleEXo+JbeOfzoDlQ5R1n0D+77ZaaciaARHuo6ra3WnHVLNuvdxU9d+PRd5Prd5H9IdIOu0C9M24+HqUm8RbAcNq+Yf/+TRGmsUtHQicVWcgda8nfDMPcaOJf2oCdDvLO/OiuFHhWltEOSbqDm2blqHScN+/PHhFjNAFMb7F086OIyetMb0c87asYJW7FjaVOUQtc9G8u9KCXeT28zoeXRXcWLEYYTDyHWa2izCEDgs+rh69xEXlonuYZfF89O+lb29XTQj6qbCjy3rMyDEw0Y4x1nGaomNAMIW3v8Su5VUsY+BV2RaB9JEoCdgw7mroYicC9Hqj/BebGf9GGjtoCHmX0dLNzwV5Y6BNG2aXMW2gwVWZVKtw28a3hdvkcCBiW0+gnQ/p9JIInEIZKj4bq48IWG0Def/V8zAUJ182h9obkEEtjYCCLBZNQgawPSdglokJddWGOnPHXpXq/hn72WY86Ag8gVV1e14yAwkyZhy80vCo8PGd4zB2xvV0An+CkWmFVTVZCUzLSomcIHNPosFyYIZKhAQJS32m6OkBuR7IoKpbgZqQvfqC87aigLafDHzMj3HZqn/5M6DuCqcX3cvObrv/MGJJKYc7Kr1clXjph38wG4fHDbpWuWPNQ98N+7v0PkRGGochT1Os+fHOvUG2EVxv0OGZW10+lVAAR51KY+FF3hYUtWeAmuFEM2XJTKK2Nzpu7CmBaNexq6/DlWBUoMAaSBFGU6UguSm4cAhlpudf9lZibuo6zGminf6oLMOzkayWYXvWG5E5xGF1K2KT1lGlrr6cTDmNnT454yoSvwhG5rJPxrjF1vPz/k2e+zx7qSmGgC/DJlymL23eH1ef4fn3+sTCwX3YBVLhpUFl+a25p6008eOfR8kwH1ORElFyKov5gyu8R2ahNbT3EneCvUZqZzFPuV0l9mWM7C1aTgybAaBw7inwcs0IOtOSCIwMAmMBCNKezEZRJ0S/dcXHlzE3p5jI/Ir8Qh9vpj6cCZ6Sf1Gb7T5sY/4VbyOGXAHPqvbKh+dgwL3hvS7T+AbfP7P6d2omlHPuKFzXFJ4RAMae+l1ejUCfKcsuwb128XkVAsKzwyYu0vZvhmtoTcdc32tKb0WIA/k5T38NCR5viMSbWneHP1b1qJ02Qia/jJwUM9H8RYVCNS0r+IhpAy8zinefH+cZR4OlJ/ZebXLQDE9jfHSxH8t6rPOYBwsfV7s/ffCgCmywyGNthnkx1relXjW8WZKSWDxpaNR4ZPUvMoYJRtXZaH0ZUtV6HUgJmGf5NdNrN5iXEqRlmmWcQROYckl4Vg5d2ZHWwuvg3WxEBB1E/RNO2z5HXhqRDH7LDmOSpuEH96BkAlQuYIE2jeESLJm0zbG0uhXkN98Kbs4k2lKM8QjrgK0F3yKcBteen7ZW8Djk+/Ix9GURu+pxTVSNYUcAhrWvF/KsDwEoW4FXpfmRHQbx+x/h/E6byY4exuVy4FVpR2MFRAVdx8S6oe7c+LIgwjnT43aWKF99o36C3n9S4JYDwTcABHzlhjDb7kYji0UAmdNnJ27ic18sJZSNEJpkGAIe+YvLNRRehZYTRYQOQnwoOZPNGt1UKVVA7Ah6Wt/5NJgdsKpVWquMRrWDxKXN2V5VZUJ+S0V6KPmp/4MztkXSOgzs+F+SI8W6cxVNfiRGVBso5gW74LUhTZ8/++Krob7eK9PXtjAe0A8oDXB5O38snPdb5NOz3Zlsf9rU+8Dl3pf4MZOHCyee0h/R+JuiOYCb3uj2vNIKZ5nUhnlFyHNe18Ua8QMuHXVAM6c20B9P/kSOkt/gkSv1amIlZ2xtrqGVvQG3XBl854dD3/XEDY1hKgubrTjN6v1vJO0l7rl1wkCTKce/rrdhUfQ7WBVQ6wPd2F7bObVCjNpOJt7UEUAESMpYgWKVj0toTMk2zjT3iMqpD/vzCWNRrlMCXBAeaqWzyEpt0V42h7XVIYix2eOmfGYkYz7aHmQPYwsIAvTgadpJ43XTKmYQo+od13qPQe0SZ6Mhw9TCPN8Gw28VQJTBVP6zCpe5UMaNRqHHsR4BpioEbKn6zjfIVRkk53tLAQIa8LzZXMAHtyfbEHalYD/a2qrKl+atzWx8l40bIG2D53q6r0uxpMd5FgTND1cVmKJeyHLS8WAwLCL8weY7ymS8+3NcS80Z9WFwoA3uyyHC1vArI1jjBkmnOyVtCspmxvo4gplHniQ2DdXoCrvFg6LOCCmOQx5rShmzb1AuSlKHIjtsOjmDVlKeXQcIxUj3YaY5mZg8tfdqe7HJ+8ivToy/RGQFNx69Kmyum+BWYWPlg02+0w2YY8aFs9wtguE0eVvOzsBNynPmYpayqUCEudUd0qwlbwRjLNUuOEZQIuz9edPr3jNBKZjpaOhyo5TzBlTtkm28UthUf9Hs9uqZW2Oo850ETm2doFMZ1qwPz6S6LQInnlxr4c7X+pdUksj6quQN9xh06/0BJ8/cBtlY09ZJCFRwu8Ifk/o4vYPRlIPOyCAWFJpDfcAzl9OuLZI9UIISzH5dSHfwJ2EnecwBKdChJZkt1PBc4olgPvAwJqx/UOVu24fWUB67t8puPPt3n6t/fxObZEKkR34WoX5vSpvP5Q9c53t2w35IuYN5kKIb7HhUTN704gmmqIA+8h1B3GC0bhl1i6Zj4MsbuaHR2eL1jzGup5Q8JAo7y4BDLR8AwPJQ+ApMkpoZj9K5ogj3bL+uSBqnWwhGMWltjProj+D/vWuwf9QBXNGLHo2kmlyIxQS4RxHXI/sdEZF6sA2IEKbVDrMpUuPIIG9CzUijSRWTMBKwMmFpqFWzBJoOMtTfeDN0sIfLYYgqC8q+fuxPcZ0/zK4rb0EwmyBmessTD1u5EqrCIt7HM9RmqVT7zYE3xQ/D5hcYXrUk12+2sHRz6uN43CyfQuBpnGG9S/Ok62lQFu5ZFpIxVSS7qNsul0h9u0l0sRCSIqfBWFaN8NDTvTaU6rZhb0qxTMrKnrSfDyR6P3BHV969O9dG3Jeasj63kNzpNEGaa1UKKhgbMT1wBESaKi3H6Ap9LIzzK4kwUI3UZusyQdcZb7fNa2pEHz/Bmpuhujvo2Yu/J+V2brZHcSM1v518ckwR7areJYkxug6jvuEeUFRTkBMjI6qZBApiKj0GnavHsagmW2MzI0iil8kae00OjfiOTxxQ5eZ1AWFFeUx+zxjR1sR1GQzHCgvZcKF8E5yWR5ALdUX2skhDc2C49UQJrmAdQfT/mvrHSedqjQ2zFGXQde2Tnm+Rpm56OGZZo0Ct7A86EwrRO8BjKLZjC3mO0qyKy3P+sPSvrP31U3SJTUGsCKxraBoHnAQpFgtjID2EADMGoib3+oLQT7ts4XKrRV6xbfpx8mEWIydgKsjr0lixfbKz3aVUCVzcV61wx1Pvpcf5eKT2vMjbGe8n3tp2PpKN0D7MBr0yNRdPGJEte0l6l7lcxLqKXiISfrQAFb59OX2zfaDxat2TZK6zKhRf9t5xfXnCKd1Dr12rLHKcwDhounQpdnpsg0yXyeMVMLFyhBIzmCXAHn/RMCl/bmFBSYlW9xu8AZ+GOjQ9lhWYyjZvCkld9CvhOcUCJN3GB7m6IR4jDC1TqgxxbiZ+VJCrCPI758qj5H2UyJGWScyRydjLjDl6Ag3O6Ux1nJHJ/KgNMbSCcJKi0HT0aoq+Db+vu45SAXAM1Ip1l4n8OrUBxDsvd8Hi4+MBjZfYkHcr5jstdZZzaHwMmxfJF+Z68u75rKGLY31r9Go/3NIIj8+YYSXNe0TVahxXwGCOcrCl/eyPnEZvcuMwLhI4Q/IqgCX6eOUHvgmH9b76Q5tUFzv0FIsUHwfC1ooXMNzg1MiZ1dhSvsQ2O9lBpYPYMymvwllbpGIg0nc8SAevs87nYujG7IDLJH+AvmGWO08WGH8Xu8kkgWwqtdNSCWToSHyvE7YhQfZNvGrT0vSX5hjc1tmo1FNfgxs8HKxj0YTH9yasowkJgjA9TB+zr5Ubf/DdFHOhfdvz/yzNj/4lWuEpsIU34vdtOdlLgS/ULrNuvZIWbDFdojTD39GkDCKFMncAV3HiQ7CIvkXwIih2LwpUIwpiJ33A1NeDWMEkl6qCaqVhDPSzx9lv8sLGNukg6FotHBs9PhT0todaPOaskBijGUayNdnKnMvkfEmNwStQjRZs6zZPC2fIvs6BJcCLsSnYryVaS6ayjl/4Cdn6PP8+c8A4Utfh1HUX3w9YX607SfdTS+jlz8YtGSIbwULTA9pfw1GxEiicx2AnqovKL+u5jDvf1ksMDDxrNIIyPfeAIUFjGJDa81gR354cdbA/RZXtpVxtta0g5R099777QQ+kDmqedVUVpRkAtZCRzoGsrCk6m23u1zO28CG9kgLZvSbmXcnYPR6PgCSkGkWEhMo0RjwLVd7QO0itBDecS0SuDwqehCugOtlcuGLA98hJnXE2vhdcWCR1aU5hSw91A0IPQ9VC6RhPpdnH0ZQ1qapddOCUVDReKjlicPHHo0LCdLoLCeh+vMT0msPRQZlX3h33dO9rA8yPcY2T4R9W+h4lAIHuOhTZWlXjpJ6S4Ik2cf4UYtwZx0eECZWG/e2Kht2inyJVUo81SrfTgBYDy72yTSInx7KnJST4h6/1GPfAU8cVaGsnUp0l0+fd6pxnW9r+qS9fGcXOqRyP2Kws5SxVaSaMXPSSzzgLy8YRD0ZGPA1cLMCHVRRiZe2pup1ZxWBPd+ezRz/stSCYJjYjNuO9+r2HXd/Ov6KuphYui5jnyP/zjOgbLjsg8AGyENyBlRfvHwGBta5aAGzaSt+DrntfnjEZ5NxrLgo9tdwrRnFXIB2G+OvxcSUaNwTwsrdT1kcHiQo2ak+5u38SOrNd6jtm0lVYUEh+JfLC/QUBFAq4W71xxsQ79qeS8L1UtH78wZ7wledH1tJRUGVudIO2jm8meJt5twDlUaK29o72y82g/+1Wm7QDB0RmAkF5TPsVEB7/a2r9amC+x4x9Fr7mJFbVWkms5RORnm7iLxdvmB8MZGUuaIckkprVFssCXASXPfKOtzQ6C4rL9PQ/hrlnu6TfD325mQG4bbDGDB1JoUhumpdiWQDHsXbmGV3V0lTtCNZufT9DcpnnIfTnWTTOwIWSVcgYvAGTiQVBm5iSv8KIZXzsE/+cnQ6gcEPJY831MRODCxy30Z79r253Y9YZzQVE9ZufuC3hVtQQK7I4568BAVjuUW6yNJp3baqlxAZwX1nblheDJVsDjAHLUf8uejLBaH8LK/X13hK70+zrmCkKD2K0SVYAdAvnFXDYZHfRbXbw3iBwzrbnVo2bi234MRc9D91zzKxUdwe83Ub+15OmM+X2Me0N9HRuBOqh7Owngy12aUsgEahfvGP+i/+5yJul31ZAHqoA7l53zrCmkdmjJ2PMQTR3kvGjP6J5d6K1QQG8BvfT5zwt+Dku5/grc0ANBp0IhFa1CpFNCALvIuKpM/Uzhi+2UP4PiuFnqspahpgakRRM4PeOlDOJWcTHdtxl9oaF6DcXE3QQv+Ic8I52Hr9/PZNJkuWlUhS1EPvC7oPT1jVGWK+X9CGxXGtbdYn3ATpTnoawGzhGh7njJ8kQN5P7Y/HDS01JUUHrtzxNEAkBbL0A2oC83SeJK3jBsjgNhhKswQKqeVmcS8cpxpdXxZ1nMgJUVUI3PFBXySUb/DltJ8lQnQXGL2IWZPQV2lnEtlkjl7yLVwyRJmUEjdByVH2S5CxFJqtn9awTgLQtwCt+6zQX4/N/+kRFgAY8cGQeqwI6BOiVoQdTrz1Xw37aZnf36X58hM1tetgwi1kaLyKK0ocChb+6aTRd8rpLiPzz3KVLuv/G8nY9DzWLV+ugiZe0cv+hfieADuA6sEZSq9sZiVGGyetw5QbTDN0xMVsxJEaNxyDdNWa5ZCIRceZnHjFihBLDOtbb4frvJj3Pdu8ApifLtAY9EZSz3sFE+hYejlpAS7unUxOTU8dHfGzoAfAJ6Hl6sp/22mZzSF3qkQ1fDuyCDNLdHHgG7H5dxtKfiLlWiWdNonN6gcg2EYMs+N8qxWeXRPetLWducBvUllT/d05mehp6E0Oz3jBRrcQGtS74U/gO98DMA4K91Uj0kA5G45TSXHuhbGDmKsP9waF58+j3zblBAWdno25xmlg2euUDmzQ6OKixz61rFUUWrMcLqhDO4IDPNXdNrK5V1CKW/OwY0IIhwgGSC3u6NeyZuELOMbvaSmxn/cDLOhzWdUgq2ot+TqubrNE9RBlETgYJv3ZU3mIqN0lA97403o7G03I9PbV1rGKSfddhHaOqdURzPD4QcsQFHRV/IYtD5xQa4hFeM7swdGKhdDjVSnMwAWPxuA7PoHJ7Aoief0Uh1rahIyHouPPaaVBbSQhkFiEXmEzHQ1Oe8EOjunk4itXzRgSO0GlCZzufS/hqifMUBUu1qcVNDIAIN8sq+MGSMdMAriCVoCqpQRffbXw8lNvcwM/m/CFbEfEGRRqI+gfERs8uJft7RhgJ+20gKhH5yqYPAIZpVT0L6HSXiXcXeTpNygr5EuWVMXKtl1PiIb3rsjjGT+StTK78m5e/RsZ6JqxqaYUpwDs63eprVDDTyqE0S75n5CDvrlzaTT7YGZN6IR7EtZnozUCPAKcxIqsqesV11tAE41eP53VuruiDKUZQP0ulICRQkBqkrkuBAIiFICNb6QFjlCJh0twfp47/tzRhhIBG79F2Wh1gxkto1sIfEJNOefciXOcJcKZn+imw3ojlmhDsYULhObRe95nAsnrj22Rckq30oP66Co39SerKUncDG78vuAMaLPEvVtVaZ/w+vmbjDmj102Iwu8XmMiEwDw/95eMvsoE0bxT+uUjlBl8Uff1ByjIsACHsiXDojlWhGhbaa2GE4+Y5xNDyNG+nF392UiUqp7DKNHY80p1QMeytqTTZ/LLUD3bLwarIr8qNWROSFjgxCMAHf3f7+/We7Z11Zn07hjN1hP7ujerspydexmaxYSBiQ/vBG0N6x5FhDv6744YDlowB2iS4B9qW78GCjJTESYgV2MJ/HzVTG46Wb5qQGw9FZRiaichJxdqXxiwxpcIMjomm2PD/NYsvN+81btbbTPHTY4ceSu4Yc73G6dO9dVEDBG9kzi7pmdZ/kBxgI7kR9ILLN3F5wRupILS3PkmOusJSNU07MxIUbbzT7vUfhuVUvw1hzs8s1COUiIA6h76FvBLMrC7M+15EA0xfKeMvSLd00qjEgfvMbJ/1iVNWmUPW4x9GBt94bVsFhnmok1YK6uWT5Zng3qw/Mwpzvi4RJSsBonhC8jOwwj8RLC1GgcJ36TC6/pZ+8NpW3BpEsXeLpJOQfdfx+3SMZz8kGYbt8FyBd7zxWLbuvpL4BPgmrBKcNcoT7G9W2aLHieRDj7VHsxKR6FUzQ5614kC9EDVcjFLfP046YpzOCjTk02V6UivMcW4iGirB3ZRioLRklSw1oeRChB2/Ys5oqZa7Y7EFqUV6U+OEo6RVjy2yts77CfXujRcZXkbM4KZ5m0tYF/cibexjgcGqF414hxH96PoTMEbcJUfG58hmfIuItJcgJpV2gZWzWo+oOd/eyenyW8snjrtqggsxfOdYlD/8xspELn/0Tirar3FFpTxSaj99BejKfau8AGlC7T1JTM5dziyxKeqCHQZLjiDSYNyPNaRLa5utAnOmsxI9ZqhSyZ9dSaG32hEEx+1Y66CiyNAhY/mKuwCgrL93mBvR2Yt0F6gQwpnfpPkfMKH5UVvsqTYfBYA7RBOKtHroge+BEM2fzDI+nMybLjZh7p3QUv64iayC496okDGwHn9ywBzRoA78aVQsLj2UZ8Pm8VGSrNF/kCieQea+mpY+oPOK5Uk+gvZiRvadpwyvs5lFwqcHwGN66SHC5jTAWde/7n5gFz7p8kujBRwl/w4In4RsjZ7ToRSfYWdZSCYq02yWhQhprk1DBQASrwlI7uEE23lTlW9to1b8SyPrNy0lMlhGbuWJ5nnDaIJlqsAM77DxtLQAiIc6r6GIC4ONxYKvqSMKOtjMb1La8rDCT/gR/nU5261EEoLbemdLUnMQoecPO1RHA6adJd2KkwFHG60H+K+s9+8a3LTTBueGfu0cOIrJY/4U+za20CB8DFEbkzKsHTaDq++P7HPhAXnYvBr3mDfksMTLzjWsKChQ5ewlnT6YzApIAXmkQ/2k9cPXWYGSrxGOgmOvWWjr3L2w7GjWehRIQFTkgQPPamE5shISXWX9BfORK1szG5DAr3ZaMDZp4dniRV+1ifn14w5Th0EWjU9sBotGYgAACrxqVRn4WW75z0AB0Q6MfE0DuQA1WOArsWrBSyKwLKRgkQERmh1Ls0zgbFbHqBlybbWpqik19S0PlKcBctqcSCsiHuaXhguI2rVc5Tq7infDEyJIrcEUDf2gs19JhBckeVoCPDDswibfWNwMt6NFcToO8+DpfEx+yARr3KAYC8nujYWMN/yOmtDPRh8xosDzEPywsSjFoPO+aQq6y+xaBp+YdJMEUBNSFWJ23YjGTPWQS5doPTUf4hp/IFK8eIgmkltHrTIocRvzgC6geco2bMMOhuxevvGqV8O8WF7lRbQXnaDxoQW7WpAveWL/d519FNH2Jrit/klURCEMKZv+phPWJmK6lGiDvXYb8XnlzYym0HoWipk5z5QhoqKR94eApCNUJTvhiy8cQy7O1H1rxZlNFl1lLNoNSDsVrbxKUZF3pGk//GrsN7hM+zZaQ/OHeMro4ayQtPP82gqytJ6ab3Fbm7xuMhXZA62LV+40lrgSgphJr6jJpf1iwuDr3BTQCRL3MVl6Xwau69d8fRJk420H8HsM1LRa2GVAzGqFNcl7IFYes1JkGsJUgHG7U71woYD1QuTNxgpkk6xhvluA4/oJi+fZW+9dInF/5n2LjcEMfcF662otJNuHtqGnTNkfKpFDAQRMW1E3Ygngg64NTZsllA7MzNmT4H6X5vdS6zpnCyXIL72opUqA+I1Q4wkO2u4GqOP+dR8MpfNSeFJNBBU/ShxfhNS1Cw6OYNEFzxS2G7clzVuXgE31OEc/xZNBoDhbiV+Lexq6omDaxTAeXw7ysymCw7/KBn8aoUeBvedKaOH5wgKhAa3AKzUzrWZL6fq1xNlKqu/NRfFsv80PyNbSuXAciX2QVzGuca5QJDOMno1q1F6q6HRGf1VAxGoC6Put2oFBB8RG0/ksxjVeeSmAiLzciMsMafvlTu5o8fFpfGlpE8TwbM6YDLatuSRRdbdtTc3ZU2UYo/owt+IHCtszkWwzEy/fde5MKLBdddpUbRY8eVCxueSzll+0uBf3uOjxz9jJ2PznJRWpWRVgXwtB2XLSYEUtIIe7J6IIa+ZaImXomaq9oKuT7ZGBCFMz63ToPfcVWBBB9McfmKm3qOkHNQPTJmgCMj7AJLSv87x1f30BPLqK3gu99hQwuw/8FHB86fKTHFai4txnN2oQZYFiY6d5YWN7aTYK9sMCIwv/BvvzAlNzWpRs0z3MvwGI1uOZGu/ZRvjDigbGxPJDaBoEUsR/amdEnwQmbcCneRVieOAtbTtMh0+Rfh1dvN7iUo5IDBQhiplXkiYik6RlN6IWoNF6j8BU6Vu/6Bt2eGnZWZJU78Z67zLQsizkchp4igkkA+k9AIknbxYVqTSqYHYkG2r04eljfeBFHT7K3w6TT1PX7MHjdZYp/SUKIRoOzMIkJqOLYYt6mcGqGj/+mUehdqKdrU6mFA2QWH+WwjPgIuDMyBVjtIUNBRf2GHFtX3FBHNBu3hO9KqaVHUT7zF+bMBp8hadViKp+HmkCEkGRFOPoujkZELFhzGlYNTwS1AxOOIrbFmSbkpYsk++5jXkPVy+zQLyfOvkKP82r2ckR0mtRHLyq1pzegDGo64bvUs6MyZRg63w6m7IgBM7W6vcV4e/zO2SMIAeS3xR2O6g3JbPEXE0Pq07It24d2dDOdj2dVBRKwTyJQtzdQmHDt6DWgNl9fuGTjFssiBYbOvCmPlQ9NXE9D3vUAqodYJc73yViqq5RVOmki1VTlmUOaqGL5a71IK7+rImbGKcWNTV7rtLZLjNcFnptrzjTpycC/0eBqwuor+zv/aQ9rqNgKkosBu2n6hfulEpTjGDJyo3uXfM/EGUs6ohpwEmAT13c18ViLNLAMp1X5RBTPfgLECG/m2zf+yj51xfKvNJ7CR8w7dpwxnlFFIAavbVLS6iUl31dflc1yDfNfNJaqRFL5Zu4rNhUhJb0kilqIjj3fextG9XYJ3Fg5Mfm2qHlzE/tlHCYyClEarSFXW3CX6ZrDlA5kHqQsdCfkKYCn2hXAJ2fUztf/eBr8//LI4Ivw8tyRehVRisPAU9q67eHQsvatkFfPn4n5pc37lhELBVk5VnngDFr7OisVGEQugcrlpz4QzqfYPwl0X7RXMdEcDXm7AKAPHZUTedN53//VP9aZU60CznUbSdgUHSmRUJLRJfZr2YbSOisURQMZy29xQKGU3lXHJHJK600Mb4J88zxfZBBACNDgeK3QMyZxB1xslNziBhZEn2HhYLmvVQ8ZIgk0kGMdqnhkDj+ZoNUOYxBoWRn6xilmGY22ljurD+0rxqp3EDePtP+3vccytcHAzWaJdk0yR4YC0gTcJj3Eo1OHfrcbNtYE/b9P8DIb0J00xi81krHWaFTWjvUxmPkM4Q7c7anl/Nju4fs4uoITQYoYhnFwVugwxwXVtHZ4dh5I5IHt1N5mb+zS12//z1NpVh2AKCR4gv3NV68i5LCTa7Koi8FIH0WS903c9+QYyx9DkwtF+wA6eEbOnGG4sHFToJdzMQsRsd2kHA3BDzIrgnIrWnq9Od8KVtLR8+2DKeXKgx0RVr6nqXlM0uBg5CZ8wsdFzsAKrOngLKyjoZLCOutOL4NzMtBuoPhFDxCpcLkUqbtoiz9CyFse8Rj9aIpGyeVduRijSiMYnYycS613x2g3c0/CXqiVcZ2hGa+EX2040RQNThNq48W8Zu15Sljy3wz+WdcmCeswIvqHHURXdLX1NtnmaC/gfvbmHWCoPKL/ZzcxxB/1p7ZKnQIjnTM79KvTCJPC1h5+C2ydPjdLwgsG/Hr0m2m9sm+hFeqhg0ygVGAbSocZ00wocgiInpUl/0WcDi1u1UpNQszTNPO19vRyPkTsf7aTSHp+w+4oMkNrz/vIob6nmzIN5/yYjGHmfKtC4F5JfEmq+LnBK/+1jE/6k2NosStMZlLBeYNIS1O7OG8rbYOfs8A3PvpL3fGbeEjEsP9N6l/qk1VG+6IU/KicHB4aQHHcSNjb/90Z7wKnXR6b7wp8Dt2txCOiTfoHeBK8viu2PFNTbc/Rl4j2BdC0r0xgiOBzHqq7nOcAkPQIm94APN1HsntigD/ry2YbJ9HG3m0eZI4UF6CvU8PbtwZQBkOFPUv3Q0/u72DE805hReEvtj1APYpIEj0d93pwK0fFfUL627uyVj5QeIzE0vLtog3fqiuQEV35S7Sq5WCSOk2KlCUHKcND+0/2b1C6l6a+zTByDqflAkLZPDwUI62LkBnFycsBXf+/FYIzRZUzU7WqO0OxGUl/ynwfSdp27y1+Ab/cgxvNb1tUqnRUcFOnz5XjRa13SzCI8HL921XdrvYg9BhuPSL/pmd+JY9o7lAS0IsVEGKdfqSSzuQ+LtU0d8dN9rSLBcUnux/1cMYoky3aS8ukNIF7vg5A591b6hcJl5tR87qkn9bbE4CgWanB4YghEGkcpYlwNUn3XXT2lHNjjyMdcNOK3m7rKDUTWfSU6NTpVqyjuyt/ixd1uTXhKdRN8J+VT4SAaaSpUCPbGJVycMSpi2GURhfhFr5TeVlfhAcFLJ12FaFY85zMBe3IpuI663TTF0V+EVyqZVEboaMGHM8kGCdStWEmdlFZsrSvJQKPudIvEmz1qP5FAHL42mtKHawSJaMECZU1pZl55h9FaELhxQqmwUTW5h4lno4m5yJaqOpgt6dRbss0+O8ZtxUFjsx3eQQB/iYRHY8LxeC/+d9M5dkDA4c9P+90P+qJh+IHwwE/c68PIREJJGfsDApECDc5xXSBWF/GImAyeuFULLaEXCVnmd2IF08OhuLzXZttIESqeK5DRLkuxr3VZr/KCZ1nOKUynquBQCEPT0nFuGD1G7O7w7/r41TokcS6faYWYjq5WTemewiU++uRDqt5CQ+V2Qj6g/O6cmbVH1fKS7yq7QCvj0xPSQzzhKOauxikFbALKZAtwkwt1v86wp9m6XUv9cp+6Ly2rK7V1RIB6bGP10YX9DB+dKEfhplNR9vS6IFphFO8eYGRqTVTtRNZJnZG0KQv6iWB7c8HiVNQ6K1KNivUtfjsd7nEdw/5HY+iJxS4hMnB83XjB/AyYGquVoc/i7jSebBYG42KwX+/+m/c9er2NrsuSKpkmtgR5MFrGpEiqPxQZxuZlzPZMWBMdATgyhOwpJuZPSKV2vCiAg+0LRTZmRoI2bIfXfR8pY7ZmIPHims2MG8lPKiWU/cCg6nIHc453BuswYU49wNnaI6agLIoQyhMtEpwAwlItP2JpgYvVdp+8aIk8O6QFdfOCc16SRgNYuUoNUNf9Cb7HhbXLmJqCj6zea0z2GrXYMKwKv6FJzyE74IrOXhiKYqjDvuGX+y5+6QsELLoT5Ld0Iu8aTrGLM2JpXdgQO9at2zmF6Ew21xweGkj/Ld11V0WIZHtMD1DeIkjBP02rFQm36n6sFfHug5aYoBFW3zbJFpfdM4qZ1C+LZ+dtLCorNVGl2UpMGryKGORAXgrfTwnm5fuEgIDLC/zj5DxTOWsVSufK4bctmE5XCiTkt4JLGsXQmG/dS3dGBEkrcNKqShkz/Rwbos8idxaRjadsvU7jdw55iZMMk7gKz22R+5tQCvhElpvjkKK+LMl7F83haV46ks01PH9SJwDY/ZMhNlXbc0gus9nk4ssuJErTx1DW6RECWLPRjo+200c/o89BUQF9P0i6kbTaSIJfCwsYV4RGiP/nlGwrJY1dutTIU+F0Zk3SGBNQ7SyZs7uew1HUcVrbCFiVxlTCj3Q8OQSZgY2DCdOBKe3y2SX9+uu/zp6zDaj1r69+Podn3yEf46f7uDURxZzOaNhjRhgvI7h6RK/6JNLMTicGlckzdrnYk+y6olyzzECU/+/YrGycGqlpDdS4H5PDcY9voS/wpwsMd+gcbfz3ULUALiHr+UpRWuN/IjWbwqlCX0HxJFLWcYcVF47VnS6IGNDAev3P85wTR9Qx0VW9DtY2V7Gz8rh+hdy8nqVRhtdp741wi/NAZVPNWEEVHyIEWugJ9Ss4hRSC+OW83aV5mYJmFWYRDHYxZVQCYigsHgbBK5eLFguEmulNp4SPYbsUqzyPkdECm+QlTgvxdBbWMWjddf+pqwAZDMLHT40AZwlIyRJlEmbVibpnqndG2lzoyyVtpUfuCXVJyVKuWSHXCAl0ikiKJNsskHwfwt3NFm1aMeXSbXJ/onyJ7S5G6N0YTruVM8hvhNI7Ip2T1zEdTJegEc3PwYSA8eWhFYUYlq200IZEYfdRGtha/GHRwwgW80O0MDUagTb74cw8GkQlsVKSv1DYQK25w/fa/JQhbuc5Boy/KqhLsB6GlmLoSdY5JpcLQv37wBZ+/Vr+lwxKSNkCCQhOtQVxiZCmQc8fIsQmbQfI+QyuIMoITKIwqZE6mTWVmIMEY977pxG0FIz9/yBUx5wOJvU2JYFIDOX+X32jZRStUy/X73Z5rWfmSmTXkpu/jzF2lnRTPrYmSMfZppm8ZVJYSA++0rIk9O+nduybzfAseGo0ix+T83SRn3bDzUMLwSrmETvmze8ooGuj9oPwZ7DmoMpDTy71xkc0YEFodU97yUJYUKb/ATB3GRvYSvvxr254ET9vc7H4eSuEk3X0ZbKG4unyJmMYuw8wFZXi3jFaH8kGazYe5Cr7u7aVm0nQ5+QT7g8KRO7Cn4SvgqMxyH95TDfo9uzdPhUalfSiy74CM4QidKzNBZBCrmQjWepwShWx9MUU08Bm9I2KO28fNrHS3NJuaAEvkdnhsereNS/Zfq9I+THaHWtXo3/zNGYe9S8Itj5A5JfQlPPYMM7C9FnVd7LJ3hpkLPVLu/bnVb4IwnnoakNsCXZajoW8H70ArrbnwcQsJ9uxmhiJZa1xJrsVhCTTpaN6bn8wfYnFkN8hrSddQqalmVFsnybqsf96hSyK0HMyGQUqDrKip1vhKRC6hRoGyHWrYYoCb78quMBWodWXeMgUgI7AWD8qnY0UO2othNjrSGxCaqAOLEkLMRV8lP9SD1w3WR0B5tQid5UXWHmAGWcQlE4LsOQBUfHq0LTN0ymL2aWYglKkSq4n26l6LjsXOpvP6OCO/mM/faiWkGjqVKCKqWRwWGaZsqZ9DF50+F9zrvg+LZeoJVkvwbLB8wm9FsUi7sDZB9FHsk6fHOxDTiTl+6J16ybGYmDB9OiLrlKEU474mQgVcU5hLkrRV2b6d1r+wGsGcBSYZIlA2kKoP5GULZot0ezxMLaZLnHd5Bn9E9wGtnL1gRaNkC7zEM1p6Cfj1dRFK16DOxzlRD6Oe/NEZ2J92Fkdu73Y+zF/4GsjcgrCiK7k92yOX3ylVWpII2AGo0CWp7fn4JEyWSMDuKe/u9R/ekJcMcgpRHRezcTe0mzq+cZNJyahX7EH9pBXcdiFxhzc1Q2A7RZOO/dMgkNlNRaD9QrOPXFfXRd7sp3ErTyP/FFOgMKO2LOAuHwc4wMczKv6zSt06Rc0WqUzYbOWXUn51VVk+NxsB1wh9Uz7TB/8wQNjxIRlsnK9pGqerdcS+0PM40a6IiLaFjM3UIO5tt2zvcpihyu3oDWQl5QJFrdkJa3p1udsxlOBWrVT3rZvubSwPx0Yphqm8ay7usYENl9rb/WjfT16OiBy2IxPZ8NvH2cQZl7391XlnuUZVSquSRURVL2mKkYSyhHE0sIpavaPbSUpD30weD/AQ/uLe6wQX8lLvEo8dkh3U7+auf2fX1fKWyvX6srIltRlvtpkQ/0bcIDE0ZclhsTfsRF0b2Nk9h4EOZqKKk2bHESyVe/sZbiIDWdChtbO7yPwEdciaoRmwigTA4WPSG391QJ76mnrSWNr0iVz5edLKeC1tos8xcA15tOvvUwUh+eXTkaUoPXfWxlQevwb0VUFqmH0Q48lDUJkudBH1O5C3nRhjRLYu6wQfUfTIi2g8fiQCqD2ryNKswO4nsQdfiRxt1zUqgPjO04n5qbyVl7zQqkVKSQmtvr9QImHDz4JleZG5f1/3jbSrFhc2jshUuAEnlh/L6oaKRLzesJutll+1ByJ6pNNy7fyeGm3xzg8piIiK3i/amLt/dNeGFo2lehMvkVFK42v0LL9XLJbcAnZU2X9ihYTvjU+GNhcWaBYgSgNNRilijhOZO9tGqgaMNTO860Sh+l1Dvnc3j/0k0vBGEVNpT6QA34a1Br/50hBGibhzhfm4omN/GCi1OMrihjxIfLmeY18lAOZyZtNctzk2lJwEOmx3unM6raXvEnD8/xrGE9RYVJpaXbRB9L61zz2bwIPN8DYGbwQXyUJMM1cgONLw8i3eTSVgj4aJ1Gf1YNLSFFF/e2lUVW5i7dPsIZQElCJHifnDjzaTiweb+tLYzySU+h0UVglc+ForVRQpjK1bYXbMOmgsoTG/5fdef4zP6e50PfnS7dgW+1S83s313l7kD9o7JXYcY7sKYIPUFUOQlX4XWqB9NPKib4TQCHayRX9ZXc6hMZiKNXr2Derafbv5tIeO4VISmYzY22SkMvRxBXNvyfOBZPvdn60g/0QQzIIkYt7aXxkbDuei9l0mDdCBqTc76E8zrkG+KfCOfTd1ZMCgIyxAqLpeGYvWkspcvZYONgCD2Iz3AW80ctrv8WuDqGrurM1pQofqFj1eYM6w4Hwo04q3lKeM2zRRlTlQYUXBTDNOXlstj1Jx/tv8x/nBT1O1BSUCD919L365FNLJc5ms9aBkKnu+hIHzcIgtdOFeSvD7AhEiQiKIuC+WbJEtuZUM1PwjQVP6gv4VbRSyRgagGOP3lW0PbWv+lSHBhIYMQL10uro6PsmRHpYyC1AuyFXtxVgtUdcGr9cXS70Kg41H537FIdk6pAASIJl/Gw4YOOwyuBG4uAnnCBDG0tLM9lAo9C7RHOL07aP6MKB6+3/hn4cloYXtuOYmzH9zLEGnmS+c8HYPhh1BB0ZeqDc1mcClBPCCHwyxQUfveneLuNoahXTNg0GlN9EpC5LzsT+od9dIAJkqrHLpexWH+p48N72of+JRGp0qOe5d0lM6tfk6D7NEIPEjA1or3RZQvyzLUmzes5X3XCLtKBpZAujrAw353uRO1Hi8g2jbcsWvRx9yc3rbhelcEB2w+xiaIt6+FwtPqWxJZg2kOup7FKhGMp3kDLToKhbtPYTZAslJgngRgrxQqQ4wX1yd4tclFZfy6tq1foQVcmkwFYwkBAHQ7RoVgMp8udUiVYsnqK8uZ+WpN+Gxw3pdDxqKs0yq3r5pXgsGG4knNoby1d1gH6EY0MqgeqrSgLgYPwkJOCX+rw25C3aK3HtaXkb1itG13OxqFVSbFPsbnViqKKOkWK7NMm/d5O8trznNvaNGofoWbg3BEKAhp3k4bzsvAS+V59QpxGvh49fBznd8UKoI4M54rIfc8XPCvXdWnwV0wZjQB6ps2JlqmbyTO4E65Wd0RwVjxsRKPJAYvgM2Fgkk5GmK/lEEte8IjiCEV0SNW8DpRWB/BagUlACcDmkeSK8+3FgOE3w0b+74Y4vT7exjxD3ON/6sppNVUJuBPFVOcf6set872tMVYQCwdkHDuXoota9ATQKiG96iw2aWKLCU8uWPIk4fFjr+TrSWMLa3LciQNx2kWqrW4I/baCjXXbd0Ip7LchPLEYzaJE50MdaDsl1EqUGM9/lAEORmBDd5eNKXjtz5TL3CcYvnAXUCeGObsOa4H8woo9LfWIFbc7u5d25SZSWWFJGQeiUyMArf/6seN9Vemeb68MxwhKLg+Q9wi/z/M92VCEf02PG/6Leg41U1qGAYMmZQhX1NW9YhkR4MYvX2mxNsrPYlcKI9Vpk610qQ/mfTUe0oKVy3kThlKYFcYIj6OGQtkpKCpfJgtvlG+kxn4KehJi1k7LHMVHWczoXTY0Y87Bi8+DdejFM74pRBgAmosYnTZhIMxFbQElHkNb2eBXJMaXMyaOZR/frVMU800jLTNwH4UzMcnRu/urkLcknpZa/iOV/CIa1BZfxn3uWnKYuJhUpIJ0q1uIts7NoV0pme2FMRwFOdNf8oANoIUW4IKWINDjqkcJe50v+qnHt1EbYPDQALmS2e1cbT+oJ+JfB8/3QTNGS2fyh98hpP5rgoslYLLqma+kH2Do00qEc5XZQm/q1hvxMSItREAb5SULdmp6jN/jzsdA+nnl0NlT4CwC2ga+oQ+UvDuT4n210mMNemXZeQrEVc/Nt8Tg40mqBi5Xvdwh1ptlWCmE2SCCqS5kl++VHwCSuWe4TFu4YFo0w2ZjvzTO3mEG8/MmgwHhZ+F0+fEZxQ4qqrfqliGMKrRk4OcpjkFRaGYGrjVS84bk5szvDbDYA5SWAQQQSxlk5uh2UpFyEg4padNK4Oh69WpRGxDu7zynKCfJehPFhANCMCHvA2J5Y4p283zKsA7437Rl+0V/yt7+Ekdm9fF43tUhe7S1taSAnyvQ4S3BxjqbSUODPgSpBG8ukuINO9VwBBepyi+P0pFdcw9Wm3CmQLXw3YBc/nr6qq1DG94iYy71OEelHnZS1Zp0NLt4X8tk6LAKh4TsFt1MtUO6Vx9BVD3FJoV1B0il3zOAK8Z0TnUxQkccdimRy0rZoC8EB7/QSelyZE8h3olxjpFR7oe4FbONCj8ybpeNUJ6jQqFR81tgo4NEhWQHJfURWyuJn3d6r7Eg3WwEAmszy8MKqikxrEkLCNGq1/7WN95AvpL5h8UuSbpqpfiMR7V7OBZimwZQ/tuAf130QQZlgXmrtjX/qzaIYaUk3gccCcVSvAYJ5fRyZYWNcM1bn7a7Ss4Y9DcA1Q/mLXyaLDGmvhXhZWRQDKgFaR0qS+mvvQYgcOn0CwCSDDfdi2VsYaRmluOAb1F7pKfjRLJJYJVQ7ZDc141MuAbNoOZ0SuUR4rvvMqf42mbqOoo/M+6KFBFDfjnTxUtt0aFr8H8PbBDlglVyQDw7sRNvJOXD3Ujamhbh49EHDMolsufUUowu+PkBPjwP2QGIcgu8ys6H7CIpQzdMJbfUb5zjHmf73hS8LvqUZVVK0oNodf4zxbVsF/O2CghJd2W3Qafrli8Ur6iIgcij2m+1ughDjMaCP269U3ao1OPzIb6pGXsYaNOTWmYPB3xKDgtrcUeeF+LglazYT1nsOY5BLqtYIjYQ/Y0fgUW3rLGd84nvwHIr24XyqaoPcgkCvlMdGZZF4HxkmNl2XTdCQFzru2OTiidKzdohp7L/fASIZ3/3J3363G6BNikjAAjSHM3EGAN5yqwpEc4R0uzP33Qmr0UTuppXxBJRK0wTMkgm44pcrr0P9cDTMTFIWb//bQgBIZiMsrVNcSpUOkrWvqF+836LkT4ap/I+LrxCWwSbK9Z5KXn4tyAqpkmvqWiNorWs32JaaPiXJ5k5QwXZvPPUd7FML25U6YAURmpVwdmDSqnOEj6nta5fFOkrsXzKMvw51eAuq6kewbW47BqItvFtF+z/zslQsdH/EaxrZdfJSiva3TPOuQGy65MVRuz9N4KTaYWH1TkFf/qCXKQQ5jkb/qau0IkTcnc8/eMcV8noPEdxnjFsFoCA7TLdoonbphC9BJlPmk4k1DitGurysnyfzx8gNg570gILA9Pi1MeZffARQYJXftPvOq3YIvilVD6sZPjc+tysXV4XL0YMg8NmZacMR6+3qzEPqdKIJ+b39sTuSogmJFYvOJc4gf31ZCkVxyHixWMs0YfOczHeew+49JGf4VAiCcXljOGN5BuS7EzqiDJDpDqeu9CHGAIyUHX8Ow4bxl3yDq/p26MBod2OEgIveqOCezip/9BgHTw5YZl94QjD9Y8fY2/D80RdWT3YlFhBKACgxvRsuCTRvx62nxMBr6Pq5t64GxHFgTJX8TXVHGx9kexrcz4uBar9YxiDY4HIwkexMwUk2OD2hhHLlPR2CvGeJQNDxq0AbyFGI2sSk3SD/o9igTAPEP3auXQprLslkAV3xSCw5aWevmXbgz94qwdy1O778k1V9pWzE+1iFvBSJHNa5I0Paf0/NleSze3Tb9yiC6Rcj0BU66KjY2s8e5LKDO9XbXY39fksmo6oAd+6PB165cg8gnz8oNROphjiCieFKIORGCnsX2PoZ1mjiUIFiI6qjmF1QoezwUEW0uhs82B9My8k9EnzMu0699EV2RSeNrP1UNjCexZ84vehLrTcUFY6WbaxCAL2Z9yuhZ6SF5ZgK/Owm1NgJUGL9N3V9wAqXa2VUHmwiDatiEkSsWf4erD5+UfSnKXS3HLZhJRUAPMJx1V64eDWXcIWZaA6+oWJwU2kytYY54Bo17rXfAoXJ5QO7rTD6gcEC34sAve2EmavZ6K6VVvxH7KO8fOKgY+HA8oZLcRg8V+8WbaC6k94BQPO4hXmQKJ/E8y3kd1kMPD7Rj+8SkT/IgZwjnWY1W2Aisti18BO2bVMhr1b4InuqUrIOjc+N91a9TUxfw/gOA9Fg5AQhuTy4DZdhO9LWxpDzssNV2EheHEVd50rpagA/ZUDEohauybIPAE4rOpG5jksDw7vbXgxiRfxW0aqLUn4VP3+Ozhq/NC0laACL8+7AO80u4S48VWKk2goSLkSecBnkQB0ZBXVAXNpIRyRi70BqULZ3Av5b5oqTXUgx2VhLJ8rdCew7GZFTqPrldb+iKsjsFvLTVl6GaN9t2RlCpPbGv8PI3Mjds9D2uHt0UlgiJ1GSYGvVSxhCYQorumGrSC3G8oAl+ryYjpM0VDQ1xM6qqLaCl33vqZWBsveGReoPgbr958FpjX05K+KHClyRdnuWYd/CPI7OWIBDVduxJUXwbWc8hSlpNgfYCLKAu4hgmtecOdzL9v5MIxBsp5eOO5Xx2cPeFgb53xWUlGrm0C+kzhZthMChvsEqZXbSMkMxZNh9LSgyCYD6SqIrKdXjPxuc4wCYi6ypKqulGOGUqxPtgiBaVqlqHI/2CvR9UszmwJQBt11gyxPob2BY3vKbdBq/eebC8Q2FTI7ZG6zZeMFI18Ytb2889YgBZZGJ3WHvBETwjI0xrCKa6EeIU6m6F+JZ/LLrH4ae02hq27fTVvLQLndfU2nv3s7fNORn0P1GOrVdlKLzdd1GeaecAcEEkS5PTQueo96/5RqXDoEjXVXU30sTLRWiVHCSF13GkBuxpZ+9Kv3Rg7/UnSJBjbgjO91ezPNC2hWazoK7yQTCeuMEbLb3kXNLNugedm0OlEa6vloxGmYjPLkCAmg704n6wfQ/zEZIy70dxDBCDXsgVOqwyx9c7KlAqcAF/qKNpwVkZhXfDXiCcoskU2qfchwS+JpqGa3VxExkZZSlMflX20TpmuxqiEx0jSWY8R5lvoeHHglzmq2XrGtJzPvf0CcJ8cK6XNP5KDBvIqaAKZRwIfodpY+hrp3oWIAfRTRoi/b3Zlqdac4miypZQjOREZmqLbeLiwWcCKenMloHG/dtpAavBOPRWvdIMcvHxfgdlxXbiyW+1NPoo1zVAwue1dbFqmZvFvS3QkXsVunHOkHcCHaNOdEAYQfPrkxu4g1csuFESmp2LzhO4SVTmb3qsdIGTjEkPP0VpipZrztnL+rMWZGCP4gAoCRQcucpEGzAa49pOdVrTM8+UT5SxyGlohvrHaM9L00cPzoAIV3JbEqJqje7c6h//7N4c4EwQdmvPpJ3F6+AfYxOnY7haneUS52vR/9ViYe2BmcQ503ERoczM8L2h9MNy2ZS6OSD8VPbXhrbaMpiaQUga/a43uHBoumiTdVD5Q2F5bhrhRFF6W3Jh3tY6+jZwPxCJDoOITcxE1cMcNLbgRrGJ6CYzUO7vF0lXXzRnPxNma7M/qq8/uL6cDf8rkpqiECeslQFy4ShIFEcVHnoxugqQZ7XPX07ZCEHhPXc5wxB77Q6Qtk/l8ELSfyDBs9FlTv9q+t1csaZL5g/dYJ6mi+YyvUtntXtjmldFUPUAygLSTKoyvYgVTr8CTxM8YndcBB1Gw4HYOfJmJlXbZ7hL7D10LqwQ/t/5tpHpFOqzlis6TvqCwhhVNMCPIHKvLJE4ZDaVagxvtglmBiMv4Mrg1F7A18oniss4V9Jx4RLMh9ibEl1RybS09xUNgFYpcxOgktHTHDY1S1kysZe5X3x2TvyYSo1SjdyRwS8WAlwdvxkRDyfWeLbftQ9asmFce6HUGnd1J8ljpNLlTOhZltSS0kvTx85gC3sMHs17L1b2jE/TyL2Y0WqwovAP0gcaakKRC5wV5OM6rtiNDyalJjbHjb0Ckd8dDobv1QR0bQ/Br3+KPI/fYc7/yKoZk1hI5nP55K27domiDvin0HZg+/TTq7GUrKHLScIKsaeq3JC9kWGnr4FlzD9XW9lYYvwBZ5eTcXF2cI2uAqCJ2i+HWdBHbyNEIFvAjvH3b+5Lw6JZbOyPFSgvXACTY17gTWi+dI9n4+8/iEMycErtEwqqDKz7/HQSnEAAA3uUZqznT9Fm+vZWk7NZ/WbxPHTnOTERPgzuHEjKc8=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle ASHRAE - Great Energy Predictor III</title>
      <link href="/2019/12/24/2019-12-24/"/>
      <url>/2019/12/24/2019-12-24/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>先贴上比赛地址：<a href="https://www.kaggle.com/c/ashrae-energy-prediction/overview" target="_blank" rel="noopener">https://www.kaggle.com/c/ashrae-energy-prediction/overview</a></p><p>比赛大意是对不同地区建筑的能耗进行预测，即预测四种类型表的读数，是个典型的回归问题。相对之前的NFL来说，思路可以说是简单粗暴多了。</p><hr><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>先附上原始数据的数据词典, 数据源：<a href="https://www.kaggle.com/c/ashrae-energy-prediction/data" target="_blank" rel="noopener">https://www.kaggle.com/c/ashrae-energy-prediction/data</a></p><p><strong>train.csv</strong></p><ul><li><code>building_id</code> - Foreign key for the building metadata.</li><li><code>meter</code> - The meter id code. Read as <code>{0: electricity, 1: chilledwater, 2: steam, 3: hotwater}</code>. Not every building has all meter types.</li><li><code>timestamp</code> - When the measurement was taken</li><li><code>meter_reading</code> - The target variable. Energy consumption in kWh (or equivalent). Note that this is real data with measurement error, which we expect will impose a baseline level of modeling error. UPDATE: as discussed <a href="https://www.kaggle.com/c/ashrae-energy-prediction/discussion/119261" target="_blank" rel="noopener">here</a>, the site 0 electric meter readings are in kBTU.</li></ul><p><strong>building_meta.csv</strong></p><ul><li><code>site_id</code> - Foreign key for the weather files.</li><li><code>building_id</code> - Foreign key for <code>training.csv</code></li><li><code>primary_use</code> - Indicator of the primary category of activities for the building based on <a href="https://www.energystar.gov/buildings/facility-owners-and-managers/existing-buildings/use-portfolio-manager/identify-your-property-type" target="_blank" rel="noopener">EnergyStar property type definitions</a></li><li><code>square_feet</code> - Gross floor area of the building</li><li><code>year_built</code> - Year building was opened</li><li><code>floor_count</code> - Number of floors of the building</li></ul><p><strong>weather_[train/test].csv</strong></p><p>Weather data from a meteorological station as close as possible to the site.</p><ul><li><code>site_id</code></li><li><code>air_temperature</code> - Degrees Celsius</li><li><code>cloud_coverage</code> - Portion of the sky covered in clouds, in <a href="https://en.wikipedia.org/wiki/Okta" target="_blank" rel="noopener">oktas</a></li><li><code>dew_temperature</code> - Degrees Celsius</li><li><code>precip_depth_1_hr</code> - Millimeters，降雨量</li><li><code>sea_level_pressure</code> - Millibar/hectopascals，气压</li><li><code>wind_direction</code> - Compass direction (0-360)</li><li><code>wind_speed</code> - Meters per second</li></ul><p><strong>test.csv</strong></p><p>The submission files use row numbers for ID codes in order to save space on the file uploads. <code>test.csv</code> has no feature data; it exists so you can get your predictions into the correct order.</p><ul><li><code>row_id</code> - Row id for your submission file</li><li><code>building_id</code> - Building id code</li><li><code>meter</code> - The meter id code</li><li><code>timestamp</code> - Timestamps for the test data period</li></ul><p>所给的特征数较少，只有10+个，主要是建筑的meta特征与所处环境的特征，含义非常直白。</p><hr><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>整个做下来感觉这个场景比NFL要简单一些，难点主要有几个：</p><ol><li>存在leakage的数据，合理利用leakage能对得分起到非常大的影响。我们主要用leak做了两个提升：1.通过leakage对最终结果做leak validation ，在模型融合时作为拟合结果的指标；2.提升lb的得分</li><li>最后需要对4种类型的电表进行预测，在建模时如何建比较好？最后是多种建模方案的融合，即每一种表建立模型 + 所有表用一个模型</li><li>特征构造部分难度较大，环境与建筑能好的专业性太强，可挖掘的特征较少</li><li>在特征没那么多好发挥的情况下，这个题主要就看模型了，最后blending的融合方式很关键</li><li>最后看top的选手分享经验说本题的难点在于异常值的识别与清洗</li></ol><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>主要进行了四类特征的挖掘：</p><ol><li><p>建筑物相关的特征，如每层的面积，历史上的读数等等</p><ol><li><p>性能提升较大的处理有target encoding，对每一个building id 进行编码，</p><blockquote><p>kaggle编码categorical feature总结 <a href="https://zhuanlan.zhihu.com/p/40231966" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40231966</a></p><p>kaggle中有关于target encoding的实现：<a href="https://www.kaggle.com/ogrellier/python-target-encoding-for-categorical-features（看代码理解原理，用的话建议直接用sklearn中的）" target="_blank" rel="noopener">https://www.kaggle.com/ogrellier/python-target-encoding-for-categorical-features（看代码理解原理，用的话建议直接用sklearn中的）</a></p><p>sklearn扩展库中有完整的实现：<a href="http://contrib.scikit-learn.org/categorical-encoding/targetencoder.html" target="_blank" rel="noopener">http://contrib.scikit-learn.org/categorical-encoding/targetencoder.html</a></p></blockquote></li><li><p>将buildingid与其他的变量进行联合的agg，groupBy+ agg </p></li></ol></li><li><p>对环境特征进行统计，如最近一个月的平均气温、平均湿度，即结合时间特征进行agg</p><ol><li>专业性强的一些特征参考了discuss的实现</li><li>气温部分存在较多缺失值，用了线性插值进行填补（ linear interpolation ）</li></ol></li><li><p>关注日期类特征，节假日，工作日等，每个季度，季节</p></li><li><p>尝试按不同的地区/季节进行数据集的划分，groupkfold，分数有所提高</p></li></ol><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>几种建模的思路：</p><ul><li>每个表建一个模型：4个lgbm</li><li>总共建立一个模型：1个lgbm</li><li>根据每个site建立模型：16个site</li><li>根据每个building建模：500+的building</li></ul><p>联合建模：</p><ul><li>site + meter</li><li>building + meter</li></ul><p>看了Top选手的分享，才有联合建模的思路，确实没想到，因为联合建模的模型数量确实很大，都是两个数量相乘的关系。根据leak尝试多种模型的组合，确定每个模型的权重，最后融合了4个模型，分别是两种实现的lgbm（4个表和1个表），公开的half-half产生的模型，以及一个队友提供的集成后的模型。</p><h3 id="What-didn’t-work"><a href="#What-didn’t-work" class="headerlink" title="What didn’t work"></a>What didn’t work</h3><ol><li>更多建立模型的方式，如根据每个地区site建立一个（算力限制）</li><li>更多样化的模型种类，如NN</li></ol><h3 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h3><p>这次比赛的数据量较大，对整体的算力有相当的要求，本来用的百度云的AI平台，每训练一次要12+个小时，时间太久了，后来换到了腾讯云的平台，20个CPU跑快多了，单次训练时长缩短至2小时（这些平台不支持lgbm的GPU版本，还是蛮蛋疼的），由于算力的限制，很多想尝试的建立更多模型的方案被搁浅了没能尝试，还是挺可惜的。</p><p>这次比赛提分的重点在于最后队友间差异性较大的模型的融合，因此前期大家都在努力完成自己的单模型，提升单模型对最后的结果有比较大的影响。</p><h3 id="Top方案复盘"><a href="#Top方案复盘" class="headerlink" title="Top方案复盘"></a>Top方案复盘</h3><p>在第1，第2名的方案中，都提到了异常值剔除是很重要的一点，确实我们当时没有画很大的功夫在异常值的剔除上。他们手动确认了下列情况：</p><blockquote><ol><li>Long streaks of constant values</li><li>Large positive/negative spikes</li><li>Additional anomalies determined by visual inspection</li></ol></blockquote><p>此外他们的建模还根据了site进行建立、根据building进行建立，所以模型的数量非常大，下面是第一二名方案的大致流程：</p><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/kaggle/ashare/ashrae_1.png" alt="第一名的方案的整体流程"></p><p>第一名的方案(<a href="https://www.kaggle.com/c/ashrae-energy-prediction/discussion/124709)整体流程如上，可以看见除了对4个meter分别建模，他们还对16个site分别建模（也是我们想做但没做的）" target="_blank" rel="noopener">https://www.kaggle.com/c/ashrae-energy-prediction/discussion/124709)整体流程如上，可以看见除了对4个meter分别建模，他们还对16个site分别建模（也是我们想做但没做的）</a></p><ul><li><p>1 model per meter</p></li><li><p>1 model per site_id</p></li><li><p>1 model per (building_id, meter)</p><p>比较意外的是对每一个building + meter进行了建模，得到2380个模型。。。。额，好吧，这确实没敢想🤦‍♂️</p></li></ul><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/kaggle/ashare/ashare_2.png" alt></p><p>又看了第二名的方案(<a href="https://www.kaggle.com/c/ashrae-energy-prediction/discussion/123481)，用到的模型数量也远在我们之上，他们的建模思路是site" target="_blank" rel="noopener">https://www.kaggle.com/c/ashrae-energy-prediction/discussion/123481)，用到的模型数量也远在我们之上，他们的建模思路是site</a> + meter，去掉leak 的话11个site *4 = 44个model</p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kaggle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>港股打新入金排雷指南</title>
      <link href="/2019/11/16/2019-11-16/"/>
      <url>/2019/11/16/2019-11-16/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直听说港股打新是个概率游戏，每只新股上市时有30%的几率会破发</p></blockquote><p>其实很早就有参与港股打新的念头，但考虑到开户入金委实麻烦便迟迟没有参与，此次实际推进这个念头的契机是阿里港股上市，破发几乎不可能，大概率是个小肉签，遂开始一步步摸索。。。</p><h1 id="港股入金排雷指南"><a href="#港股入金排雷指南" class="headerlink" title="港股入金排雷指南"></a>港股入金排雷指南</h1><p>正文开始，过程一如既往地曲折🤧，如下：</p><ol><li>首先找一个港股的券商开户，这里我找了一直关注的公众号博主推荐的利弗莫尔证券，打新申购免手续费，中签了交千1的手续费（中签后的千1是必交的，有点印花税的意思，其他很多券商打新会有额外的手续费，比如50港币一次，下面的官方佣金写得很清晰了），网上比较了下这家还挺良心的，于是就开了户。</li></ol><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/foreign%20exchange/lifumoer.jpeg" style="zoom:50%;"><ol start="2"><li>接着就是最麻烦的事了，入金。。。首先需要先把人民币兑换成港币，当时我直接在工行app里边进行了操作，直接搜索结售汇进行对应汇率的买卖，每人每年5万美刀的额度。不同银行的汇率是不一样的，后来我才发现了这个宝藏网站：<a href="https://www.kylc.com/huilv" target="_blank" rel="noopener">一 站 式 汇 率</a>,里面罗列了当下最划算的银行汇率（虽然用处很有限，首先你不一定有对应银行的账号，其次每个银行境外转账的手续费差别挺大的，见下文）</li></ol><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/foreign%20exchange/exchange%20rate.png" alt="一站式汇率" style="zoom: 67%;"><blockquote><p>深刻感受到了金融业务课上学到的做市商制度</p></blockquote><ol start="3"><li>有了港币之后，需要再进行跨境汇款，这里的手续费是真的不便宜，当时年少不懂事，不同银行的跨境汇款是不一样的，上面的这个宝藏网站依然可以查到，很清晰，<a href="https://www.kylc.com/bank/fees/tt.html" target="_blank" rel="noopener">个人向境外电汇汇款手续费一览表</a></li></ol><blockquote><p>直接给出结论最划算的是用支付宝入金，方便快捷，真的全网最低50元单笔，当时我用工行是80+50，很夸张</p></blockquote><ol start="4"><li>汇款等1-3天即可完成，如果没有什么幺蛾子的话，就成功入金了。这里还值得一提的是钱出去了，回来就更难了，要有香港银行账户才能把钱转回来，具体的办理办法的话1. 自己去香港开2. 找内地银行，满足一定的条件即可开通（比如存10万块几个月就给你开之类的要求，还是很麻烦）</li></ol><hr><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本以为这次虽然多花了点手续费但终于把钱转出去了，结果第二天工行给我驳回了汇款请求，我以为地址填错了又重新申请。。。结果第三天又被驳回了，还打电话给我说我这是个证券账户，现在上头有规定转不出去Orz，难怪说入金不同银行成功率不同，原来是这个意思🤭</p><p>本来想把外汇转到另一个银行曲线救国，结果被告知转外汇要去柜台办理，还要额外的手续费，只能作罢了，加上当时人民币兑美元处在相对高位，把外汇捏在手里所承受汇率的风险来说不太划算，遂放弃，最后只能悻悻地又换回了人民币，净亏损140+，心痛。</p><blockquote><p>当时还有个消息是阿里巴巴在机构处兜售火爆，本来发行价相对美股有5%的折扣，当时说折扣取消了，我一想那这口肉也太小了，再说也不一定申得上，放弃地更心安理得🙄</p></blockquote><p>最后的结果嘛，中签率80%，最高价位比发行价溢价10%，难受香菇Orz（想放弃的时候总能找到一堆理由支持自己的结论hah）</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/foreign%20exchange/alibab.jpeg" style="zoom:50%;"><h1 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h1><ol><li>以后买卖外汇直接用<strong>支付宝</strong>（划重点），跨境汇款也是，其他花里胡哨的都不用考虑，再也不想用银行的业务了</li><li>更优惠的方案是当地的民间外汇交换所，能拿到更划算的价格</li><li>等人民币兑美元什么时候回到6.6左右了，再入手换港币吧</li><li>港股新股有暗盘，可以提前看见新股的市场预期</li><li>按前辈的经验，港股打新坚持原则，亏损开盘卖，每日十一点前必须买（止盈or止损），玄学：全字母的新股基本都是肉签</li><li>港股打新其实带来的收益有限，因为它不是市值越高申中的几率越大，大概2万港币就够申所有的新股了，对于大资金量来说，真的是“屁仓赚钱水推沙“了，相对于每日投入的时间成本，可能更加微不足道</li><li>坐等宇宙条上市再冲进港股打新了，Anyway价值投资真香，抱紧我的大白马，不用看盘的日子再多几个月吧😌</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> summary </tag>
            
            <tag> Finance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名解析调整归档</title>
      <link href="/2019/08/18/2019-08-18/"/>
      <url>/2019/08/18/2019-08-18/</url>
      
        <content type="html"><![CDATA[<p>由于域名一般只有第一年有优惠活动，直接用github page的url又太长了，遂暂时只能每年一换，缺点也很明显，撇开繁琐的更改部署，最重要的是busuanzi的统计数据（pv和uv）是跟着域名走的🤯，新的域名以前的数据就都没了，这还挺尴尬的，所以目前博客的访问数据都是新的数据~</p><p>每年换域名都要各种查资料查记录，遂整理记录形成短小精悍的本文如下：</p><blockquote><p>每年换对读者其实并不友好，明年准备用页面重定向的方式，直接跳转回github page 的地址处，这样大家收藏夹里的链接就不会失效啦</p></blockquote><ol><li><p>买域名（goDaddy）</p></li><li><p>修改本地项目中的CNAME文件（可以忽略，在github中设置了域名会自动更新相关的CNAME，路径Settings-GitHub Pages-Custom domain）</p></li><li><p>在goDaddy的域名管理处配置DNS解析（链接：<a href="https://dcc.godaddy.com/manage/zc-apiao.space/dns，zc-apiao.space为自己的域名），直接一步到位通过cloudFlare加上https协议（cloudFlare的作用不仅仅在提供用户自定义的https协议，还有cdn加速），自定义域名解析到其提供的两个地址：" target="_blank" rel="noopener">https://dcc.godaddy.com/manage/zc-apiao.space/dns，zc-apiao.space为自己的域名），直接一步到位通过cloudFlare加上https协议（cloudFlare的作用不仅仅在提供用户自定义的https协议，还有cdn加速），自定义域名解析到其提供的两个地址：</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guy.ns.cloudflare.com</span><br><span class="line">serena.ns.cloudflare.com</span><br></pre></td></tr></table></figure></li></ol><p>​    PS.之前设置的时候这边更改一直显示失败，系其服务器有问题，第二天工作日的时候再修改就好了，迷</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/dns.png" alt="image-20190818125328561" style="zoom:50%;"><ol start="4"><li><p>配置cloudFlare的dns（<a href="https://dash.cloudflare.com/47d4a93aec3e795548cd9468bd0bab8c/zc-apiao.space/dns），将其指向自己github" target="_blank" rel="noopener">https://dash.cloudflare.com/47d4a93aec3e795548cd9468bd0bab8c/zc-apiao.space/dns），将其指向自己github</a> page的ip地址即可：</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/cloudflare.png" alt="image-20190818130148511" style="zoom:50%;"><p>ip地址获取：直接ping一下自己对应的github page即可获得</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zc-apiao.space -&gt; 192.30.252.153</span><br><span class="line"> -&gt; 192.30.252.154</span><br><span class="line">q827926435.github.io</span><br></pre></td></tr></table></figure><ol start="5"><li>大功告成，然后就可以直接通过<a href="https://zc-apiao.space访问啦" target="_blank" rel="noopener">https://zc-apiao.space访问啦</a></li></ol><blockquote><p>后来发现一个很蛋疼的事情，博客中的流量统计用的是不蒜子(<a href="http://busuanzi.ibruce.info/),这个是跟着域名走的，也就是说换了个域名所有的数据都归0了。。。归0了。。。。。" target="_blank" rel="noopener">http://busuanzi.ibruce.info/),这个是跟着域名走的，也就是说换了个域名所有的数据都归0了。。。归0了。。。。。</a></p><p>所以对于只能接受首年优惠的用户（比如在下）来说，配一个页面重定向是最优的，哭，悔不当初</p></blockquote></li></ol><p>参考： </p><p><a href="https://www.jianshu.com/p/8d50ff70b3d9" target="_blank" rel="noopener">https://www.jianshu.com/p/8d50ff70b3d9</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>祝好</title>
      <link href="/2019/07/05/2019-07-05/"/>
      <url>/2019/07/05/2019-07-05/</url>
      
        <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />    <label for="pass">Please enter the password to read the blog.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鉴权方案实现小结</title>
      <link href="/2019/06/11/2019-06-11/"/>
      <url>/2019/06/11/2019-06-11/</url>
      
        <content type="html"><![CDATA[<h1 id="鉴权方案实现小结"><a href="#鉴权方案实现小结" class="headerlink" title="鉴权方案实现小结"></a>鉴权方案实现小结</h1><p>首先贴上业内的四种解决方案，这是看下来写的比较不错的文章：<a href="https://blog.csdn.net/wang839305939/article/details/78713124/" target="_blank" rel="noopener">前后端常见的几种鉴权方式</a></p><p>目前我们常用的鉴权有四种：</p><ol><li>HTTP Basic Authentication</li><li>session-cookie</li><li>Token 验证</li><li>OAuth(开放授权)</li></ol><p>第一种基于http自带的鉴权是比较古老的方式，用的比较少，安全性较低</p><p>第二种是大家都耳熟能详的通过session - cookie来维持用户登录状态，一般课本教的都是这种，弊端非常多，如下：</p><blockquote><ol><li>只适用于web系统(其他终端没有cookie一说)</li><li>session的内存占用：每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</li><li>分布式session的问题：分布式环境下，如何保证session在多台机器间共享(解决思路：1.共享存储(redis)；2.只使用cookie(类似于token验证)；3.Nginx负载均衡策略按ip hash(保证同一用户的请求打到同一台机器))</li><li>CSRF风险：由于依赖cookie进行用户识别，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击</li></ol></blockquote><p>第三种使用Token，目前的主流思路，适用于app鉴权，微信开发平台access token也是差不多这种思路。具体的实现有JWT（JSON WEB TOKEN） ,JWT的主要优势在于使用无状态、可扩展的方式处理应用中的用户会话。服务端可以通过内嵌的声明信息，很容易地获取用户的会话信息，而不需要去访问用户或会话的数据库。在一个分布式的面向服务的框架中，这一点非常有用。</p><p>第四种的使用场景主要在需要第三方授权时使用，如豆瓣可以通过qq授权登录</p><p>刚看完token和OAuth的时候感觉两者的实现有些类似，贴一段比较(来源：<a href="https://blog.csdn.net/ljinddlj/article/details/53108261" target="_blank" rel="noopener">OAuth 2和JWT - 如何设计安全的API</a></p><blockquote><h2 id="JWT和OAuth2比较？"><a href="#JWT和OAuth2比较？" class="headerlink" title="JWT和OAuth2比较？"></a>JWT和OAuth2比较？</h2><p>​    要比较JWT和OAuth2？首先要明白一点就是，这两个根本没有可比性，是两个完全不同的东西。</p><ul><li><strong>JWT是一种认证协议</strong><br>JWT提供了一种用于发布接入令牌（Access Token),并对发布的签名接入令牌进行验证的方法。 令牌（Token）本身包含了一系列声明，应用程序可以根据这些声明限制用户对资源的访问。</li><li><strong>OAuth2是一种授权框架</strong><br>另一方面，OAuth2是一种授权框架，提供了一套详细的授权机制（指导）。用户或应用可以通过公开的或私有的设置，授权第三方应用访问特定资源。</li></ul><p>既然JWT和OAuth2没有可比性，为什么还要把这两个放在一起说呢？实际中确实会有很多人拿JWT和OAuth2作比较。标题里把这两个放在一起，确实有误导的意思。很多情况下，在讨论OAuth2的实现时，会把JSON Web Token作为一种认证机制使用。这也是为什么他们会经常一起出现。</p></blockquote><p>这个感觉很像Java中的依赖反转（IOC）和依赖注入(DI)的关系，即依赖反转是思想，注入是其常见的实现方式。</p><p>更进一步地，JWT是OAuth2协议中授权码模式的一种具体实现(<a href="https://www.infoq.cn/article/identity-authentication-of-architecture-in-micro-service" target="_blank" rel="noopener">深入聊聊微服务架构的身份认证问题</a>)</p><blockquote><p>想起当时网易面试就被问到了cookie - session 的分布式session问题，当时我答通过数据库😂。。。后来池哥和我说仅仅使用cookie就可以了，把所有信息都存储在cookie中， 其实就是token的实现方式</p></blockquote><h1 id="项目中鉴权方案的升级"><a href="#项目中鉴权方案的升级" class="headerlink" title="项目中鉴权方案的升级"></a>项目中鉴权方案的升级</h1><p>在对外的开放平台项目中，也用到了token的鉴权方式，实现方式与<a href="https://cloud.tencent.com/document/product/213/11652" target="_blank" rel="noopener">腾讯云 - 接口鉴权</a>非常相似（看了看各公司提供的鉴权方案，大同小异，均是token的实现方式），我接手的版本没有包括一个时间戳，然后有一个业务场景是先对用户的套餐进行扣费，再返回收费资源的下载链接，这时候有一个风险是如果此时这个收费资源的链接被拦截了，或者用户恶意放到网上，那后果是所有人都能通过这个链接直接访问收费资源(鉴权信息都包含在返回的下载链接中的token里了)</p><p>类似的问题让我第一个想到了百度网盘的收费资源，于是去查了下实现方式，网上没有具体的说明，但通过几次测试（先在一个浏览器中通过验证，随即打开新的浏览器尝试先前验证后的url，发现需重新验证）猜测是通过localStorage实现(即把验证信息放在localStorage中，每次发起请求带上这个信息，又下载资源无需登录，排除cookie)</p><p>由于open平台不是B/S架构，故不能通过cookie或者localStorage实现，又想了想几个解决方案：</p><ol><li>传输用https协议，避免CSRF的攻击(已采用)</li><li>下载url的token中绑定用户ip</li><li>设置下载的上限次数(已采用)</li><li>设置链接的超时时间(可以在token中加入时间戳之后每次在内存中验证，也可以把这个key放入redis并设置timeout，每次setnx即可判断是否超时)</li><li>更改接口，类似于第三方验证的机制，第一次访问扣费后不再直接拿到资源下载的链接，而是返回一个accessToken代替，客户端真正下载再次访问时需加入该字段，服务器重新进行鉴权判断</li></ol><p>最后在2、4、5三种思路中选择了最轻量的设置较短的超时时间完成鉴权方案的升级，同时为了平滑升级，保留了原有接口，新接口通过拦截器统一加v2完成分组路由，最少限度地更改原有代码。</p><p>最后贴上当时V2EX发的讨论贴：<a href="https://www.v2ex.com/t/566566#reply19，自己想不到优雅的解决办法的时候，可以发个贴试试🏷" target="_blank" rel="noopener">https://www.v2ex.com/t/566566#reply19，自己想不到优雅的解决办法的时候，可以发个贴试试🏷</a></p><p>附业内的一些鉴权接口文档：</p><p><a href="https://cloud.tencent.com/document/product/213/11652" target="_blank" rel="noopener">腾讯云 - 接口鉴权</a></p><p><a href="https://help.aliyun.com/document_detail/57007.html" target="_blank" rel="noopener">阿里云 - 视频安全 -URL鉴权</a></p><p><a href="https://help.aliyun.com/document_detail/56810.html" target="_blank" rel="noopener">阿里云 - HTTPDNS -鉴权解析接口</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ByteDance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go强制关闭goroutine实践</title>
      <link href="/2019/05/16/2019-05-16/"/>
      <url>/2019/05/16/2019-05-16/</url>
      
        <content type="html"><![CDATA[<h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>起因是线上的一个业务被反馈有bug，同一个资源被扣费了两次，回忆了下那个业务，前人写的时候直接用redis加了个粒度非常大的互斥锁，如果锁状态正常的话不应该出现数据不一致的情况，遂把关注点放在了redis加的锁上，经过一番review，发现加的锁设定了一个30秒的timeout，同时当请求无法获得锁的时候，会不断轮训拿锁直到成功为止。看到这大概能猜出来这个bug是怎么产生的了，又找到了具体的问题数据，发现订单逻辑中创建时间正好相差30秒，bingo。</p><p>简单来说当用户要下载某个付费的资源发起请求时，该资源不一定在我们的服务器上，需要先下载到我们机器上再返回给用户，这中间不可控因素太多了，网络的抖动，对方服务的质量，如果30秒内资源还没下载到我们服务器上（即后续记录已对该资源付费的逻辑尚未执行），redis超时自动解锁，在这期间用户如果再次发起请求，那第二个请求此时发现还没有这个资源的扣费记录，就会又执行一次原本在加锁段中只执行一次的扣费逻辑，bug成功复现。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E5%A5%97%E9%A4%90%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B.jpg" alt="扣费逻辑" style="zoom:50%;"><p>解决思路无非就是保证上图篮筐中的三个流程需要保持加锁的状态，即要么确保锁必须在这以后释放，要么锁超时释放的时候终止流程回滚，进一步的，第一个方案确保不释放只能放弃timeout，这显然是不可取的。因此决定在代码中加入锁超时回滚的控制。</p><p>原本的逻辑因为涉及大资源的下载，故通过goroutie异步下载，每多一个下载任务，WaitGroup.add(1),下载完成WaitGroup.done()，最后在主线程WaitGroup.wait，确保所有资源都到位了再进行之后的逻辑，所以超时实现需要通知子线程（其实是协程）return</p><p>贴上一篇写得很精辟的关于几种退出方式的总结文章：<a href="https://xingwangc.github.io/go/golang/goroutine/2018/01/07/%E5%8E%9F-goroutine%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html" target="_blank" rel="noopener">goroutine退出方式的总结</a></p><p>下文通过context进行实现：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DownloadGoruntine</span><span class="params">(ctx, rpcCtx context.Context, timerCtx context.Context, wc *WaitChan,...)</span></span> &#123;</span><br><span class="line">beginDownloadChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">beginDownloadChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//避免多次下次</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 超时退出，避免因下载过慢导致redis互斥锁已经解锁而产生数据不一致</span></span><br><span class="line"><span class="keyword">case</span> &lt;-timerCtx.Done():</span><br><span class="line">wlerr := constant.NewWlErrorf(...)</span><br><span class="line">gincommon.SetWlError(ctx, wlerr)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-beginDownloadChan:</span><br><span class="line"><span class="keyword">go</span> DownloadImage(ctx, rpcCtx, wc, ...)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个gotoutine中，控制一个无限循环，每隔一秒读取一次定时器是否已到时间，当timerCtx.Done()后，报错并返回，<del>这样由该线程创建的所有子routine都会强制退出</del>（纠正：只有在main函数退出时对应的所有routine才会结束，此处不是main函数退出只是一个请求的线程退出，所以不会导致子routine退出，正确的退出方法✅应该是通过channel通知退出，具体见<a href="https://xingwangc.github.io/go/golang/goroutine/2018/01/07/%E5%8E%9F-goroutine%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html" target="_blank" rel="noopener">goroutine退出方式的总结</a>）</p><p>timerCtx通过主线程控制，统一传入：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置图片下载的超时时间为redis的timeout前5秒，保证在处理后续逻辑时不会超时</span></span><br><span class="line">timerCtx, cancel := context.WithTimeout(context.Background(), time.Millisecond*(REDIS_MUTEX_TIMEOUT<span class="number">-5000</span>))</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> DownloadImageGoruntine(ctx, rpcCtx, timerCtx, wc, ...)</span><br></pre></td></tr></table></figure><h1 id="优化后的实现"><a href="#优化后的实现" class="headerlink" title="优化后的实现"></a>优化后的实现</h1><p>嗯，<del>第一版的思想其实没什么问题</del>（第一版这一类的轮询非阻塞管道的做法，很容易导致CPU被拉满），但写法有很多优化的地方，贴上导师改完的代码（膜拜下）：</p><p>首先项目里已经有一个ctx的传递，没必要再额外创建一个，直接对已有的ctx设置即可：</p><p>对ctx的理解推荐这一篇：<a href="https://xingwangc.github.io/go/%E5%B9%B6%E5%8F%91/context/2018/01/02/%E8%AF%91-Go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F-context.html" target="_blank" rel="noopener">Go并发模式:context</a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(ctx, time.Millisecond*REDIS_MUTEX_TIMEOUT)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">go</span> DownloadImageGoruntine(ctx, rpcCtx, wc, ...)<span class="comment">//直接复用了ctx，少一个参数</span></span><br></pre></td></tr></table></figure><blockquote><p>关于此处是否需要打提前量，我觉得其实应该有，虽然意义不是特别大，如果不加的话可能会在一个场景下出现订单重复扣费的bug：即图片刚下载完，后续创建订单的逻辑还未生效，另一个请求就又进来了，虽然这间隙很短可能只有几百毫秒///</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DownloadGoruntine</span><span class="params">(ctx, rpcCtx context.Context, wc *WaitChan,...)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wc.Done()</span><br><span class="line">idc := <span class="built_in">make</span>(<span class="keyword">chan</span> *Data, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(idc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> DownloadImage(ctx, rpcCtx, idc, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时退出，避免因下载过慢导致redis互斥锁已经解锁而产生数据不一致</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    wlerr := constant.NewWlErrorf(...)</span><br><span class="line">gincommon.SetWlError(ctx, wlerr)</span><br><span class="line">wc.ch &lt;- &amp;Data&#123;</span><br><span class="line">ID: ...,</span><br><span class="line">Data:    <span class="literal">nil</span>,</span><br><span class="line">Format:  format,</span><br><span class="line">WlError: wlerr,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> id := &lt;-idc:</span><br><span class="line">wc.ch &lt;- id</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实不难发现我们完全没必要写一个for循环，当chain都不满足的时候，select会自动轮训直到有case满足，当超时后，ctx.Done()报错并会返回一个相关data为nil的结构以便程序后续的处理，同时通过创建一个无缓冲chain idc用于传递异步下载的数据至wc（这里用有缓冲的我理解下来问题也不大），最后程序下载完了对WaitGruop进行Done的操作。</p><p>这里其实忘记关闭通道了，虽然我查了说GC会自动处理，但好的代码习惯还是加上吧，最后记得defer close(idc)`</p><h1 id="Java-的处理思路"><a href="#Java-的处理思路" class="headerlink" title="Java 的处理思路"></a>Java 的处理思路</h1><p>不自觉地又会去思考这个场景在Java中该如何实现，即父线程通知子线程关闭，思路大致是：异步的下载任务通过起一个线程池完成，借助submit提交任务传递下载好的byte，当主线程超时退出时，直接对线程池进行shutdownnow的操作中断所有任务</p><p>当然这里的中断不能确保全部中断，其原理是把线程池的状态立刻变成STOP状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。而试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。 </p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> ByteDance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ApacheBench for mac 踩坑记</title>
      <link href="/2019/04/21/2019-04-21/"/>
      <url>/2019/04/21/2019-04-21/</url>
      
        <content type="html"><![CDATA[<p>众所周知mac系统自带了ab工具，谁知神坑就此开始，当我满心欢喜地照常输入以下压测命令时，花式报错开始了：<br><code>ab -n 300000 -c 1000 http://127.0.0.1:8080/seckill/seckill</code><br>简单说明下，这个命令<code>-n 300000</code>表示发起30w个请求，<code>-c 1000</code>表示指定并发数是1000，后面的url就是要访问的接口，发的是get请求，一切正常的话，在终端会显示压测的种种指标，举例如下图：</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/ab2.png" style="width:488px">一般我们比较关心的指标有两个1.QPS（红框部分）2. 90%line（页面底部90%那一行，表示90%的请求完成的平均时间），上图是已经做过一定优化的秒杀系统的压测结果，根据当时线上机器的性能峰值来说，已经优化的不错了。正当我期待本地的结果能跑出多少QPS的时候，报错开始：<ol><li><strong>socket: Too many open files (24)</strong></li></ol><p>最常见的错误，这个错误解决起来很简单，一般是由于MacOSX默认的open files数值过小导致的。使用<code>ulimit -a</code>查看当前系统的默认文件打开数。如下图，可以看见当前bash设置的是2048（默认值一两百吧，这个是已经改过的版本），进一步使用<code>ulimit -n 2048</code>修改，注意该修改只对当前bash生效，重开后要重新改</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/ultimate%20-n.png" style="width:488px"><ol start="2"><li><strong>apr_socket_recv: Connection reset by peer (54)</strong></li></ol><p>头痛的问题来了，这个问题折腾了一晚上+一早上都没解决，把网上的方法都试了，主流的说法是mac自带的ab有缺陷，会限制并发数，解决办法：下载最新的apache并重新编译，备份原来的ab并将新编译的ab替换到原来的路径。</p><blockquote><p> 具体的流程网上不靠谱的千千万，很想diss一下博主们，有的命令就直接是错的，有的可能是源已经过期了，有的用了复杂的方法，百度搜的真的不靠谱，关键时刻还是要google啊</p></blockquote><p>直接上可以跑通的：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以下是报错的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ab -n 1 http://www.google.com/</span></span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking www.google.com (be patient)...apr_socket_recv: Connection reset by peer (54)&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">To fix this, you'll want to run the following commands. In my example, the latest version of Apache is 2.4.3, but by the time you read this it may be a newer version, so just in case, &lt;a href="http://apache.mirrors.pair.com/httpd/" target="_blank"&gt;download the latest Apache&lt;/a&gt; from their website.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是解决方案(homebrew要是没装的话网上搜一下，一大把)</span></span><br><span class="line">brew insatll apr # 先装3个ab要求的工具（不装后面会报错），网上很多帖子说的这三个工具包都是要自己下载，再解压，再配置路径，再make，无语，明明brew install都能装， 浪费了不少时间，(mmp已经在嘴边了)</span><br><span class="line">brew install apr-util</span><br><span class="line">brew install pcre # install PCRE, required by Apache</span><br><span class="line">wget http://apache.mirrors.pair.com/httpd/httpd-2.4.3.tar.bz2 # download Apache，不用wget自己下压缩包解压效果也一样的，没有wget的话先brew install wget</span><br><span class="line">tar -xzvf httpd-2.4.3.tar.bz2 # extract Apache</span><br><span class="line">cd httpd-2.4.3 # enter Apache directory</span><br><span class="line">./configure &amp;&amp; make # configure and compile Apache</span><br><span class="line">sudo mv /usr/sbin/ab /usr/sbin/ab.bak # backup old ApacheBench(备份这部无所谓，old的版本我直接没备份)</span><br><span class="line">sudo cp support/ab /usr/sbin/ # install new ApacheBench</span><br><span class="line">ab -n 1 http://www.google.com/ # test new ApacheBench</span><br></pre></td></tr></table></figure><p>虽然正常的流程就那么点，但网上各种误导之下真的浪费了很久，然后在装齐3个ab要求的工具再configure ab的时候，可能还会有报错like：<code>./configure时出现以下错误：C compiler cannot create executables</code><br>服了，又是一通goole，百度，有的说<code>brew upgrade gcc</code>，更新了还是不行，这时候依稀回忆起以前也碰见过类似的，是Xcode版本太老了引起的，遂更新Xcode（校园网下6个G直接下了一个通宵。。。。），第二天一早果然问题解决</p><blockquote><p>这也是我不喜欢mac系统的一点，升级个系统版本，就各种不兼容不匹配👎，升系统千万慎重！你永远不知道升完之后哪个环境就炸了</p></blockquote><p>最后这些错都解决了，满怀期待的用sudo cp替换系统中老的ab时，又报错了，提示没有权限，解决见：</p><p><a href="https://thomashunter.name/posts/2012-08-29-fixing-apachebench-on-os-x-lion" target="_blank" rel="noopener">关于MAC系统没有修改/usr/bin和/usr/sbin文件夹权限问题</a></p><p>嗯，至此虽然ab成功更新到了新版本，然并软。。。。<br>我都开始怀疑是我程序的问题了。。。但之前windows环境、linux环境就跑压测跑的很顺畅，迷<br>如果有同学遇到了同样的问题，在升级ab版本后成功解决的，求不吝赐教。。。</p><blockquote><p>之后不放弃的我又试着在虚拟机的windows里面装ab，然鹅，虚拟机的文件目录的地址实在太鬼畜了，shell完全cd不到相关的地址，放弃。。。</p></blockquote><p>后续：现在升级后的ab依然只能跑聊胜于无的并发，经测试-n 10000 -c 100还是可以的，-c再往上就会出Connection reset by peer (54)</p><hr><p>参考：</p><p><a href="https://thomashunter.name/posts/2012-08-29-fixing-apachebench-on-os-x-lion" target="_blank" rel="noopener">Fixing ApacheBench on OS X Lion</a></p><p><a href="https://blog.csdn.net/hexuan1/article/details/45191549" target="_blank" rel="noopener">运行ab测试时socket: Too many open files (24)的解决办法</a></p><p><a href="https://www.cnblogs.com/richard-youth/p/10002565.html" target="_blank" rel="noopener">configure: error: C compiler cannot create executables</a></p><p>以下内容或者类似的这种均不适合借鉴：（别在里面浪费时间了）</p><p><a href="https://blog.csdn.net/h254532693/article/details/48218047" target="_blank" rel="noopener">ab(Apache Benchmark)运行apr_socket_recv报错</a></p><p><a href="https://segmentfault.com/a/1190000007956688" target="_blank" rel="noopener">Mac使用ab并发测试问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS High Sierra </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World 2.0</title>
      <link href="/2019/04/20/2019-04-20/"/>
      <url>/2019/04/20/2019-04-20/</url>
      
        <content type="html"><![CDATA[<p>之前看到<a href="https://yisaer.github.io/" target="_blank" rel="noopener">伊撒</a>大大的博客，深觉自己之前的博客有点单一，自己用Jekins去找模板再部署可扩展性有点低，很多想加的留言功能、分享功能加起来比较麻烦， 基于此决定拥抱Hexo，下文为hexo自动生成的hello world,很良心的是其还有官方的中文文档，上手建站也真的是迅速，一个晚上就搞定了，然后又挑了许久主题，决定用这套<a href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/" target="_blank" rel="noopener">hexo-theme-melody</a>，最后就是把文章配置进行修改，迁移过来。</p><p>说说体验吧，官方文档真的很友好，建站尤为迅速，弊端的话感觉定制化修改门槛比以前高了不少（到现在都没解决about，archieve等页面如何不显示gitalk 🤦‍♂️\ (ノ｀Д)ノ，之后有时间慢慢改吧）</p><p>增加的新功能：</p><ol><li>分享系统：再也不用自己默默把链接发给微博拿一个短链再分享了</li><li>评论系列：gitalk，基于github issue</li><li>搜索功能</li><li>文章顶部的字数统计与建议阅读时间</li><li>浏览量等相关统计功能可视化</li><li>右侧栏目阅读进度提示</li></ol><p>to be continue：</p><ol><li>个性化设置（顶部的图片 + gitalk显示问题）</li><li>为某猪蹄再搭一个更炫酷的页面，带密码访问的那种</li></ol><hr><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中4类定时器比较总结</title>
      <link href="/2019/04/09/2019-04-07/"/>
      <url>/2019/04/09/2019-04-07/</url>
      
        <content type="html"><![CDATA[<h1 id="定时器总结"><a href="#定时器总结" class="headerlink" title="定时器总结"></a>定时器总结</h1><p>梳理了下目前用过的定时器实现方案：</p><ol><li>JDK的Timer包</li><li>Thread</li><li>ScheduledThreadPool</li><li>Spring Timer(@Scheduled 推荐)</li></ol><p>定时器的启动时间主要有以下：</p><ol><li>随tomcat启动而启动——原生servlet（落后的方式）</li><li>随Spring启动而启动</li><li>其他时间（根据业务逻辑确定）</li></ol><p>下面具体介绍每一种的实现及利弊，最后会说明分布式场景下定时器如何正确设置的思路，首先说明启动时机的实现（主要对前两个共性的启动时机进行说明）：</p><h3 id="1-1原生servlet（落后的方式）"><a href="#1-1原生servlet（落后的方式）" class="headerlink" title="1.1原生servlet（落后的方式）"></a>1.1原生servlet（落后的方式）</h3><p>最原始的解决方案，随着tomcat启动而启动，其加载顺序在spring之前，固在spring初始化之前定时器就启动了所以相关注入依赖会报NPE，只能用最原始的直接从上下文里去拿要的变量（不推荐）。</p><p>（SpringMVC）在build目录下的web.xml文件中需要添加以下配置（class具体放的是timer的全限定名）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">netease</span>.<span class="title">pangu</span>.<span class="title">guide</span>.<span class="title">module</span>.<span class="title">secondkill</span>.<span class="title">service</span>.<span class="title">ListenerService</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意这里要修改的是<code>build文件夹下的web.xml目录</code>，一共有2个web.xml，另一个是打包后产生的在webapp-&gt;WEB-INF文件夹下,每次打包会根据build下的配置文件重新生成WEB-INF</p></blockquote><p>当时第一次加这个配置就是这里出了问题，加到了WEB-INF下，那每次一打包都是用原来未修改的xml文件覆盖了当前修改的文件，根本就没有把这个配置加进去，找这个bug找了很久。</p><p>具体实现的话需要实现ServletContextListener接口，并重写里面的contextInitialized方法和contextDestroyed方法。</p><p>其中定时器的主要逻辑写在contextInitialized中，该方法会随tomcat的启动而启动，此处如果要用到Spring的依赖注入，需要直接从上下文去获取，真的非常原始了。。。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Timer timer  =  <span class="keyword">new</span> Timer(<span class="keyword">true</span>);<span class="comment">//set timer as daemon</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerService</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在listener中注入不可以用注解模式,要采用以下方式</span></span><br><span class="line">        <span class="keyword">final</span> WebApplicationContext webApplicationContext =</span><br><span class="line">                WebApplicationContextUtils.getWebApplicationContext(event.getServletContext());</span><br><span class="line">        initRedis = webApplicationContext.getBean(InitRedis.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//本质是基于JDK的timer实现定时任务</span></span><br><span class="line">        TimedTask timedTask = <span class="keyword">new</span> TimedTask(event.getServletContext(), event);</span><br><span class="line">        timer.schedule(timedTask, date,<span class="number">12</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span>  </span>&#123;</span><br><span class="line">            timer.cancel();</span><br><span class="line">            event.getServletContext().log(<span class="string">"定时器销毁"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Spring启动后启动"><a href="#1-2-Spring启动后启动" class="headerlink" title="1.2 Spring启动后启动"></a>1.2 Spring启动后启动</h3><p>其实从效果而言，Spring启动前启动与启动后再启动并无多大区别，而如果定时器启动时Spring已经启动了，那么就避免了手动去context中获取bean，代码简介多了（我一开始用第一种启动方法纯粹是搜的时候搜错了，第一种其实没有任何的必要，是一种落后的方法，网上的教程什么的完全没必要看，被误导了）<br>这种方法配置就更简单了，直接找到Spring的配置文件加入相关信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 定时任务 --&gt;</span><br><span class="line">    &lt;task:executor id=<span class="string">"executor"</span> pool-size=<span class="string">"5"</span>/&gt;</span><br><span class="line">    &lt;task:scheduler id=<span class="string">"scheduler"</span> pool-size=<span class="string">"10"</span>/&gt;</span><br><span class="line">    &lt;task:annotation-driven executor=<span class="string">"executor"</span></span><br><span class="line">                            scheduler=<span class="string">"scheduler"</span>/&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">    &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span>/&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.netease.pangu.guide.module.seckill.service"</span>/&gt;</span><br></pre></td></tr></table></figure><p>同时注意到此处有一个<code>pool-size</code>的参数，说明可以配置成线程池，也就没有了单线程timer的不足（后面具体说明）。</p><hr><p>下面首先列举经典的jdk的timer使用</p><h3 id="2-1JDK的Timer"><a href="#2-1JDK的Timer" class="headerlink" title="2.1JDK的Timer"></a>2.1JDK的Timer</h3><p>使用非常简单，直接上代码（以之前蚂蚁二面笔试中的实现一个定时删除过期值得队列中的timer实现为例）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">      timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  scanAndDelete();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                  <span class="comment">//</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, delay, interval); <span class="comment">//指定timer在delay时间后开始执行第一次任务，任务之间间隔interval的时长</span></span><br><span class="line"></span><br><span class="line">timer.cancel(); <span class="comment">// 关闭当前定时器，根据具体情况使用</span></span><br></pre></td></tr></table></figure><p>注意一开始直接用lambda表达式（）-&gt;{}会报错，看来不像排序sort方法中的comparator和线程中的runable一样可以直接简写 </p><h3 id="2-2-通过thread实现定时器"><a href="#2-2-通过thread实现定时器" class="headerlink" title="2.2 通过thread实现定时器"></a>2.2 通过thread实现定时器</h3><p>同理，只是写法更复杂些，直接上demo code</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用thread</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(delay);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    scanAndDelete();</span><br><span class="line">                    Thread.sleep(interval);<span class="comment">//注意此处要用类去调用静态方法，直接用实例thread调用会报其可能尚未实例化</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"scanThread"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-单线程timer的弊端"><a href="#2-3-单线程timer的弊端" class="headerlink" title="2.3 单线程timer的弊端"></a>2.3 单线程timer的弊端</h3><p>通过上述两种方式实现的timer都是单线程工作的，会有以下弊端：<br>1.管理多个延时任务的缺陷<br>如果存在多个任务，且任务时间过长，超过了两个任务的间隔时间，会导致后续任务被推迟进行（因为单线程还在处理前一个任务）</p><p>2.任务抛出异常时的缺陷<br>如果TimerTask抛出RuntimeException，Timer会停止所有任务的运行（即不仅仅当前任务停止了，后续所有的任务也都不会再运行），因此如果我们要使用timer，必须捕获RuntimeException</p><p>3.Timer执行周期任务时依赖系统时间<br>Timer执行周期任务时依赖系统时间，如果当前系统时间发生变化会出现一些执行上的变化，ScheduledExecutorService基于时间的延迟，不会由于系统时间的改变发生执行变化。</p><blockquote><p>来源：<a href="https://blog.csdn.net/lmj623565791/article/details/27109467" target="_blank" rel="noopener">https://blog.csdn.net/lmj623565791/article/details/27109467</a></p></blockquote><h3 id="2-4-scheduledThreadPool"><a href="#2-4-scheduledThreadPool" class="headerlink" title="2.4 scheduledThreadPool"></a>2.4 scheduledThreadPool</h3><p>为了解决上述单线程timer的三个问题，我们可以通过线程池的思想实现，相比上面的版本，其实就是把任务交给了线程池去执行，改进后的代码并不复杂，demo如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    QueueWithTimeOut(<span class="keyword">int</span> size, <span class="keyword">int</span> delay, <span class="keyword">int</span> interval) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.que = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">this</span>.timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">//        timer.schedule(new TimerTask() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                scanAndDelete();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;, delay, interval);</span></span><br><span class="line">        scheduledThreadPool.schedule(()-&gt;&#123;</span><br><span class="line">            scanAndDelete();</span><br><span class="line">        &#125;,interval, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-Spring-timer（推荐）"><a href="#2-5-Spring-timer（推荐）" class="headerlink" title="2.5 Spring timer（推荐）"></a>2.5 Spring timer（推荐）</h3><p>通过spring实现timer就更简单了，如1.2配置完之后，就可以通过@Scheduled标签与cron表达式实现定时任务，形式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">scanAndDelete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下是最简洁的实现，也不再需要自己去维护timer的生命周期，此外另一个好处是我们可以通过配置文件将其配置成线程池的版本，这样就很好地避免了单线程timer会产生的问题</p><h3 id="3-定时器的分布式设计"><a href="#3-定时器的分布式设计" class="headerlink" title="3.定时器的分布式设计"></a>3.定时器的分布式设计</h3><p>最后说说timer分布式设计的思路，可能有些业务场景只需要执行一次定时任务，但每一台机器都起了自己的timer，这时候有两种思路去解决：</p><p>1.所有的timer正常运行，但要执行前去竞争一个redis的分布式锁，通过setnx保证只有一个定时器能够做这个任务，即每次做任务的可能是不同的定时器，但任务是相同的</p><p>2.更为简单的处理是只在一台机器的timer上起这个任务（如果可以的话）</p><p>具体取舍还是要看业务场景而定</p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>练手——蚂蚁二面笔试题</title>
      <link href="/2019/03/29/2019-03-29/"/>
      <url>/2019/03/29/2019-03-29/</url>
      
        <content type="html"><![CDATA[<h1 id="练手——蚂蚁二面笔试题"><a href="#练手——蚂蚁二面笔试题" class="headerlink" title="练手——蚂蚁二面笔试题"></a>练手——蚂蚁二面笔试题</h1><h3 id="1-起两个线程，交替打印奇数和偶数"><a href="#1-起两个线程，交替打印奇数和偶数" class="headerlink" title="1. 起两个线程，交替打印奇数和偶数"></a>1. 起两个线程，交替打印奇数和偶数</h3><p>一拿到这个题目有几个思路，1.共享变量，2.等待/通知机制，其实感觉考察的是进程通信的方式（6种）</p><p>共享变量实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">oddAndEvenPrintThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RANGE = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;(RANGE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argus)</span> </span>&#123;</span><br><span class="line">        Thread oddPrinter = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; RANGE) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((cnt &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//System.out.println(cnt);</span></span><br><span class="line">                    ans.add(cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"oddPrinter"</span>);</span><br><span class="line"></span><br><span class="line">        Thread evenPrinter = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; RANGE) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((cnt &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//System.out.println(cnt);</span></span><br><span class="line">                    ans.add(cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"evenPrinter"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oddPrinter.start();</span><br><span class="line">            evenPrinter.start();</span><br><span class="line">            oddPrinter.join();</span><br><span class="line">            evenPrinter.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ans.forEach((a) -&gt; System.out.print(a + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里可以有几个优化的地方，1.用线程池代替单独的线程；2.当不满足cnt条件时可以加一个yield主动放弃cpu资源（这个见仁见智，我觉得没必要，多核cpu还会增加上下文切换的开销）</p><p>用线程池又写了一个版本：（此处如果面试还能再阐述下线程池的几个好处，绝对的加分项）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">oddAndEvenPrintThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RANGE = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;(RANGE);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService oddExecutorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,<span class="number">1</span>,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService evenExecutorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,<span class="number">1</span>,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argus)</span> </span>&#123;</span><br><span class="line">        Future oddTask = oddExecutorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; RANGE) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((cnt &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//System.out.println(cnt);</span></span><br><span class="line">                    ans.add(cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//return “finish”； 通过future.get可以得到这边return的结果，因为默认的泛型是object，不限数据类型</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Future evenTask = evenExecutorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; RANGE) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((cnt &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//System.out.println(cnt);</span></span><br><span class="line">                    ans.add(cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oddTask.get();</span><br><span class="line">            evenTask.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ans.forEach((a) -&gt; System.out.print(a + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要用submit代替execute，原因是submit的任务可以拿到Future的一个返回值,在主线程中我们可以通过futureTask.get操作获取到返回的结果值，若果任务未执行完则会阻塞</p><hr><p>之后的第二个思路，用wait()和notify（）实现，这个版本由于涉及到synchronize加锁效率较低，同时写的时候出现了下面的问题：</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E8%9A%82%E8%9A%81%E4%BA%8C%E9%9D%A2%E7%AC%94%E8%AF%95%E6%8A%A5%E9%94%99%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE.png" style="width:400px"><p>说明在自己线程里面，不能对自己去wait，而且此时去通知evenPrinter线程，会由于该线程定义的顺序关系无法运行，固需要换个思路在主线程里去做通知和等待，而这两个线程仅负责打印奇数和偶数，不做其他的判断（相当于把判断当前哪个线程打数字的工作交给了主线程），理清了思路不难发现写起来真的很麻烦，同时判断打奇数和偶数还要通过一个变量cnt去记录，那为什么不直接采用第一个版本呢？这个实现显然多此一举。</p><h3 id="2-实现一个带超时时间的队列，队列中会自动剔除超时的数据"><a href="#2-实现一个带超时时间的队列，队列中会自动剔除超时的数据" class="headerlink" title="2.实现一个带超时时间的队列，队列中会自动剔除超时的数据"></a>2.实现一个带超时时间的队列，队列中会自动剔除超时的数据</h3><p>一个思路就是用一个linkedlist 作为队列的载体，再加上一个timer或者起一个线程去每隔几秒删除过期数据<br>另一个思路其实和redis的惰性删除相似，即在要使用的时候才检查是否过期，不过这个方法有一个弊端，当队列塞满的时候，需要去设置键的remove策略，因为有些键可能过期了，但没有被删除，此时还存放在队列里边。</p><p>此处直接用第一个思路实现，同时考虑到多线程环境（加分项），对相关方法做同步操作。</p><p>用timer或者thread去写大同小异：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueWithTimeOut</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Node&gt; que;</span><br><span class="line">    <span class="keyword">private</span> Timer timer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> curSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        QueueWithTimeOut(<span class="keyword">int</span> size, <span class="keyword">int</span> delay, <span class="keyword">int</span> interval) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.que = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">this</span>.timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//使用Timer</span></span><br><span class="line"><span class="comment">//        timer.schedule(new TimerTask() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                scanAndDelete();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;, delay, interval);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用thread</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(delay);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    scanAndDelete();</span><br><span class="line">                    Thread.sleep(interval);<span class="comment">//注意此处要用类去调用静态方法，直接用实例thread调用会报其可能尚未实例化</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"scanThread"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Object key;</span><br><span class="line">        <span class="keyword">long</span> timeout; <span class="comment">//这里timeout存放的是currentTime + timeout</span></span><br><span class="line">        Node(Object key, <span class="keyword">long</span> timeout) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> timeout;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Object key, <span class="keyword">long</span> currentTime, <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        timeout += currentTime;</span><br><span class="line">        <span class="keyword">if</span> (curSize &gt; size) <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"size 已满"</span>);</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, timeout);</span><br><span class="line">        que.offer(node);</span><br><span class="line">        curSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!que.isEmpty()) <span class="keyword">return</span> que.poll();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scanAndDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = que.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (que.get(i).getTimeout() &lt; getCurrentTime()) que.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getCurrentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于考虑到多线程，在方法里加了synchronized，性能并不高，更好的实现是用读写锁去优化，改写后的offer，poll，scanAndDelete方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Object key, <span class="keyword">long</span> currentTime, <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    timeout += currentTime;</span><br><span class="line">    <span class="keyword">if</span> (curSize &gt; size) <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"size 已满"</span>);</span><br><span class="line">    rwlock.writeLock().lock();</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(key, timeout);</span><br><span class="line">    que.offer(node);</span><br><span class="line">    curSize++;</span><br><span class="line">    rwlock.writeLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwlock.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!que.isEmpty()) <span class="keyword">return</span> que.poll();</span><br><span class="line">    rwlock.readLock().unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanAndDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwlock.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!que.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = que.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (que.get(i).getTimeout() &lt; getCurrentTime()) &#123;</span><br><span class="line">                rwlock.writeLock().lock();</span><br><span class="line">                que.remove(i);</span><br><span class="line">                rwlock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rwlock.readLock().unlock();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-字符串匹配，KMP算法"><a href="#3-字符串匹配，KMP算法" class="headerlink" title="3.字符串匹配，KMP算法"></a>3.字符串匹配，KMP算法</h3><p>之前一直反复忘KMP的写法，贴上自己整理的一篇理解：<a href="https://app.yinxiang.com/Home.action?csrfBusterToken=U%3D153667a%3AP%3D%2F%3AE%3D169b3e02fc8%3AS%3D5db0fd09cdaf4292e3fd0520cf65d03d#n=460643aa-9733-4516-ae98-0e39a5a8baaf&s=s62&b=dfef6f4e-48c2-4a2e-b162-0c74d9e5b2d2&ses=4&sh=1&sds=5&" target="_blank" rel="noopener">印象笔记——KMP</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argus)</span> </span>&#123;</span><br><span class="line">        String  str = <span class="string">"abcabcdab"</span>;</span><br><span class="line">        String  pattern = <span class="string">"abcdr"</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len_str = str.length(), len_pat = pattern.length();</span><br><span class="line">        <span class="keyword">if</span> (len_pat &gt; len_str) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len_pat];</span><br><span class="line">        getNext(pattern, next);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len_str &amp;&amp; j &lt; len_pat) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == pattern.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == len_pat) System.out.println(i - j);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(String pattern, <span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; pattern.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == -<span class="number">1</span> || pattern.charAt(k) == pattern.charAt(i)) &#123;</span><br><span class="line">                k++;</span><br><span class="line">                i++;</span><br><span class="line">                next[i] = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>三道题共一小时,感觉在正常实现的基础上适当考虑多线程的情况，使用线程池代替线程会是个不错的加分项。接着还可以bb为什么要用线程池代替线程（1.便于对线程这类昂贵资源的管理；2.复用线程节省资源；3.提高响应速度，无需先创建个线程；4.线程挂了的话线程池会自动补充；5.单线程的话如果前面的任务执行时间过长会对后面任务产生影响，即timer的不足之一），后面4,5也是推荐用scheduledThreadPool代替timer的原因（因为timer底层是单线程的）</p><p>贴上用scheduledThreadPool实现timer的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    QueueWithTimeOut(<span class="keyword">int</span> size, <span class="keyword">int</span> delay, <span class="keyword">int</span> interval) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.que = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">this</span>.timer = <span class="keyword">new</span> Timer();</span><br><span class="line"><span class="comment">//        timer.schedule(new TimerTask() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                scanAndDelete();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;, delay, interval);</span></span><br><span class="line">        scheduledThreadPool.schedule(()-&gt;&#123;</span><br><span class="line">            scanAndDelete();</span><br><span class="line">        &#125;,interval, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「19春招总结」</title>
      <link href="/2019/03/15/2019-03-15/"/>
      <url>/2019/03/15/2019-03-15/</url>
      
        <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />    <label for="pass">Please enter the password to read the blog.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解单例模式的三大要素（最容易忽略的构造函数）</title>
      <link href="/2019/03/09/2019-03-09/"/>
      <url>/2019/03/09/2019-03-09/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解单例模式的三大要素（最容易忽略的构造函数）"><a href="#深入理解单例模式的三大要素（最容易忽略的构造函数）" class="headerlink" title="深入理解单例模式的三大要素（最容易忽略的构造函数）"></a>深入理解单例模式的三大要素（最容易忽略的构造函数）</h1><p>详细的怎么写一个单例在此不过多赘述，推荐 <a href="https://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">单例模式的八种写法比较</a><br>下面以其中最经典的双重检查写法为例进行说明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第一个要素"><a href="#第一个要素" class="headerlink" title="第一个要素"></a>第一个要素</h2><p>之前自己关注的重点一直在于getInstance获取单例的写法之中，可以理解为其仅仅是第一个要素，思想很好理解，先检查一次是否有被实例化，没有的话进行加锁，此时需要再通过一道检查，原因是要避免加锁语句产生的空隙，举个例子：A，B两个线程都访问到了第一次判断对象是否为null的语句，此时都检查为空，固其都能通过，即使有了加锁单例实例还是会被创建两次</p><h2 id="第二个要素"><a href="#第二个要素" class="headerlink" title="第二个要素"></a>第二个要素</h2><p>另一个要素也不难理解，即将单例声明成volatile以防止指令重排序造成的意外情况，贴上《Java并发编程的艺术》中对其的解释：<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/singleton_volatile1.png" alt><br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/singleton_volatile2.png" alt><br>固此处需要加volatile，依赖其添加的内存屏障以强制屏蔽编译器和JIT的优化工作。</p><h2 id="第三个要素（很重要）"><a href="#第三个要素（很重要）" class="headerlink" title="第三个要素（很重要）"></a>第三个要素（很重要）</h2><p>之前一直没有在意单例里边的<code>构造函数</code>，网上的文章也很范范没有特别强调，自己写的时候很容易就忽略了。<br>再看一遍单例的实现，可以发现里面特意写了一个private的且为空的构造函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Singleton() &#123;&#125;</span><br></pre></td></tr></table></figure><p>为什么这里要特意加一个空的构造函数呢？如果没有这个构造函数会有什么问题吗？当仔细推敲这个代码，不难发现其中的蹊跷。</p><blockquote><p>引用下昨天腾讯面试官问我的问题：我为什么一定要通过getInstance获取这个单例呢？我自己直接new一个不就有两个了吗？你怎么保证到单例的唯一性？（好问题，感慨鹅厂的前辈在一个问题的理解上真的很深）</p></blockquote><p>抛出这个问题后再看这个构造函数问题就迎刃而解了，如果用默认的构造函数，那么new一个依然可以获取到另一份单例实体，这是不允许的。<code>因此这里显示地把构造函数置空，同时加上了private保证外界无法访问，用户即使new了一个也无法再次创建单例对象，要用这个对象只能通过暴露给外界的getInstance方法获取</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>单例模式最初的定义出现于《设计模式》：“保证一个类仅有一个实例，并提供一个访问它的全局访问点。”，前面的两个要素仅仅是保证了提供了一个访问它的全局访问点（仅靠这两点还是伪单例），但无法保证该类只有一个实例，因此重写构造函数在唯一性的保证上显得尤为重要。</p><p>附上两点构造单例的要素：（特别容易忽视的第一点）</p><ol><li>将该类的构造方法定义为私有方法，<strong>这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象</strong>，只有通过该类提供的静态方法来得到该类的唯一实例；</li><li>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li></ol><p>最后的效果如图：</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/err_private%20access.png" style="width:388px; padding-left:0"><p>通过private保证后，我们无法通过new来重新建一个单例对象，只能用getInstance方法获取</p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java8 流“只遍历一次”的理解</title>
      <link href="/2019/01/21/2019-01-21/"/>
      <url>/2019/01/21/2019-01-21/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Java8-流“只遍历一次”的理解"><a href="#关于Java8-流“只遍历一次”的理解" class="headerlink" title="关于Java8 流“只遍历一次”的理解"></a>关于Java8 流“只遍历一次”的理解</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先贴上一篇整理的很到位的对流的基本介绍，没有接触过流的同学可以通过下文快速地对流有一个概念，在此就不再做多余的文字搬运工作<br>链接：<a href="https://blog.csdn.net/u010425776/article/details/52344425" target="_blank" rel="noopener">Java8新特性——StreamAPI(一) - 大闲人柴毛毛 - CSDN博客</a></p><h3 id="问题的产生"><a href="#问题的产生" class="headerlink" title="问题的产生"></a>问题的产生</h3><p>当时对流的特性之一：<code>只遍历一次</code>理解不够深入，导致在项目中出现了与预期相左的结果,现结合代码进行分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; test = publishList.stream().filter(it -&gt; it != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; it.getChannelIds() != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; it.getChannelIds().contains(channel.getId()))</span><br><span class="line">                .map(noticeRecord -&gt; &#123;</span><br><span class="line">                    <span class="comment">//执行了一些处理逻辑</span></span><br><span class="line">                    System.out.println(noticeRecord.getId());</span><br><span class="line">                &#125;).filter(it -&gt; it != <span class="keyword">null</span> &amp;&amp; !it.isEmpty()).findFirst().orElse(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>当时在对项目组曾经的旧项目重构代码写单元测试时发现了上述的一个方法，按照最开始我的理解，其流程为：将publishList中符合条件的元素通过filter筛选出来再通过map批量执行相关的操作逻辑（map中的具体逻辑不深究），最后再经过一遍filter，若结果集不为空则返回第一个，否则返回一个新的ArrayList避免空指针。<br>读懂了代码后开始写单元测试，可发现即使在第一个filter中允许有多个元素通过，但其在map中并不会都执行相应的逻辑，反复测试发现均只有一个元素做完了map中的方法。</p><blockquote><p>当时真的是各种打断点，打log看是哪个逻辑出了问题，无果</p></blockquote><p>最后把我能想到的风险点都排除了，问题依然没有解决，无论怎么设定数据，在map中始终只有一个数据得到处理，于是又想到为什么偏偏只有一个，或许和findFirst方法有关？bingo</p><h3 id="关于“只遍历一次”的理解"><a href="#关于“只遍历一次”的理解" class="headerlink" title="关于“只遍历一次”的理解"></a>关于“只遍历一次”的理解</h3><p>下面对流“只遍历一次”的实现原理进行阐述：</p><p> 一般来说Stream可分为三个部分：源source、中间操作Intermediate和终止操作Terminal。流的源可以是一个数组、一个集合、一个生成器方法，一个I/O通道等等。<br>一个流可以有零个和或者多个中间操作，每一个中间操作都会返回一个新的流，供下一个操作使用一个流只会有一个终止操作。<code>中间操作都是惰性的，也就是说仅仅调用流的中间操作，其实并没有真正开始流的源的遍历</code>。一个流只能有一个终止操作，它必定是流的最后一个操作。只有调用了流的终止操作，流的源的元素才会真正的开始遍历，并且会生成一个结果返回或者产生一个副作用（side-effect）。另外，每一个流只能被使用一次（即调用中间操作或者终止操作）。</p><p>从表面上来看，好像流在执行了多个中间操作和一个终止操作之后，对于每一个操作，流中的元素都会遍历执行，也就是有几个操作，流中的元素就会进行几次遍历。这种观点是<code>大错特错的</code>。</p><p>流的实际执行流程是这样的，在遇到中间操作的时候，其实只是构建了一个Pipeline对象，而该对象是一个双向链表的数据结构，只有在遇到终止操作的时候，那些中间操作和终止操作会被封装成链表的数据结构链接起来，而流中每一个元素只会按照顺序链接的去执行这些操作，也就是说，<code>流中的元素最终只会在遇到终止操作后遍历一次，而每个元素会将所有操作按顺序执行一遍</code>。</p><h3 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h3><p>具体回到项目中遇见的问题， 当流遇上终止操作findFirst()时，流真正开始执行，不像我们想当然的所有元素先一起经过filter再一起经过map，而是每个元素像水流一样逐个地走完整个流程，当第一个元素成功到达终止操作findFirst时，流即被<code>截断</code>（findFirst：找到第一个元素。找到了就直接返回，不在遍历后面元素）。所以之前无论流中还有多少符合filter的数据，其都不会执行map方法。</p><blockquote><p>这次找了许久的bug归根到底是自己对jdk8新特性底层的不熟悉，反思反思</p></blockquote><hr><br><p>参考资料：</p><p><a href="https://blog.csdn.net/u010425776/article/details/52344425" target="_blank" rel="noopener">Java8新特性——StreamAPI(一) - 大闲人柴毛毛 - CSDN博客</a></p><p><a href="https://blog.csdn.net/zw19910924/article/details/76945279" target="_blank" rel="noopener">Java8的流Stream与收集器Collector详解 - zw19910924的专栏 - CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年终复盘</title>
      <link href="/2018/12/31/2018-12-31/"/>
      <url>/2018/12/31/2018-12-31/</url>
      
        <content type="html"><![CDATA[<h1 id="2018年终复盘"><a href="#2018年终复盘" class="headerlink" title="2018年终复盘"></a>2018年终复盘</h1><p>懒洋洋地躺在被窝里敲下这篇复盘，细细梳理一下，总的来说18年<del>还不错</del> 高于预期（鉴于女票都说我人生巅峰了🤣）</p><h3 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h3><p>先按时间的逻辑复盘下自己做了哪些事👣</p><ol><li>从去年年底开始直到今年4月都在忙着做项目，没错就是折腾了大半年的御宽，给它一个高大上的名字叫《基于深度学习的股市量化平台》，从参赛作品的角度，创意到实现到展示我觉得都没什么毛病，这段时间拿了不少的校奖和上海市奖，也申了软著。</li><li>4月份权衡了下决定保研，遂开始着手联系外校老师，准备材料，同时开始为夏令营的面试做准备。</li><li>6月份-7月底奔波于各大高校夏令营，参加推免生面试，收获也不错，成功拿到了复旦和交大的offer。（这一段经历一直想写博文记录下来，拖到现在，8000字洋洋洒洒第一版终于是写完了）</li><li>七八月份继续打软开和创赛的国赛，小伙伴真的很给力，队长老安心了，公费旅游去了山西太原，拿了1个国一1个国二，这一块算圆满了</li><li>9月份继续忙着九推，主要就是申清北和一直心心念念的浙大，其实也就面了清华和浙大（巧的是10年前的时候去北京旅游，到清华参观，10年后去清华面试哈哈），北大时间和浙大冲突了，最后尘埃落定，<del>圆梦</del> 选择了一直想去的浙大（现在说圆梦好像早了点）</li><li>10月开始入职网易，平台开发实习至今。主要完成了秒杀系统和抽奖系统的后台，以及一些知识的积累沉淀。</li></ol><h3 id="Milestone"><a href="#Milestone" class="headerlink" title="Milestone"></a>Milestone</h3><ol><li><strong>国家奖学金</strong>！评上之后感觉本科圆满了，虽然无缘后面的校长奖还是有点遗憾，感慨选择真的拉比重要，研究生再加油，痛定思痛哈哈</li><li>认真准备的比赛成功从上海市打进了全国还拿了国一和国二，好歹没浪费时间</li><li>保研拿了复、交、浙的offer，也有机会去清北参加面试考核，看见了最顶端的模样，最后去了最想去的学校🎏</li><li>第一个大厂的实习，猪场真的名副其实</li><li>6级成功刷到了560分，第三把!</li><li>遇到了某只打农药比我厉害的猪蹄并把她变成了<strong>女票</strong>哈哈哈/羞涩，快晚上上分了@小猪蹄</li><li>还记得大二和zyf立的flag，连续三年的学业特等奖我吹爆，哈哈今年还是单年的<strong>第一</strong>☝️</li><li>大致估算了一把已经赚到了人生中第一个<strong>六位数</strong>（奖学金+家教+实习工资+理财），虽然工作以后再来看或许就是几个月的工资，在大学里却花了三年多的时间，不过大一开始经济独立的意义真的特别大。</li><li>正式开始更新自己的个人博客，虽然大二就搭完上线了，但一直没有去运作。（第一次感觉自己有拖延症就在写博客上）</li></ol><p>一梳理发现还挺充实的，展望什么的就不在此罗列了，因为想要的还挺多的哈哈哈，实力依旧配不上野心，继续加油，反正每次再回头看去年的自己，总是忍不住嘲讽自己这里菜那里菜，最后再总结下两个贯穿全年的计划：</p><h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><p>130斤的flag还是没达到，最新的是127斤半，BMI 20.1，可算是脱离了偏瘦的范围，其实今年年中一度达到过130斤，哎，多锻炼多锻炼，目前保持每周2-3次的频率，胸，手臂和肩膀，背和腰腹，下肢，自己划分了四个主题，每次练完第二天都感觉被人打了一顿，满足感杠杠的💪</p><h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3><p>股市</p><p>今年投资是真的难，股市都跌成啥diao样了，翻了下去年入市第一年的收益有12个点，今年第二年 -19.74%，老韭菜表示波澜不惊，较去年换了种投资风格，无脑长线持有绩优白马，适时加仓，一股没减，唔罢了好歹还是跑赢指数了，跑赢P2P我就不奢望了</p><p>基金</p><p>讲道理这种估值洼地应该持续买入基金建仓，不过发现基金还跑不过自己的收益的时候，我就呵呵了，今年基金综合-29.78%（其实怪我没有坚持一直定投），还好就几千块，现在准备考虑建仓跟踪指数的基金。大牛猫推荐的中证500和证券ETF</p><p>P2P</p><p>虽然今年暑期P2P爆了一波大雷，我倒还挺安心的，现在只认股权上市的两个千亿平台，全年收益大概有10%左右（雷潮后收益率明显降低，360天期限现在只有8.5%左右）</p><p>总的来看全年的收益大概在5%左右，也就跑平了通胀，现在逐渐把到期的p2p投入股市，真的是韭菜割了一茬又一茬啊哈哈。┑(￣Д ￣)┍</p><p>2019年目标10个点的flag立在这里了！A股麻烦您佬给点力📈</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>最后引一个非常文艺又非主流的别人年终总结的博客标题做结尾</p><blockquote><p>我用时间称自己的重量，然后数落自己的肤浅与狂妄</p></blockquote><p>望来年的自己再回顾现在的自己时，能狠狠地喷一句：“你怎么那么菜啊！”</p><p>瑞雪兆丰年❄️</p><p>新年快乐！</p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E7%9C%8B%E7%A9%BF%E4%B8%96%E4%BA%8B%E7%9A%84%E7%8B%97%E5%AD%90.jpeg " style="width:188px">]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 清北复交浙 计算机/软件 推免经历</title>
      <link href="/2018/12/24/2018-12-24/"/>
      <url>/2018/12/24/2018-12-24/</url>
      
        <content type="html"><![CDATA[<p>建议配合【<a href="https://zc-apiao.world/blog/2018/11/29/%E5%85%B3%E4%BA%8E%E4%BF%9D%E7%A0%94-%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/" target="_blank" rel="noopener">关于保研——写在最前面</a>】食用</p><p>最后的offer：复旦软院，交大软院，浙大软院</p><blockquote><p>软院和计院功能高度重合，你想学的方向相信我，软院计院都会有的(不信可以去相关学校的官网看两个学院老师的简介与方向)</p></blockquote><h1 id="一、夏令营情况"><a href="#一、夏令营情况" class="headerlink" title="一、夏令营情况"></a>一、夏令营情况</h1><hr><h3 id="复旦"><a href="#复旦" class="headerlink" title="复旦"></a>复旦</h3><p>复旦的计院和软院还有个好像是信息安全，三个方向的申请虽然不同，但最后都是在一起入营考核的，考核的方式都一样，甚至在最后面试还可以自由选方向（没把握可以入营的可以申软院，会比较好通过初审）</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>入营后，计院和软院的院长给我们致辞（没错是同一个），说计院申请的人就有千余人（具体的量级记不清了），最后我们(三个方向）坐在下面通过初审的就只有80+个（计科：软院：信安 = 5:3:1，大概是这个比例，等最后面试，计院软院人数55开了），当时印象最深刻的就是<strong>申软院入营的概率比计科高太多了</strong>。</p><p>复旦夏令营营期3天，第一天和第二天上午听各方向介绍，第二天下午英语口语面试，每人5分钟左右，无非就是你问我答基本的一些问题，诸如介绍你的家乡/你的专业云云，第三天上午机试，难度横向对比是几个学校算最简单的😃，给三个题，每题分3个数据量，基本上小数据量暴力都能写，中等的要用到正确的算法，大的就要用最优的算法，三道题一题动态规划，一题字符串，一题DFS还是BFS记不清了，比较坑的地方是你上交后不知道是否AC，类似于CCF的模式，最后我写完感觉还不错，估摸着对两道半吧。。</p><h4 id="一些tips："><a href="#一些tips：" class="headerlink" title="一些tips："></a>一些tips：</h4><ul><li>提前联系导师，4月份就可以开始联系了，复旦联系导师还是很管用的，有的导师还可以帮助你入营（比如我的导师就直接帮我确认了能入营，当时和老师聊完答复也挺好，“机试发挥的可以就没什么问题”）</li><li>没有提前联系的也可以在入营后第二天去找老师唠嗑，我当时听到了一个计科的老师，对他很感兴趣就去了，尴尬的是那个老师对我印象也挺好，说他本来不打算招外校的同学了，破例算我一个，实验室大组还有名额就给我争取，然后叫我明天去面他们实验室，woc当时真的叫一个尴尬（这个事情告诉我们提前联系导师的弊端在于，宣讲会上你会听见各种方向各种生动的讲解，说不定哪个你就心动了，但这时候你已经和之前的导师联系过了，气氛就会real尬，更惨的情况是两个老师如果是同一个学院的，万一面试碰上他俩都坐在底下🤪）</li><li>机试定江山，英语面只要过得去就可以了，老师人超nice，最后的面试也是，你和导师提前聊过后，在面试的时候基本都是那个导师的实验室里的老师在问你问题，围绕项目，不会很刁钻（甚至都没问专业课）</li><li>院长直接在宣讲会上表示夏令营不会录取很多，大概在20个人左右，更多的机会在九推，所以筒子们不要放弃每一个机会</li></ul><p>复旦效率非常高，大概过了2-3天，收到录取邮件，软工学硕（额，在进考场前10分钟收到的消息，过于开心直接做崩了交大的机试）</p><h3 id="交大软院"><a href="#交大软院" class="headerlink" title="交大软院"></a>交大软院</h3><p>通过交大的初审还挺意外的，因为我们学校之前没有一个通过过交大初审，更意外的是摸着黑过河居然还拿到了offer。。。</p><h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><p>不得不吐槽交大的流程，整个营期要5天，第一天报完到，第二天白天讲座晚上就直接机试了，之后第三第四天就是自己去参观实验室，第五天面试。早知道第三第四天没什么事我就回学校了/摊手（闵大荒真的很远，直接订了5天酒店）</p><p>上交的机试我觉得是所有学校最难的，它难点在与把工程和算法结合在了一起，四个小时做一个大的工程，要有GUI的那种，虽然说是开卷（要带自己电脑），但和ACM的开卷完全是两个概念，考察的算法很简单，LCS，具体的题目大家可以好好搜下准备下，我印象最深的就是进场前千万检查好自己本地的环境，我当时一看题就想要Java web + Echarts.js可视化去实现，结果一打开IDEA发现之前配微服务的时候把环境搞炸了，现场环境是不能联网的，maven没法下包，卒。。。最后做完是把工程放在自己的电脑里，之后一个个等人工评分（轮到我已经快12点了。。半夜12点🤯），机试做得不够好，中下。</p><p>其实做完机试我觉得上交已经凉了，最后抱着死猪不怕开水烫还是走完了面试，面试的老师一上来：“你觉得机试做得怎么样？”我一听就知道机试炸了，赶紧说环境的问题，想要的实现没做出来。上交会在夏令营开始前给入围的人发面试题目，每个实验室题目不一样，基本都是看指定的论文再做ppt去答辩，这一块我看来一定要结合自己的东西，最好与自己的项目结合着讲，不然会很空，记住答辩的目标是去展现自己，别把范围限定在给定的题目里了，一定要结合自己的东西。在这次我还犯了非常严重的错误，导师问我：“那你觉得自己更擅长什么？编码还是写文章？”，我一想机试都做崩了说编码也太苍白了，然后突然想到之前复旦的老师和我说你的领导力是一个闪光点，脑子一抽脱口而出：“我觉得我更擅长带领团队做项目。。。”，当场老师们都笑了，说完才意识到说错话了，这个时候最稳妥的选择应该是写文章，虽然我这个出乎意料的答案可能会让部分老师觉得这同学很有想法，但在这个场合说还是弊大于利。</p><p>最后会问一个英语问题，说你最喜欢的科目，囧，没准备到。</p><p>面完感觉凉凉，不过当时已经过了复旦了再加上之前预期也没那么高，还是没心没肺地在交大浪了一圈，最后在交大凯旋门合了照走人。。</p><p>交大面试的结果官方说法是在9月初才会给，部分非常牛逼的同学一结束就有老师会联系，后来大家陆陆续续收到通知，一开始其实给的外校offer特别少，后来应该是大部分人被清华挖走了（清华面试的时候一半都是熟面孔），我居然奇迹地通过了，虽然当时已经铁了心准备去浙大了还是很开心，哈哈，最后给的是专硕还是学硕已经记不清了，老师打电话给我之后思考了了十分钟拒绝。</p><h4 id="一些tips：-1"><a href="#一些tips：-1" class="headerlink" title="一些tips："></a>一些tips：</h4><ul><li>机试真的定江山，之前网上有说上交不看重机试，假的。。。外校的旁友还是好好刷题把，同时直接搜真题刷，题目和一般的OJ算法题完全两个概念</li><li>还是机试，这里开卷别带什么ACM模板，带各种Java/Python/C++的电子书（选自己熟悉的语言），一定要有可视化的章节，可视化部分虽然占比不高，但你做出来了，评审的人一下印象就好很多，会java的同学建议带着echars.js相关的可视化资料，很实用</li><li>因为是用自己的电脑做的机试，相关的设备自己准备好，特别是IDE环境，一定要确认，开考后是没有网络的，很多连网下载的包要提前下到本地，不然真的，巧妇难为无米之炊👾</li><li>有时间还是和自己的导师多联系，去参观参观实验室没错。</li><li>上交其实在入营前大家就已经准备好面试的材料了，对于夏令营日程比较紧的同学来说，其实负担还挺大的，好好准备PPT（答辩时可以坐着对着屏幕用演讲者模式）。</li><li>上交真的很漂亮，第三四天或者结束了一定要好好逛逛，校区里边有公交车的就是任性，还可以自己租共享电动车，上交特有（真的是共享小电驴）。 </li></ul><p>最后大概9.20日收到老师的电话offer，其实现在还是有点可惜拒绝了上交，感觉是南方计算机最好的学校，也真的不好进。</p><hr><p>整个夏令营一共投了清北复交，同济，华师大，南大，上科大。清北毫无悬念的没有入营，南大今年报的人超多也没入营（老师微信里给我说叫我九推再报），华师大时间和复旦撞车了，上科大给通知太晚后来懒得去拒了，令我挺意外的倒是同济没入营，同济的计院和软院我都投了，计院只要了我们学院的第一（不应该啊，之前几届听学长说都很好进，估摸着是不是鸽的人太多了名额就少了），软院打电话问我要不要读博，秒拒，然后就要了另一个直博的入营 /社会社会。</p><blockquote><p>其实后来庆幸同济没入营，复旦+同济+上交时间刚好首尾相连，这么大强度整半个月真的吃不消</p></blockquote><h1 id="二、九推"><a href="#二、九推" class="headerlink" title="二、九推"></a>二、九推</h1><hr><p>因为已经有offer的关系，到九推的时候我压力就比较小了，就报了一直想进的浙大软院和清北，我本来以为清北初审肯定过不了，抱着不留遗憾的心态又去麻烦老师签好了推荐信，又抱着一大摞材料寄出去吗，结果居然都过了初审收到了面试…</p><h3 id="清华软院"><a href="#清华软院" class="headerlink" title="清华软院"></a>清华软院</h3><p>大概是九月中旬面试，提前一礼拜收到通知，清华的复试还要额外交100的费用，大概是怕你鸽了吧，其实去不去面试我还纠结了很久，因为胜算真的不大，我查了下前两年的数据，去年初审过了70人左右，最后招了30+吧，接近一半的通过率乍一看感觉挺高的，直到我数了下70个人里，211院校出身的不到1 0个，最后过的印象里就两三个吧（今年初审过了接近80人，但本校扩招了，最后外校也就招30左右），另一方面复试的时候正好赶上学校国家奖学金答辩，本人答都不一定能评上，更别说代答了。又算了算来回一趟加住宿预算得2000+，略有点肉痛。。。</p><blockquote><p>Anyway，当然最后还是去了，真香</p></blockquote><h4 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h4><p>清华的机试题型更像ACM，做完了不知道结果，是保存在电脑里最后人工黑盒跑用例评卷的，第一题日期的转换，不难只是有点烦，第二题高精度（想想离清华的距离可能就差这道题了，当时一下懵了没做出来），第三题DP，我没推出公式，后来用暴力DFS解的，应该能得一半分吧，整个机试做下来感觉一般，做对一道半的话我感觉排在中等吧。<br>印象里机试完了还有一两天可以自己再准备准备面试，我就在清华找了个自习教室看书，最后一天面试，正常来说每个人15分钟，先问专业课，再问项目，中间夹着英语的问题。为什么强调了正常来说呢，因为我足足面了半小时/沧桑（现在回想起来可能是我刚好在那个临界位置，老师们一时吃不准）</p><blockquote><p>前面绝大部分人都卡好15分钟，到我真的是黑人问号</p></blockquote><p>面试感觉也一般，主要原因是老师专业课问了我编！译！原！理!我当时一听就想赶紧转移话题说没学好（其实应该说没复习到/没准备到），然后老师就怼我“你成绩单上这个课不是有90分吗？”，目瞪狗呆，赶紧接着解释：“老师那其他课比这高的还有很多呀”，老师又怼我：“那你是学习只为了应付考试咯”。。。。呃好吧，这原场打不下去了，继续解释把精力选择性地花在了感兴趣的地方，之后总算过了这个话题，另一个老师开始问我离散数学，这个答对了两题，最后一题没答出来，感觉这一块是一定要问到你不会为止。之后的项目就比较轻松了，老师还是挺感兴趣的，英语问的是用英文描述TCP和UDP的区别，我答得也还可以，虽然有个专业词汇用错了(可靠性reliability我一直在说security,最后老师给我纠正了）</p><p>最后面完其实我感觉还挺好，一来面试时间长说明老师在关注，二来最后结束的时候有老师问我：如果他们录取我了（因为我还报了清华在深圳的一个学院），问我会不会优先考虑这边，我当然说会啊，然后美滋滋地去食堂蹭了中饭。</p><blockquote><p>晕，我编译原理明明就没有90，3.7的绩点应该是85+，当时一下懵了没记起来，心里真的一万匹草拟马奔过🌚</p></blockquote><p>正常流程一礼拜后出结果，出拒绝的名单，我因为复旦一直在催要确认，提前打电话问了招生老师，告知没通过。</p><h4 id="一些tips"><a href="#一些tips" class="headerlink" title="一些tips"></a>一些tips</h4><ul><li>专业课准备的全面些，清华侧重点感觉和其他学校差别还挺大的，像离散数学几乎大家都被问到了，计网/操作系统/数据库这些常见的反倒没什么问</li><li>英语的话也是专业里的问题居多，不像之前的介绍自己啦介绍家乡啦，很多需要现场组织，emmm毕竟清华</li><li>有一个老师专门看你的成绩单然后问你分数较高的专业课，这方面可以自己注意下</li><li>面试时的简历要反复确认，我当时因为有个项目时间写错了没注意，面试就被问到为什么这个时间段做了那么多事，看挺认真的（一路下来其他学校都没关注到）</li><li>最后平常心吧，当时面试大概一半的人我在交大见过，大家面完也会一起交流面了什么问题（重复概率比较小）</li></ul><h3 id="北大软微"><a href="#北大软微" class="headerlink" title="北大软微"></a>北大软微</h3><p>面完清华过了好几天才出北大的初审结果，这几天就一个人在北京玩，故宫天安门圆明园，还是挺开心的（当时觉得自己清华还是有戏的），后来北大软微来通知了但时间在中秋以后，刚好和浙大面试时间撞车，哇当时把我纠结的，第二天我就跑到了北大软微的校区，一来看看环境，二来想问问老师能不能换时间之类的（因北大面试分方向面的，每个方向在不同的时间），到了校区真的非常失望，软微在大兴，北京郊区，除了一幢孤零零的教学楼和食堂挨在一块，就是一幢行政楼，其他都是各种各样的宿舍，蹭了顿饭也不好吃，又查了去北京大的互联网企业的距离，当场就感觉和软微没缘分了。</p><p>其实北大软微难度不高（招生规模摆在那），它的模式和浙大的软院很像，学生可以有大量的出去实习的时间，也可以选择跟老师做项目，选老师选了本部的还会搬到北大本部去。后来我看了过了初审的名单，所有相关方向加起来200人左右，招100+吧，里面大概一半的211，也有双非的学校，没有机试的考核，只有面试，许多来面试的都是没有专业背景的跨考。</p><blockquote><p>马后炮一把其实我感觉当时要是去面了北大软微过的概率有七八成（科班出身还怕和一大波跨考的人一起？(｡・`ω´･)）</p></blockquote><h3 id="浙大软院"><a href="#浙大软院" class="headerlink" title="浙大软院"></a>浙大软院</h3><p>流程最简短，半天就结束了，准确来说只有面试的15分钟，材料也不用各种花里胡哨的推荐信，网上很多面经都把题目说的很到位了，稍微准备下几乎没难度，不过现场对跨考的同学感觉问的问题会奇怪一些，对科班出身的问的超基础。</p><p>当时我进去面试，老师看完简历一上来就问：“哎你拿过国家奖学金啊”（能感觉到老师眼里都放光了），然后下一个问题就是还有没有其他学校的offer，我当时没敢说复交的，瞎说了个同济，然后不知怎么后来好像提到了今天鸽了北大的面试来这里面，老师们巨惊奇，吧啦吧啦了一通，大概时间过去七八分钟了，言归正传开始走正常流程，先考察英语，英语交流了30秒老师直接说可以了，然后问专业的问题，没啥印象了，很基础，出来就感觉这一把稳稳的，最后排名出来第10吧，应该是同组里的第一第二的样子/汗，最后录取的话递补到了140名左右。</p><h1 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h1><hr><p>啊这篇终于写完了，其实不算是很常规的面经，只是记录下这一段难忘的回忆，有些踩过的坑也想给学弟学妹们指个路，感谢一路上郭学长、刘学长、吴学姐、徐学长的帮助！</p><p>至今仍能记起刚拿到复旦offer时的喜悦与激动，也希望多年后的自己再看到这一篇博文，再想起当时的这个选择时，能笑着吐槽一句这个选择太tm正确了。</p><hr><h3 id="2019-2-17更新"><a href="#2019-2-17更新" class="headerlink" title="2019.2.17更新"></a>2019.2.17更新</h3><p>在leetcode上刷到了清华机试压轴试题。。。</p><p>居然是2015年就有的原题。。。</p><p>贴上链接：<a href="https://leetcode.com/problems/burst-balloons/" target="_blank" rel="noopener">burst-balloons🎈</a></p><blockquote><p>刷题不努力，机试徒伤悲系列😭</p></blockquote><p>所以学弟学妹们一定要好好刷题！好好刷题！好好刷题！手撕代码什么的在各种场合都很看重</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC + Redis实现激活码秒杀活动（4.性能优化极致的Version3）</title>
      <link href="/2018/12/16/2018-12-16/"/>
      <url>/2018/12/16/2018-12-16/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-MVC-Redis实现激活码秒杀活动（4-性能优化极致的Version3）"><a href="#Spring-MVC-Redis实现激活码秒杀活动（4-性能优化极致的Version3）" class="headerlink" title="Spring MVC + Redis实现激活码秒杀活动（4.性能优化极致的Version3）"></a>Spring MVC + Redis实现激活码秒杀活动（4.性能优化极致的Version3）</h1><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/seckill/seckill_flowChat.png" alt="在这里插入图片描述"></p><p>在这个版本中，进一步优化统计接口，将redis中的计数用新建异步线程完成，避免和主线程竞争redis资源；同时在前台加上定时器，方便时间验证直接从实例内存里获取。</p><h4 id="核心代码-SeckillService"><a href="#核心代码-SeckillService" class="headerlink" title="核心代码 SeckillService"></a>核心代码 SeckillService</h4><p>基于访问的统计（一次请求参与人数+1）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRemainCode = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CodeService codeService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SeckillRecordDao seckillRecordDao;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LoadRoundService loadRoundService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SeckillCacheDao seckillCacheDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsRemainCode</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isRemainCode = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * seckill</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillResponse <span class="title">seckill</span><span class="params">(String urs)</span> </span>&#123;</span><br><span class="line">        SeckillResponse seckillResponse = <span class="keyword">new</span> SeckillResponse();</span><br><span class="line">        <span class="comment">//Object startTime = commonRedisDao.get(SeckillConsts.CURRENT_ROUND);</span></span><br><span class="line">        Object startTime = loadRoundService.getRound();</span><br><span class="line">        <span class="keyword">if</span> (startTime == <span class="keyword">null</span> || !isLegalTime(startTime.toString())) &#123;</span><br><span class="line">            seckillResponse.setStatus(SeckillBusinessProtocol.TIME_ILLEGAL);</span><br><span class="line">            <span class="keyword">return</span> seckillResponse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先在本实例的内存中查重,未找到再去redis查重</span></span><br><span class="line">        String ursInCache = seckillCacheDao.get(urs);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(ursInCache)) &#123;</span><br><span class="line">            executorService.execute(</span><br><span class="line">                    <span class="keyword">new</span> SeckillRecordTask(ursInCache, Long.valueOf(startTime.toString()), seckillRecordDao));</span><br><span class="line">            seckillResponse.setStatus(SeckillBusinessProtocol.DUPLICATED_CODE);</span><br><span class="line">            <span class="keyword">return</span> seckillResponse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在redis中找</span></span><br><span class="line">        String status = codeService.hget(SeckillConsts.WIN_CODE, urs);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(status)) &#123;</span><br><span class="line">            executorService.execute(</span><br><span class="line">                    <span class="keyword">new</span> SeckillRecordTask(status, Long.valueOf(startTime.toString()), seckillRecordDao));</span><br><span class="line">            seckillResponse.setStatus(SeckillBusinessProtocol.DUPLICATED_CODE);</span><br><span class="line">            <span class="keyword">return</span> seckillResponse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据身份抢码</span></span><br><span class="line">        <span class="keyword">if</span> (codeService.isWhiteUser(urs)) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> SeckillRecordTask(SeckillConsts.WHITE_USER,</span><br><span class="line">                    Long.valueOf(startTime.toString()), seckillRecordDao));</span><br><span class="line">            <span class="keyword">return</span> seckill(urs, SeckillConsts.WHITE_USER, seckillResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (codeService.isBlackUser(urs)) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> SeckillRecordTask(SeckillConsts.BLACK_USER,</span><br><span class="line">                    Long.valueOf(startTime.toString()), seckillRecordDao));</span><br><span class="line">            seckillResponse.setStatus(SeckillBusinessProtocol.DUPLICATED_CODE);</span><br><span class="line">            seckillResponse.setStatus(SeckillBusinessProtocol.RANK_BLACK_PARTICIPATED);</span><br><span class="line">            <span class="keyword">return</span> seckillResponse;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> SeckillRecordTask(SeckillConsts.NORMAL_USER,</span><br><span class="line">                    Long.valueOf(startTime.toString()), seckillRecordDao));</span><br><span class="line">            <span class="keyword">return</span> seckill(urs, SeckillConsts.NORMAL_USER, seckillResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * seckill</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SeckillResponse <span class="title">seckill</span><span class="params">(String urs, String userRank, SeckillResponse seckillResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isRemainCode) &#123;</span><br><span class="line">            String code = codeService.getCode(SeckillConsts.CODE_LIST + userRank);</span><br><span class="line">            <span class="keyword">if</span> (code != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (codeService.setCodeWinner(SeckillConsts.WIN_CODE + userRank, urs, code)) &#123;</span><br><span class="line">                    seckillCacheDao.put(urs, userRank);</span><br><span class="line">                    seckillResponse.setStatus(SeckillBusinessProtocol.GET_CODE);</span><br><span class="line">                    seckillResponse.setCode(code);</span><br><span class="line">                    <span class="keyword">return</span> seckillResponse;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    codeService.put(SeckillConsts.CODE_LIST + userRank, code);</span><br><span class="line">                    isRemainCode = <span class="keyword">true</span>;</span><br><span class="line">                    seckillResponse.setStatus(SeckillBusinessProtocol.DUPLICATED_CODE);</span><br><span class="line">                    <span class="keyword">return</span> seckillResponse;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isRemainCode = <span class="keyword">false</span>;</span><br><span class="line">        seckillResponse.setStatus(SeckillBusinessProtocol.FAIL_CODE);</span><br><span class="line">        <span class="keyword">return</span> seckillResponse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>SeckillRecordTask :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillRecordTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String rank;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> currentRound;</span><br><span class="line">    <span class="keyword">private</span> SeckillRecordDao seckillRecordDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SeckillRecordTask construct</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillRecordTask</span><span class="params">(String rank, <span class="keyword">long</span> currentRound, SeckillRecordDao seckillRecordDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rank = rank;</span><br><span class="line">        <span class="keyword">this</span>.currentRound = currentRound;</span><br><span class="line">        <span class="keyword">this</span>.seckillRecordDao = seckillRecordDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seckillRecordDao.increaseParticipate(<span class="keyword">this</span>.rank, <span class="keyword">this</span>.currentRound);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下具体的任务创建的方法，由于用了new每次新建一个任务，所以这里<strong>不能再通过Spring注入的方式完成依赖的注入</strong>，因为用new了之后就不再归Spring管理，组件涉及到的所有的注入都会失效（直接报NPE）,两种解决方法，1.直接把任务设定成单例，这样也可以避免每次都新创建一个任务，增加GC的工作；2.将要注入的Dao，直接作为形参传入，我用了第二种实现方式，其实感觉语义会有点奇怪。</p><p>上述实现的逻辑还是基于访问次数的统计，后将逻辑改成按账号统计，故不再需要线程池，核心代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRemainCode = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CodeService codeService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LoadRoundService loadRoundService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SeckillCacheDao seckillCacheDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsRemainCode</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isRemainCode = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * seckill</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillResponse <span class="title">seckill</span><span class="params">(String urs)</span> </span>&#123;</span><br><span class="line">        SeckillResponse seckillResponse = <span class="keyword">new</span> SeckillResponse();</span><br><span class="line">        Object startTime = loadRoundService.getRound();</span><br><span class="line">        <span class="keyword">if</span> (startTime == <span class="keyword">null</span> || !isLegalTime(startTime.toString())) &#123;</span><br><span class="line">            seckillResponse.setStatus(SeckillBusinessProtocol.TIME_ILLEGAL);</span><br><span class="line">            <span class="keyword">return</span> seckillResponse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先在本实例的内存中查重,未找到再去redis查重</span></span><br><span class="line">        String ursInCache = seckillCacheDao.get(urs);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(ursInCache)) &#123;</span><br><span class="line">            seckillResponse.setStatus(SeckillBusinessProtocol.DUPLICATED_CODE);</span><br><span class="line">            <span class="keyword">return</span> seckillResponse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在redis中找</span></span><br><span class="line">        String ursInRedis = codeService.getUrsInRedis(SeckillConsts.WIN_CODE, urs);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(ursInRedis)) &#123;</span><br><span class="line">            seckillResponse.setStatus(SeckillBusinessProtocol.DUPLICATED_CODE);</span><br><span class="line">            <span class="keyword">return</span> seckillResponse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据身份抢码</span></span><br><span class="line">        <span class="keyword">if</span> (codeService.isBlackUser(urs)) &#123;</span><br><span class="line">            codeService.setUrsFailure(SeckillConsts.FAIL_CODE_BLACK_USER, urs);</span><br><span class="line">            seckillResponse.setStatus(SeckillBusinessProtocol.RANK_BLACK_PARTICIPATED);</span><br><span class="line">            <span class="keyword">return</span> seckillResponse;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (codeService.isWhiteUser(urs)) &#123;</span><br><span class="line">            <span class="keyword">return</span> seckill(urs, SeckillConsts.WHITE_USER, seckillResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> seckill(urs, SeckillConsts.NORMAL_USER, seckillResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * seckill</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SeckillResponse <span class="title">seckill</span><span class="params">(String urs, String userRank, SeckillResponse seckillResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isRemainCode) &#123;</span><br><span class="line">            String code = codeService.getCode(SeckillConsts.CODE_LIST + userRank);</span><br><span class="line">            <span class="keyword">if</span> (code != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (codeService.setUrsSuccess(SeckillConsts.WIN_CODE + userRank, urs, code) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    seckillCacheDao.put(urs, userRank);</span><br><span class="line">                    seckillResponse.setStatus(SeckillBusinessProtocol.GET_CODE);</span><br><span class="line">                    seckillResponse.setCode(code);</span><br><span class="line">                    <span class="keyword">return</span> seckillResponse;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    codeService.put(SeckillConsts.CODE_LIST + userRank, code);</span><br><span class="line">                    isRemainCode = <span class="keyword">true</span>;</span><br><span class="line">                    seckillResponse.setStatus(SeckillBusinessProtocol.DUPLICATED_CODE);</span><br><span class="line">                    <span class="keyword">return</span> seckillResponse;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isRemainCode = <span class="keyword">false</span>;</span><br><span class="line">        codeService.setUrsFailure(SeckillConsts.FAIL_CODE + userRank, urs);</span><br><span class="line">        seckillResponse.setStatus(SeckillBusinessProtocol.FAIL_CODE);</span><br><span class="line">        <span class="keyword">return</span> seckillResponse;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="后台定时器"><a href="#后台定时器" class="headerlink" title="后台定时器"></a>后台定时器</h4><p>这里换了种timer的实现，直接用Spring的timer：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(jedisDao.lock(</span><br><span class="line">                SeckillConsts.REDIS_PREFIX, SeckillConsts.LOCK, SeckillConsts.EXPIRE))) &#123;</span><br><span class="line">            nextRound = seckillConfigDao.getNextRound();</span><br><span class="line">            <span class="keyword">boolean</span> isBegin = isBeginTime();</span><br><span class="line">            <span class="keyword">if</span> (nextRound != <span class="keyword">null</span> &amp;&amp; isBegin) &#123;</span><br><span class="line">                seckillRedisService.initRedis(nextRound);</span><br><span class="line">                currentRound = nextRound;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isBegin &amp;&amp; currentRound != <span class="keyword">null</span> &amp;&amp; isEndTime()) &#123;</span><br><span class="line">                persistService.persistToDb(currentRound);</span><br><span class="line">                currentRound = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            jedisDao.unlock(SeckillConsts.REDIS_PREFIX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见上面的代码比之前简介了很多，一是直接用Spring管理定时器，省去了我们自己管理的操作，二是将之前的两个标志位（isEnd 和isBegin，其实之前一直只需要一个标志就好了，二者是互斥的），通过redis加分布式锁的方式优化掉了，语义更简洁</p><h4 id="前台定时器"><a href="#前台定时器" class="headerlink" title="前台定时器"></a>前台定时器</h4><p>在这里最简单粗暴的操作就是直接复制后台的定时器，我比较作的又换了种方法实现：即通过后台跳转前台的url实现定时的操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(value = <span class="string">"$&#123;seckill.basePath&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String basePath;</span><br><span class="line"><span class="meta">@Value</span>(value = <span class="string">"$&#123;seckill.url&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">frontendFoward</span><span class="params">()</span> </span>&#123; <span class="comment">//这一步封装在定时器的initRedis中，也就是每场活动前都会调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; REPEAT;i++) &#123;</span><br><span class="line">        String response = HttpClient4Utils.httpPost(basePath + url, <span class="keyword">null</span>); <span class="comment">//这里直接用了现成的工具类，变量从.properties读取</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(response)) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Frontend forward failed, url: &#123;&#125;"</span>, basePath + url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用完发现其实还是直接用定时器更好，这样写有几个地方要考虑：</p><ol><li>分布式环境下，前台做了负载均衡则这边要慎重使用，因为url跳转一次代表一个请求发出，只能被一台前台 接收，固此处我重复将该请求发了REPEAT次，确保每台实例都收到请求（不推荐）</li><li>需考虑网络阻塞导致失败的情况</li><li>需在前台Controller中做好权限验证</li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总结一下做的几个优化：</p><ol><li>黑白用户名单可以事先导入内存，节省确认用户身份时间</li><li>生成的激活码也可以在活动开始前生成并导入redis</li><li>已抢码用户在每场活动结束后，同步至本实例内存中，以加快查重</li><li>统计功能用异步线程实现，避免争抢redis资源</li><li>新增isRemainCode标签，用于在激活码已抢完时直接返回</li><li>前台获取时间直接从内存中读取（由前台定时器直接控制该变量的改变）</li><li>更换redis的连接池配置（后来用了三种不同的连接池方式测试，见 <a href="https://mp.csdn.net/mdeditor/84939744#" target="_blank" rel="noopener">源码解析：探究JedisPool与CommonRedis的性能差异</a>）</li><li>redis优化，直接用原生jedis速度最快，关闭了testOnBorrow/testOnReturn</li><li>JVM调优：java -Xmx3550m -Xms3550m -Xmn2g <em>-Xss128k</em>（128K可能会报StackOverflow）</li></ol><p>最坏情况下（用户抢码成功）：检查时间（内存级）+ 在内存中确认是否重复（内存）+ 内存中没有继续在redis中查重（redis）+ 确认用户身份（内存） + 检查是否有码（内存） + lpop激活码（redis） + 信息写回redis（写回redis） = 3次redis操作 + 若干内存级操作 + 0 次db操作</p><p>最坏情况下（用户抢码失败）：2次redis操作（即少了lpop激活码一次访问redis） + 若干内存级操作 + 0 次db操作</p><p>这个版本的QPS已成功突破3000,线上服务器的峰值QPS测试在3600左右，可以说性能已经达到了目前机器的上限<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/seckill/seckill_QPS2.png" alt="在这里插入图片描述"></p><p>其实还要优化的话，可以从批处理的角度去考虑，即一次导出100个码到内存中，成功/失败抢码的写回也是100个才写一次，这个做法牺牲了部分的可靠性但节省的是成百倍的中间件性能，根据需求考虑是否使用。</p><blockquote><p>这部分的思考见上一篇系列博文<a href="http://zc-apiao.world/blog/2018/12/12/Spring-MVC-+-Redis%E5%AE%9E%E7%8E%B0%E6%BF%80%E6%B4%BB%E7%A0%81%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8-3.%E9%80%9A%E8%BF%87lpop%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9A%84Version2/" target="_blank" rel="noopener">《Spring MVC + Redis实现激活码秒杀活动（3.通过lpop操作实现并发控制的Version2）</a>》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易 </tag>
            
            <tag> Java </tag>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC + Redis实现激活码秒杀活动（3.通过lpop操作实现并发控制的Version2）</title>
      <link href="/2018/12/12/2018-12-12/"/>
      <url>/2018/12/12/2018-12-12/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-MVC-Redis实现激活码秒杀活动（3-通过lpop操作实现并发控制的Version2）"><a href="#Spring-MVC-Redis实现激活码秒杀活动（3-通过lpop操作实现并发控制的Version2）" class="headerlink" title="Spring MVC + Redis实现激活码秒杀活动（3.通过lpop操作实现并发控制的Version2）"></a>Spring MVC + Redis实现激活码秒杀活动（3.通过lpop操作实现并发控制的Version2）</h1><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/seckill/seckill_flowChat.png" alt="在这里插入图片描述"></p><p>在这个版本中，并发控制直接通过redis的lpop操作去实现，具体如下：</p><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SeckillResponse <span class="title">seckill</span><span class="params">(String urs)</span> </span>&#123;</span><br><span class="line">       SeckillResponse seckillResponse = <span class="keyword">new</span> SeckillResponse();</span><br><span class="line">       <span class="keyword">if</span> (!isLegalTime()) &#123;</span><br><span class="line">           seckillResponse.setStatus(TIME_ILLEGAL);</span><br><span class="line">           <span class="keyword">return</span> seckillResponse;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//先在本实例的内存中查重,未找到再去redis查重</span></span><br><span class="line">       <span class="keyword">if</span> (winUserMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">           String rank = winUserMap.get(urs);</span><br><span class="line">           <span class="keyword">if</span> (!StringUtils.isEmpty(rank)) &#123;</span><br><span class="line">               codeService.put((PARTICIPATE + rank), urs);</span><br><span class="line">               seckillResponse.setStatus(DUPLICATED_CODE);</span><br><span class="line">               <span class="keyword">return</span> seckillResponse;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//在redis中找</span></span><br><span class="line">       <span class="keyword">if</span> (codeService.isExists(WIN_CODE_NORMAL_USER, urs)) &#123;</span><br><span class="line">           codeService.put((PARTICIPATE_NORMAL_USER), urs);</span><br><span class="line">           seckillResponse.setStatus(DUPLICATED_CODE);</span><br><span class="line">           <span class="keyword">return</span> seckillResponse;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (codeService.isExists(WIN_CODE_WHITE_USER, urs)) &#123;</span><br><span class="line">           seckillResponse.setStatus(DUPLICATED_CODE);</span><br><span class="line">           <span class="keyword">return</span> seckillResponse;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (codeService.isWhiteUser(urs)) &#123;</span><br><span class="line">           codeService.put((PARTICIPATE_WHITE_USER), urs);</span><br><span class="line">           <span class="keyword">return</span> seckill(urs, WHITE_USER, seckillResponse);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (codeService.isBlackUser(urs)) &#123;</span><br><span class="line">           codeService.put((PARTICIPATE_BLACK_USER), urs);</span><br><span class="line">           seckillResponse.setStatus(DUPLICATED_CODE);</span><br><span class="line">           seckillResponse.setStatus(RANK_BLACK_PARTICIPATED);</span><br><span class="line">           <span class="keyword">return</span> seckillResponse;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           codeService.put((PARTICIPATE_NORMAL_USER), urs);</span><br><span class="line">           <span class="keyword">return</span> seckill(urs, NORMAL_USER, seckillResponse);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * seckill</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> SeckillResponse <span class="title">seckill</span><span class="params">(String urs, String userRank, SeckillResponse seckillResponse)</span> </span>&#123;</span><br><span class="line">       String code = codeService.getCode(CODE_LIST + userRank);</span><br><span class="line">       <span class="keyword">if</span> (code != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (codeService.setCodeWinner(WIN_CODE + userRank, urs, code) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               winUserMap.put(urs, userRank);</span><br><span class="line">               seckillResponse.setStatus(GET_CODE);</span><br><span class="line">               seckillResponse.setCode(code);</span><br><span class="line">               <span class="keyword">return</span> seckillResponse;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               codeService.put(CODE_LIST + userRank, code);</span><br><span class="line">               seckillResponse.setStatus(DUPLICATED_CODE);</span><br><span class="line">               <span class="keyword">return</span> seckillResponse;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       seckillResponse.setStatus(FAIL_CODE);</span><br><span class="line">       <span class="keyword">return</span> seckillResponse;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * check current time and start time</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLegalTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String startTimeStr = jedisDao.get(CURRENT_FIELD);</span><br><span class="line">       String durableSecondStr = jedisDao.get(DURABLE_TIME);</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(startTimeStr) || StringUtils.isEmpty(durableSecondStr)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">long</span> startTime = Long.valueOf(startTimeStr);</span><br><span class="line">       <span class="keyword">long</span> durableSecond =  Long.valueOf(durableSecondStr) * SECOND_TRANS;</span><br><span class="line">       <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">return</span> (startTime &lt;= currentTime &amp;&amp; currentTime &lt;= startTime + durableSecond);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看见较Version1，这里的优化包括：</p><ol><li>在内存中维护一个已抢码成功的用户map，减少了部分检查用户是否有码而访问redis的操作</li><li>事先把黑白名单导入到内存，判断用户黑白名单也直接从内存读取</li><li>事先生成激活码存在redis中，用户抢码时直接lpop获取（多用户并发控制），获取成功后用setnx存入（单用户并发控制），存入失败说明是单用户并发抢码，由于redis不支持事物的回滚，所以我们手动进行回滚，把lpop的激活码再用lpush放回队列</li></ol><p>此时的流程图如下：<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/seckill/seckill_flowChat2.png" alt="在这里插入图片描述"><br>其中的getCode操作和setCodeWinner操作如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get code according to userRank</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rank userRank &#123;<span class="doctag">@link</span> SeckillSpecialUser#userRank&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">(String rank)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(rank)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jedisDao.lpop(rank);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * setCodeWinner</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">setCodeWinner</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String field, <span class="keyword">final</span> String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(key) || StringUtils.isEmpty(field) || StringUtils.isEmpty(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jedisDao.hsetnx(key, field, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的QPS如下：<br>线上环境的机器峰值约在3600左右，当时前辈做的对照的QPS 20w抢20w在2600,20w抢2w在3000<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/seckill/seckill_QPS.png" alt="在这里插入图片描述"></p><p>其实这个版本还有可以优化的地方见下文，最后的性能超过了3000的qps</p><h4 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h4><p>这里的timer也改成了JDK的timer，再也不用直接去上下文拿实例了，直接注入依赖即可<br>isEnd 和isBegin是用来控制场次开始结束的两个标记</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        timer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="keyword">new</span> Timer();</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (jedisDao.lock(REDIS_PREFIX, LOCK, EXPIRE) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nextField = getNextField();</span><br><span class="line">                isEnd = Boolean.parseBoolean(jedisDao.get(REDIS_PREFIX + IS_END));</span><br><span class="line">                isBegin = Boolean.parseBoolean(jedisDao.get(REDIS_PREFIX + IS_BEGIN));</span><br><span class="line">                <span class="keyword">if</span> (nextField == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    persistService.persistCodeOwner();</span><br><span class="line">                    LOGGER.info(<span class="string">"All fields has been finished, timer end"</span>);</span><br><span class="line">                    isEnd = <span class="keyword">false</span>;</span><br><span class="line">                    isBegin = <span class="keyword">false</span>;</span><br><span class="line">                    timer.cancel();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isBegin &amp;&amp; isBeginTime()) &#123;</span><br><span class="line">                    redisService.initRedis(nextField);</span><br><span class="line">                    isEnd = <span class="keyword">true</span>;</span><br><span class="line">                    isBegin = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isEnd &amp;&amp; isEndTime()) &#123;</span><br><span class="line">                    persistService.persistToDb(nextField);</span><br><span class="line">                    nextField = getNextField();</span><br><span class="line">                    isEnd = <span class="keyword">false</span>;</span><br><span class="line">                    isBegin = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                redisService.updateFlag(String.valueOf(isBegin), String.valueOf(isEnd));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, DELAY, INTERVAL);<span class="comment">//scan per 10 seconds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意Timer在执行定时任务时只会创建一个线程，所以如果存在多个任务，且任务时间过长，超过了两个任务的间隔时间，会发生一些缺陷</p><br><h5 id="这个版本在第二次代码review时还是被找出了不少问题，梳理如下："><a href="#这个版本在第二次代码review时还是被找出了不少问题，梳理如下：" class="headerlink" title="这个版本在第二次代码review时还是被找出了不少问题，梳理如下："></a>这个版本在第二次代码review时还是被找出了不少问题，梳理如下：</h5><ol><li>redis应该在每场结束后就把抢到激活码的用户写回mysql，不应该最后再写。<blockquote><p>这里的设计把redis当成了持久不应该最后再写。这里的设计把redis当成了持久层，所有的抢到码的用户都先存储在redis中，几天的活动结束后才写回redis不妥当，</p></blockquote></li><li>此处的单用户并发的setnx考虑是否可以换到前面，先setnx用户再抢码， 这样乍一看要两次操作redis，先写一次用户，再抢到码了写激活码，但实际上可以有两种方法去优化：</li></ol><ul><li><p>第二次写回的时候可以在内存攒到一定数量再统一写会redis，我当时问前辈这样写不是牺牲了可靠性吗，万一服务宕机重启，这部分未写入redis的抢码数据不就丢了吗？答：你可以事先从redis拿出一批码，比如100个，那最后写回也是每100个写一次，即使这部分信息丢了，你只需要找到这发出来的100个码将其标示为可用就可以了，其实哪个用户对哪个激活码不是必要的这样乍一看要两次操作redis，先写一次用户，再抢到码了写激活码，但实际上可以有两种方法去优化，1.第二次写回的时候可以在内存攒到一定数量再统一写会redis，我当时问前辈这样写不是牺牲了可靠性吗，万一服务宕机重启，这部分未写入redis的抢码数据不就丢了吗？答：你可以事先从redis拿出一批码，比如100个，那最后写回也是每100个写一次，即使这部分信息丢了，你只需要找到这发出来的100个码将其标示为可用就可以了，其实哪个用户对哪个激活码不是必要的</p><blockquote><p>事先拿100个码到每个实例的内存里，引申出的另一个弊端是由于加了负载均衡，用户可能访问这一台机器的时候告知抢码失败，已经没有码了，但他再抢一次可能又能抢到码（这时候请求被转发到了另一台有码的机器）  ————这一点弊端需要根据实际情况取舍</p></blockquote></li><li><p>将setnx放置最前面检查用户是否重复抢码时就加上，加失败了就说明该用户已参与过抢码，弊端也很明显，这就限制了单场抢码的用户次数，即使抢失败了也不能再抢一次（和需求有出入）</p></li></ul><ol start="3"><li>redis加锁时setnx和expire要一起加，<a href="https://blog.csdn.net/d1562901685/article/details/54881862?utm_source=blogxgwz2" target="_blank" rel="noopener">https://blog.csdn.net/d1562901685/article/details/54881862?utm_source=blogxgwz2</a> ，即这篇文章提到的问题，事实上不需要用setnx+getset，新的jedis中的set方法已支持同时设置和两个参数）<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/seckill/seckill_RedisSet.png" alt="在这里插入图片描述"></li><li>加上即时显示码剩余数量的进度条，额外的需求，显得抢码活动更真实（所以程序猿还是要培养自己的产品意识，做的时候就可以考虑到这些可能要加的但没在交互稿体现出来的需求）</li><li>用户查询激活码时，一定是从持久化层（数据库）给用户的，不能返回不可靠的未被持久化的数据</li><li>题外话，git push时，确认自己的个人信息是否已设置，当时没注意，100+的commit的作者都是unknown，被骂惨</li><li>hashmap线程不安全，用CurrentHashMap</li><li>内存中也会维护一份已抢码用户的信息，从分层的角度来讲这应该也要写在Dao层（MVC里只有Dao是有状态的，Service不应有状态，状态通俗来讲就是数据）</li><li>在数据库记录抢码用户列表时，应记录批次和抢码的时间</li><li>sql拼写时，拼接语句前后的空格别忘了</li><li>因为我额外加了conut的功能，就被Q了这个点，详见大表count的优化<a href="https://blog.csdn.net/vip_hitwu/article/details/77066688" target="_blank" rel="noopener">https://blog.csdn.net/vip_hitwu/article/details/77066688</a> ，一种优化方法是如文中提到的加辅助索引，第二种以空间换时间再维护一张统计信息的数据表，在空闲时进行统计，之后查询直接select操作即可</li><li>数据库中该用unique的不能少</li><li>如果判断条件有&lt;和&gt; ,那就要考虑=应该怎么办</li><li><strong>一定要考虑活动中服务器随时可能宕机重启，这时候不能影响其他正常运行的机器或者数据（比如启动自动清空数据是禁止的）</strong></li><li>定时器要手动去catch 异常，否则出现异常后定时器会自动停止（一般只要catch runtime exception即可）</li><li>如果是项目专用的redis操作，命名不能明很全局的类似redisService，建议前面加业务逻辑，如SeckillRedisService</li><li>所有consts常量的引用要用类名+变量名去操作，不能直接import这个consts，可读性差，反例如<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/seckill/seckill_WrongImport.png" alt="在这里插入图片描述"></li></ol><hr><h4 id="2019-2-1更新"><a href="#2019-2-1更新" class="headerlink" title="2019.2.1更新"></a>2019.2.1更新</h4><p>今天刚看完策略模式，如上的版本可以进一步用策略模式+工厂模式（反射）+枚举优化代替 if..else，更为优雅，此前大量的if…else 的弊端有以下：</p><ol><li>一旦分支多太多，逻辑复杂，会导致代码十分冗长，增加阅读难度</li><li>违背了开闭原则。如果需要增加或减少分支，需要改动if…elseif，增大因代码改动而出错的风险</li><li>具体算法执行策略与判断逻辑耦合</li></ol><p>详情见：<a href="https://blog.csdn.net/u012557814/article/details/81671928" target="_blank" rel="noopener">https://blog.csdn.net/u012557814/article/details/81671928</a><br>等年后把策略模式都学完了再把代码重构一把</p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易 </tag>
            
            <tag> Java </tag>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC + Redis实现激活码秒杀活动（2.采用动态代理的Version1）</title>
      <link href="/2018/12/08/2018-12-08/"/>
      <url>/2018/12/08/2018-12-08/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-MVC-Redis实现激活码秒杀活动（2-采用动态代理的Version1）"><a href="#Spring-MVC-Redis实现激活码秒杀活动（2-采用动态代理的Version1）" class="headerlink" title="Spring MVC + Redis实现激活码秒杀活动（2.采用动态代理的Version1）"></a>Spring MVC + Redis实现激活码秒杀活动（2.采用动态代理的Version1）</h1><h4 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h4><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/seckill/seckill_flowChat.png" alt="在这里插入图片描述"></p><p>第一个版本的QPS非常低，大概只有几百，原因是加锁的粒度太大 ，对整个抢码逻辑进行了加锁，其次动态代理增加了复杂度，会消耗一部分性能（虽然内存级的影响很小）<br>此处动态代理实现参照了：<a href="https://blog.csdn.net/u010359884/article/details/50310387?utm_source=blogxgwz0" target="_blank" rel="noopener">https://blog.csdn.net/u010359884/article/details/50310387?utm_source=blogxgwz0</a> ,在此不过多赘述</p><h2 id="核心代码-第一个版本很多不规范的写法，大家看看思想就好"><a href="#核心代码-第一个版本很多不规范的写法，大家看看思想就好" class="headerlink" title="核心代码(第一个版本很多不规范的写法，大家看看思想就好)"></a>核心代码(第一个版本很多不规范的写法，大家看看思想就好)</h2><h5 id="抢码逻辑"><a href="#抢码逻辑" class="headerlink" title="抢码逻辑"></a>抢码逻辑</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKillImpl</span> <span class="keyword">implements</span> <span class="title">SeckillInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(getClass().getName());</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CommonRedisDao commonRedisDao;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SecondKillService secondKillService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> GenerateCode generateCode;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">secKill</span><span class="params">(String username, String lockItem, <span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftCodeWhite = Integer.parseInt(commonRedisDao.get(<span class="string">"leftCodeWhite"</span>).toString());</span><br><span class="line">        <span class="keyword">int</span> leftCodeNormal = Integer.parseInt(commonRedisDao.get(<span class="string">"leftCodeNormal"</span>).toString());</span><br><span class="line">        <span class="keyword">int</span> outCode = Integer.parseInt(commonRedisDao.get(<span class="string">"outCode"</span>).toString());</span><br><span class="line">        <span class="keyword">if</span> (secondKillService.checkCode(username) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank == <span class="number">1</span> &amp;&amp; leftCodeWhite &gt; <span class="number">0</span>) &#123; <span class="comment">//白名单用户秒杀</span></span><br><span class="line">                secondKillService.addSuccess(rank);</span><br><span class="line">                <span class="comment">//根据rank生成不同类型的激活码</span></span><br><span class="line">                String code = generateCode.generateCode(<span class="number">20</span>);</span><br><span class="line">                <span class="keyword">if</span> (code == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    logger.info(<span class="string">"本场激活码已抢完，剩余激活码数： "</span> + leftCodeWhite);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                commonRedisDao.put(username, code);</span><br><span class="line">                <span class="comment">//long status = secondKillService.addAwardedObj(username, code, rank);</span></span><br><span class="line">                <span class="comment">//logger.info("是否已插入数据库id：" + status);</span></span><br><span class="line">                leftCodeWhite -= <span class="number">1</span>;</span><br><span class="line">                outCode += <span class="number">1</span>;</span><br><span class="line">                commonRedisDao.put(<span class="string">"leftCodeWhite"</span>, leftCodeWhite);</span><br><span class="line">                commonRedisDao.put(<span class="string">"outCode"</span>, outCode);</span><br><span class="line">                logger.info(<span class="string">"用户"</span> + username + <span class="string">"抢码成功，激活码为:"</span> + code + <span class="string">" 本场白名单剩余激活码数： "</span> + leftCodeWhite);</span><br><span class="line">                <span class="keyword">return</span> code;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">0</span> &amp;&amp; leftCodeNormal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                secondKillService.addSuccess(rank);</span><br><span class="line">                <span class="comment">//根据rank生成不同类型的激活码</span></span><br><span class="line">                String code = generateCode.generateCode(<span class="number">20</span>);</span><br><span class="line">                <span class="keyword">if</span> (code == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    logger.info(<span class="string">"本场激活码已抢完，剩余激活码数： "</span> + leftCodeNormal);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                commonRedisDao.put(username, code);</span><br><span class="line">                <span class="comment">//long status = secondKillService.addAwardedObj(username, code, rank);</span></span><br><span class="line">                <span class="comment">//logger.info("是否已插入数据库id：" + status);</span></span><br><span class="line">                leftCodeNormal -= <span class="number">1</span>;</span><br><span class="line">                outCode += <span class="number">1</span>;</span><br><span class="line">                commonRedisDao.put(<span class="string">"leftCodeNormal"</span>, leftCodeNormal);</span><br><span class="line">                commonRedisDao.put(<span class="string">"outCode"</span>, outCode);</span><br><span class="line">                logger.info(<span class="string">"用户"</span> + username + <span class="string">"抢码成功，激活码为:"</span> + code + <span class="string">" 本场普通名单码库剩余激活码数： "</span> + leftCodeNormal);</span><br><span class="line">                <span class="keyword">return</span> code;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.info(<span class="string">"本场激活码已抢完，剩余激活码数：0"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Empty"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">"用户"</span> + username + <span class="string">"已有激活码"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Repeat"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实抢码的逻辑很简单，请求进来后的处理逻辑就如流程图所画的，因为用了代理加锁的方式此处其实已经是串行处理了，代理的好处是可以统一在莫一类的执行前进行加锁操作，逻辑上解耦。</p><p>加锁代码（真见鬼了controller侵入了大量service代码）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/secondKill"</span>, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">secondKill</span><span class="params">(@RequestParam(<span class="string">"urs"</span>)</span> String username) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!secondKillService.checkTime()) &#123;</span><br><span class="line">           <span class="keyword">return</span> BusinessResp.builder(<span class="number">39</span>).setMsg(<span class="string">"不在秒杀时间内"</span>).build();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (secondKillService.checkIdentity(username) &lt; <span class="number">0</span>) &#123; <span class="comment">//黑名单用户</span></span><br><span class="line">               secondKillService.addParticipate(-<span class="number">1</span>);</span><br><span class="line">               logger.error(<span class="string">"黑名单用户不能秒杀激活码： "</span> + username);</span><br><span class="line">               <span class="keyword">return</span> BusinessResp.builder(<span class="number">41</span>).setMsg(<span class="string">"黑名单用户不能秒杀激活码"</span>).build();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.info(<span class="string">"白名单用户:  "</span> + username);</span><br><span class="line">               rank = <span class="number">1</span>;</span><br><span class="line">               secondKillService.addParticipate(<span class="number">1</span>); <span class="comment">//白名单用户进行秒杀操作</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (EmptyResultDataAccessException e1) &#123;</span><br><span class="line">           logger.info(<span class="string">"普通用户： "</span> + username);</span><br><span class="line">           secondKillService.addParticipate(<span class="number">0</span>); <span class="comment">//普通用户进行秒杀操作</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//实现动态代理</span></span><br><span class="line">           InvocationHandler handler = <span class="keyword">new</span> CacheLockInterceptor(secKillImpl);</span><br><span class="line">           SeckillInterface proxy = (SeckillInterface) Proxy.newProxyInstance(handler.getClass().getClassLoader(),</span><br><span class="line">                   secKillImpl.getClass().getInterfaces(), handler);</span><br><span class="line">           String code = proxy.secKill(username, <span class="string">"leftCode"</span>, rank);</span><br><span class="line">           <span class="keyword">if</span> (code.equals(<span class="string">"Empty"</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span> BusinessResp.builder(<span class="number">38</span>).setMsg(<span class="string">"本场激活码已发完"</span>).build();</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code.equals(<span class="string">"Repeat"</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span> BusinessResp.builder(<span class="number">40</span>).setMsg(<span class="string">"用户已有激活码"</span>).build();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> BusinessResp.builder(<span class="number">21</span>).setMsg(<span class="string">"秒杀成功"</span>).setPayload(code).build();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (CacheLockException m) &#123;</span><br><span class="line">           logger.error(username + <span class="string">"秒杀失败请重试"</span>);</span><br><span class="line">           <span class="keyword">return</span> BusinessResp.builder(<span class="number">42</span>).setMsg(<span class="string">"秒杀失败请重试"</span>).build();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>加锁（完整的流程见链接：<a href="https://blog.csdn.net/u010359884/article/details/50310387?utm_source=blogxgwz0）" target="_blank" rel="noopener">https://blog.csdn.net/u010359884/article/details/50310387?utm_source=blogxgwz0）</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="comment">//获取代理对象注解的方法method和参数args</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    CacheLock cacheLock = method.getAnnotation(CacheLock.class);</span><br><span class="line">    <span class="comment">//没有cacheLock注解即不加锁，pass</span></span><br><span class="line">    <span class="keyword">if</span> (cacheLock == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"No cacheLock annotation"</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得方法中参数的注解</span></span><br><span class="line">    Annotation[][] annotations = method.getParameterAnnotations();</span><br><span class="line">    <span class="comment">//根据参数注解获得加锁的参数</span></span><br><span class="line">    Object lockedObject = getLockedObject(annotations, args);</span><br><span class="line">    String objectValue = lockedObject.toString();</span><br><span class="line">    <span class="comment">//对加锁的参数上锁</span></span><br><span class="line">    RedisLock lock = <span class="keyword">new</span> RedisLock(cacheLock.lockedPrefix(), objectValue);</span><br><span class="line">    <span class="keyword">boolean</span> result = lock.lock(cacheLock.timeOut(), cacheLock.expireTime());</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123; <span class="comment">//取锁失败</span></span><br><span class="line">        ERROR_COUNT += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheLockException(<span class="string">"get lock fail,秒杀失败请重试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println("Intecepor 释放锁");</span></span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里用代理加锁也可以，只不过加锁的粒度可以更小，只需要锁目前已发放码的数量就可以了，不用把整个流程都锁上。可以用双重检查机制实现只锁发放码数量</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>因为本次的抢码活动需要定时执行，要求在活动开始后不得重启服务器，所以我们需要在后台写一个定时器，去完成相关的初始化和持久化操作。<br>此处的实现用了原生的selvet，随着tomcat启动而启动，在spring初始化之前定时器就启动了所以直接注入会报NPE，只能直接从上下文里去拿要的变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerService</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(getClass().getName());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Timer timer  =  <span class="keyword">new</span> Timer(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> InitRedis initRedis;</span><br><span class="line">    <span class="keyword">private</span> SecondKillConfigDao secondKillConfigDao;</span><br><span class="line">    <span class="keyword">private</span> UpToMysql upToMysql;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent  event)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//在listener中注入不可以用注解模式,要采用以下方式</span></span><br><span class="line">        <span class="keyword">final</span> WebApplicationContext webApplicationContext =</span><br><span class="line">                WebApplicationContextUtils.getWebApplicationContext(event.getServletContext());</span><br><span class="line">        initRedis = webApplicationContext.getBean(InitRedis.class);</span><br><span class="line">        secondKillConfigDao = webApplicationContext.getBean(SecondKillConfigDao.class);</span><br><span class="line">        upToMysql = webApplicationContext.getBean(UpToMysql.class);</span><br><span class="line">        event.getServletContext().log(<span class="string">"定时器已启动"</span>);</span><br><span class="line">        <span class="comment">//得到执行任务的起始场次</span></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Object&gt; configList = secondKillConfigDao.getConfigList().get(<span class="number">0</span>);</span><br><span class="line">        String beginDate = configList.get(<span class="string">"beginDate"</span>).toString();</span><br><span class="line">        <span class="keyword">int</span> durableTime = Integer.parseInt(configList.get(<span class="string">"durableSecond"</span>).toString()); <span class="comment">//这里的date在数据库里还是以String去存储的，所以拿出来要进行转化，规范要用Long</span></span><br><span class="line">        <span class="keyword">final</span> String endDate = configList.get(<span class="string">"endDate"</span>).toString();</span><br><span class="line">        String []timeBegin = beginDate.split(<span class="string">" "</span>);</span><br><span class="line">        String []timeHms = timeBegin[<span class="number">1</span>].split(<span class="string">":"</span>);</span><br><span class="line">        <span class="comment">//得到执行任务的起始时间</span></span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, Integer.parseInt(timeHms[<span class="number">0</span>]));</span><br><span class="line">        calendar.set(Calendar.MINUTE, Integer.parseInt(timeHms[<span class="number">1</span>]));</span><br><span class="line">        calendar.set(Calendar.SECOND, Integer.parseInt(timeHms[<span class="number">2</span>]) + durableTime + <span class="number">30</span>);</span><br><span class="line">        Date date = calendar.getTime();</span><br><span class="line">        <span class="comment">//如果第一次执行定时任务的时间小于当前的时间就加一天</span></span><br><span class="line">        <span class="keyword">if</span> (date.before(<span class="keyword">new</span> Date())) &#123;</span><br><span class="line">            date = <span class="keyword">this</span>.addDay(date, <span class="number">1</span>);</span><br><span class="line">            event.getServletContext().log(<span class="string">"第一场场次时间已过，从第二天开始，新的时间为："</span> + date);</span><br><span class="line">        &#125;</span><br><span class="line">        initRedis.initRedisAtFirstStart();<span class="comment">//在最开始先按数据库配置初始化一次redis，之后每次在秒杀活动结束2分钟之后运行</span></span><br><span class="line">        event.getServletContext().log(<span class="string">"第一场场次时间为："</span> + date + <span class="string">"，redis初始化已完成"</span>);</span><br><span class="line">        TimedTask timedTask = <span class="keyword">new</span> TimedTask(event.getServletContext(), event);</span><br><span class="line">        timer.schedule(timedTask, date,<span class="number">12</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);<span class="comment">//指定第一次统计时间为第一场活动结束30秒后，之后每隔12小时统计一次</span></span><br><span class="line">        event.getServletContext().log(<span class="string">"已经添加任务调度表"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span>  </span>&#123;</span><br><span class="line">        timer.cancel();</span><br><span class="line">        event.getServletContext().log(<span class="string">"定时器销毁"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="不足之处："><a href="#不足之处：" class="headerlink" title="不足之处："></a>不足之处：</h3><h5 id="需求部分"><a href="#需求部分" class="headerlink" title="需求部分"></a>需求部分</h5><ul><li><p>此处config中只有一列数据，不能实现调节每场的配置，同时一列数据再去计算下一场会显得比较复杂，解决办法：直接换成多条配置即可，每场一条记录更灵活</p></li><li><p>timer采用非常早期的写法，在Spring开始前完成，不推荐使用</p></li><li><p>最致命的问题：锁的粒度太大，qps低</p></li><li><p>统计出现争议，最后统一了应该按urs账号统计，重复抢码的不再计数</p></li><li><p>定时器未考虑分布式部署</p><h5 id="代码规范部分"><a href="#代码规范部分" class="headerlink" title="代码规范部分"></a>代码规范部分</h5></li><li><p>考虑访问的速度（按速度排列）</p></li></ul><ol><li>本机的内存</li><li>redis（网络io）</li><li>Mysql （网络io + 硬盘io）</li></ol><ul><li>inputUserList.whiteUserList.contains(OBJ)，调用的是OBJ中的equals方法，不是whiteUserList中Object的equals方法</li><li>不同实例的同一个包内的变量是彼此独立的（即若后台实例初始化一变量，前台实例直接去读取该变量还是原来未初始化的结果）</li><li>static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！<br>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。<br>对于方法，表示不可覆盖，并且可以通过类名直接访问。声明为static的方法有以下几条限制： 1.它们仅能调用其他的static 方法。 2.它们只能访问static数据。 3.它们不能以任何方式引用this 或super</li><li>Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法–&gt;@Autowired(注入)–&gt;@PostConstruct<br>（ Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct）</li><li>使用Redis记得加前缀，不一定只有一个人用，同时使用flushDB/flushAll的时候要考虑会不会把其他人的数据删了</li><li>redis分布式锁1.setnx+expire防死锁（升级版：setnx+getset）；2.lpop原子操作</li><li>@RestController = @Controller + @ResponseBody</li><li>全局变量是每个方法共同持有的，因此很容易产生线程问题，在多线程环境中建议多使用局部变量，局部变量每个线程都有自己的一份，不会产生线程问题</li><li>抢码的准确性：先写到数据库再返回给用户</li><li>new 自己去实例化一个对象后，其中所有spring注入的标签都会失效（两者不能同时使用），错误示例：</li></ul><br>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易 </tag>
            
            <tag> Java </tag>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC + Redis实现激活码秒杀活动（1.设计部分）</title>
      <link href="/2018/12/07/2018-12-07/"/>
      <url>/2018/12/07/2018-12-07/</url>
      
        <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />    <label for="pass">Please enter the password to read the blog.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易 </tag>
            
            <tag> Java </tag>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于保研——写在最前面</title>
      <link href="/2018/11/29/2018-11-29/"/>
      <url>/2018/11/29/2018-11-29/</url>
      
        <content type="html"><![CDATA[<p>最近常有小朋友来询问我保研种种，遂以此文记录相关心得体会，希望能给他们一些帮助。</p><p>摸黑过河还是挺难的，至今任清晰地记得当我还在大一，刚知道保研推免这个概念时，我的学长们告诉我很难很难。但现在我可以很负责地对我的学弟学妹们说，<strong>其实并没有那么难</strong>。</p><h1 id="一、为什么保研"><a href="#一、为什么保研" class="headerlink" title="一、为什么保研"></a>一、为什么保研</h1><p>这是所有想保研的同学最该思考清楚的问题，保研的目的究竟是什么，于我而言，原因如下（按优先级排列）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 不同选择（就业/出国/保研）的性价比衡量</span><br><span class="line">2. 更多的时间</span><br><span class="line">3. 试错机会</span><br><span class="line">4. 专业技能的深度拓展</span><br><span class="line">5. 名校硕士学历</span><br></pre></td></tr></table></figure><p>具体而言，第一点我觉得最重要，每个人的情况不同，那么最适合他的选择就会不同，我是一个纯结果导向的人，直到今年上半年4月份，仔细权衡这三者后，才决定走保研这条路，大家一定一定要想清楚，花两到三年的时间成本读研值不值得。</p><blockquote><p>其实最后最让我无法反驳的一点是，有个学长和我说：“之后你会花几十年的时间工作，为什么不多花两到三年去更高的学府看看呢？”   ———— 读研也算种别样的人生经历</p></blockquote><p>关于第二点，在本科阶段总是被迫把时间花到许多琐事上，专业技能也都是广度学习，大二的时候忙于社团和学生会一直没有注意到（针对技术岗的同学，大一大二打ACM性价比<strong>远</strong>高于学生会），到了大三想掉头，已经太晚了。</p><p>至于第三点，我不是一进大学就立志成为码农，我从大一开始实习，深知实习的重要性，一路下来，去过券商营业部，在创业公司写过爬虫、做过前端，在四大做过IT咨询，在一次次的实习后我发觉自己对非技术岗的工作越来越不感冒，这就是不断试错的过程，也让我下定决心从事技术岗。</p><blockquote><p>方向比努力更重要。</p></blockquote><h1 id="二、大致时间点"><a href="#二、大致时间点" class="headerlink" title="二、大致时间点"></a>二、大致时间点</h1><p>整个保研一般从4-6月份开始申请夏令营，大部分学校的夏令营时间集中在7月份，会有时间冲突需要自己选择。8月末9月初开始申请正式的推免流程，也就是俗称的“九推”，大部分学校九推时间集中在九月中旬,最后填报志愿是在9.28左右，所有学校几乎都会在这之前给出拟录取的结，下图是我当时申请夏利营自己做的时间轴</p><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E4%BF%9D%E7%A0%947%E6%9C%88%E6%97%A5%E7%A8%8B.png" alt></p><h1 id="三、如何保研外校"><a href="#三、如何保研外校" class="headerlink" title="三、如何保研外校"></a>三、如何保研外校</h1><p>明确了第一个问题之后，就该思考要怎么样才能保研了（以下内容的目标人群为计算机相关专业同学）。</p><p>每个学院的保研政策都不尽相同，大家第一步肯定是取得自己学院的保研名额，这是必要条件一，再次不多赘述，这里着重关注如何推免到更好的学校。</p><p>针对<strong>计算机相关专业</strong>，在我看来老师们关注点如下（按优先级排列）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 排名尽可能高（必要条件二）</span><br><span class="line">2. 论文、专利</span><br><span class="line">3. 竞赛情况（ACM等）</span><br><span class="line">4. 项目情况</span><br><span class="line">5. 英语水平</span><br></pre></td></tr></table></figure><p>每所学校考察的方面无非是这几样，其中第一点是通过初审的必要条件，让我们换位思考一下，你作为其他高校的老师，面对上千份的初审材料，但你只要放200人甚至更少时，会怎么选择，毫无疑问排名不达标直接pass（具体绩点意义不大，名次和百分比特别重要），第一点不成立，在程序里就直接return了，后面的加分项都无从施展。</p><blockquote><p>以本校计算机学院情况来看，清北的标准前2名，交大无从考证（难度介于清北和复旦之间），复旦前10左右。（夏令营的入营对排名要求会更苛刻）</p></blockquote><p>等过了初审之后，绩点、排名影响就很少了，剩下的主要看你面试、机试发挥如何</p><p>关于论文，anyway 不论发表还是未发表，发表的期刊的级别怎么样，有了就是加分项（前提是这篇论文必须是你精心完成的，细节原理等等，面试必问）</p><p>关于竞赛，ACM &gt; 数学建模 &gt; 软件开发类赛事 &gt; 创赛</p><p>关于项目，项目成果最好有所体现，比如相关的软件著作权、专利等等</p><p>英语水平：CET6 500以上</p><p><strong>补充一点</strong>：大部分学校的流程分为都会有自己的机试，机试很重要! 很重要! 很重要！一来它是给面试老师的第一印象，二来直接体现出了你的代码能力</p><blockquote><p>机试定江山，毫不夸张</p></blockquote><p><em>我的推免经历（清北复交浙）见【<a href="https://zc-apiao.world/blog/2018/12/24/2018-%E6%B8%85%E5%8C%97%E5%A4%8D%E4%BA%A4%E6%B5%99-%E8%AE%A1%E7%AE%97%E6%9C%BA_%E8%BD%AF%E4%BB%B6-%E6%8E%A8%E5%85%8D%E7%BB%8F%E5%8E%86/" target="_blank" rel="noopener">2018 清北复交浙 计算机/软件 推免经历</a>】</em></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 实现抽奖活动（3.优化—乐观锁实现Version2）</title>
      <link href="/2018/11/01/2018-11-01/"/>
      <url>/2018/11/01/2018-11-01/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC-实现抽奖活动（3-优化—乐观锁实现Version2）"><a href="#SpringMVC-实现抽奖活动（3-优化—乐观锁实现Version2）" class="headerlink" title="SpringMVC 实现抽奖活动（3.优化—乐观锁实现Version2）"></a>SpringMVC 实现抽奖活动（3.优化—乐观锁实现Version2）</h1><h4 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h4><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/lottery.png" alt="代码流程图"><br>针对第一次代码review提出的缺陷与不足，重构了抽奖部分的代码并进行了优化，改用性能更高的乐观锁取代for update。(现在回头来看代码的语义真的好了很多)<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/lottery_flowChat.png" alt="在这里插入图片描述"></p><h4 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doLottery</span><span class="params">(String urs, <span class="keyword">long</span> gbId)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(urs)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"urs can not be null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">boolean</span> isProperTime = checkTime();</span><br><span class="line">       <span class="keyword">if</span> (!isProperTime) &#123;</span><br><span class="line">           <span class="keyword">return</span> TIME_ILLEGAL;</span><br><span class="line">       &#125;</span><br><span class="line">       LotteryRecord lotteryRecord = lotteryRecordDao.getUserRecord(urs, gbId);</span><br><span class="line">       <span class="keyword">if</span> (lotteryRecord == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> NO_QUALIFY;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (lotteryRecord.getLotteryResult() != NOT_PARTICIPATED) &#123;</span><br><span class="line">           <span class="keyword">return</span> ALREADY_LOTTERY;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">boolean</span> hasWon = judgeLottery();</span><br><span class="line">       <span class="keyword">if</span> (hasWon) &#123;</span><br><span class="line">           <span class="keyword">if</span> (lotteryConfigDao.increaseAcquiredAward() &gt; <span class="number">0</span>) &#123; <span class="comment">//乐观锁实现，控制多用户并发，奖品数量不会过度发放</span></span><br><span class="line">               <span class="keyword">if</span> (lotteryRecordDao.updateAwarded(urs, gbId, GET_AWARD) == <span class="number">0</span>) &#123; <span class="comment">//控制单用户并发抢码行为</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> SUCCESS_LOTTERY;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       lotteryRecordDao.updateAwarded(urs, gbId, NO_AWARD);</span><br><span class="line">       <span class="keyword">return</span> FAIL_LOTTERY;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 确认是否中奖</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judgeLottery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> awardRange = lotteryConfigDao.getConfig().getProbability();</span><br><span class="line">       <span class="keyword">return</span> RandomUtils.nextDouble() &lt;= awardRange;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * check current time</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (lotteryConfigDao.getConfig() == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">long</span> startTime = lotteryConfigDao.getConfig().getAwardTime();</span><br><span class="line">       <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">return</span> startTime &lt;= currentTime;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h4><p>increaseAcquiredAward() ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increaseAcquiredAward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">"update "</span> + getQuotedTableName()</span><br><span class="line">            + <span class="string">" set acquiredAward = acquiredAward + 1 where acquiredAward &lt; totalAward"</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>)updateBySql(sql); <span class="comment">//返回更新影响到的数据库记录数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过“where acquiredAward &lt; totalAward”实现乐观锁，其本质和加一个version字段类似（即先读取一次取出version，再用where version = 取出的version进行更新），类似于CAS操作（虽然底层的实现方式不一样，但乐观锁的思想都是相同的）</p><p>   updateAwarded(urs, gbId, NO_AWARD)：<br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * updateAwarded</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> status GET_AWARD表示中奖，NO_AWARD表示未中奖 &#123;<span class="doctag">@link</span> LotteryRecord#lotteryResult&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateAwarded</span><span class="params">(String urs, <span class="keyword">long</span> gbId, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(urs)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status != GET_AWARD &amp;&amp; status != NO_AWARD) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"status should be GET_AWARD/NO_AWARD"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String sql = <span class="string">"update "</span> + getQuotedTableName()</span><br><span class="line">            + <span class="string">" set lotteryResult = ?, lotteryTime = ? where lotteryResult = 0 and urs = ? and gbId = ?"</span>;</span><br><span class="line">    <span class="keyword">return</span> updateBySql(sql, status, <span class="keyword">new</span> Date().getTime(), urs, gbId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   也是用乐观锁实现，防止单用户并发抢码，若果更新记录条数为0（说明更新失败，单用户并发抢码情况出现），则抛出RuntimeException进行回滚</p><h4 id="优化后的meta类："><a href="#优化后的meta类：" class="headerlink" title="优化后的meta类："></a>优化后的meta类：</h4><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/lottery_ConfigMeta.png" alt="在这里插入图片描述"></p><h4 id="最后附上Controller代码："><a href="#最后附上Controller代码：" class="headerlink" title="最后附上Controller代码："></a>最后附上Controller代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lottery</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/lottery"</span>, produces = MediaType.APPLICATION_JSON_UTF8_VALUE, method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BusinessResp <span class="title">lottery</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                           @RequestParam(<span class="string">"gbId"</span>)</span> <span class="keyword">long</span> gbId) </span>&#123;</span><br><span class="line">    String username = UrsLoginInterceptor.getCurrentUserName(request);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(username)) &#123;</span><br><span class="line">        <span class="keyword">return</span> BusinessResp.builder(BusinessCode.NOT_LOGIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        status = lotteryService.doLottery(username, gbId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> BusinessResp.builder(ALREADY_LOTTERY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == SUCCESS_LOTTERY) &#123;</span><br><span class="line">        <span class="keyword">return</span> BusinessResp.success();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BusinessResp.builder(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有最简单的参数校验，其余逻辑均放在service</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>第一次做很规范化的工程项目，还是很感谢我的导师涛哥以及部门的大佬们，在评审的时候王老师迟哥麦斯都给了非常多的建议，受益匪浅，其实后来补了阿里的《码出高校 阿里巴巴Java开发手册》很多评审里指出的点都在里面有所提及，强烈推荐，一定要看。做完这个项目对SpringMVC的分层有了更具体的认识，同时也深入理解了乐观锁和悲观锁的一些实现。<br>其实目前写的还有很大优化的空间，比如可以引入redis做缓存加快qps，但考虑到抽奖场景对性能的要求没那么高，所以这边没有加入redis</p><h4 id="另一种版本：基于version的乐观锁"><a href="#另一种版本：基于version的乐观锁" class="headerlink" title="另一种版本：基于version的乐观锁"></a>另一种版本：基于version的乐观锁</h4><p>另一种写法的乐观锁（其中的userCount相当于version），此处while里加了dao操作，不建议使用，非常耗性能，这个写法原意是，多用户并发场景下，如果一个用户成功中奖了，但没能成功将此结果写入数据库（其他实例已更改过数据库导致userCount失效），那么这时候就用while直到其成功写入数据库。<br>这个时候前辈的建议是更新失败直接回滚，当它抽奖失败处理（(⊙o⊙)…），但用之前的乐观锁就不用担心这类情况的发生<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/lottery_optimistic.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易 </tag>
            
            <tag> Java </tag>
            
            <tag> 抽奖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 实现抽奖活动（2.Version1 —基于for update悲观锁）</title>
      <link href="/2018/10/28/2018-10-28/"/>
      <url>/2018/10/28/2018-10-28/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC-实现抽奖活动（2-Version1-—基于for-update悲观锁）"><a href="#SpringMVC-实现抽奖活动（2-Version1-—基于for-update悲观锁）" class="headerlink" title="SpringMVC 实现抽奖活动（2.Version1 —基于for update悲观锁）"></a>SpringMVC 实现抽奖活动（2.Version1 —基于for update悲观锁）</h1><h4 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h4><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/lottery.png" alt="代码流程图"></p><p>第一个版本实现的抽奖是保证所有奖品一定能发完的情况（在该场景下只有一个），故每次抽奖的概率不同，会根据剩余用户数与奖品数动态调整（现在整理的时候再看代码的原意真的是惨不忍睹，比如一个map对象命名的后缀是List？？）</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * doLottery</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doLottery</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//获取总的奖品池值</span></span><br><span class="line">       Map&lt;String, Object&gt; configList = configDao.getConfigList().get(<span class="number">0</span>);</span><br><span class="line">       logger.info(<span class="string">"configList: "</span> + configList);</span><br><span class="line">       <span class="comment">/** ----------- 解释1见下文 ----------- **/</span></span><br><span class="line">       <span class="keyword">int</span> totalAward = Integer.parseInt(configList.get(<span class="string">"totalAward"</span>).toString());</span><br><span class="line">       <span class="keyword">int</span> acquiredAward = Integer.parseInt(configList.get(<span class="string">"acquiredAward"</span>).toString());</span><br><span class="line">       <span class="keyword">if</span> (totalAward - acquiredAward &gt; <span class="number">0</span>) &#123; <span class="comment">//奖品有剩余</span></span><br><span class="line">           <span class="comment">//获取中奖范围</span></span><br><span class="line">           <span class="keyword">int</span> awardUpperLimit = Integer.parseInt(configList.get(<span class="string">"awardUpperLimit"</span>).toString());</span><br><span class="line">           <span class="keyword">int</span> totalUpperLimit = Integer.parseInt(configList.get(<span class="string">"totalUpperLimit"</span>).toString());</span><br><span class="line">           <span class="comment">//获取随机数</span></span><br><span class="line">           Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">           <span class="keyword">int</span> random = rand.nextInt(totalUpperLimit); <span class="comment">//用户抽奖，在[0,totalUpperLimit)生成int随机数</span></span><br><span class="line">           <span class="keyword">if</span> (random &lt;= awardUpperLimit &amp;&amp; random &gt;= <span class="number">0</span>) &#123;<span class="comment">//若该数在中奖范围内则说明中奖</span></span><br><span class="line">               res = <span class="number">1</span>; <span class="comment">//中奖</span></span><br><span class="line">               lotteryService.updateAward(acquiredAward + <span class="number">1</span>, awardUpperLimit - <span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               res = -<span class="number">1</span>; <span class="comment">//未中奖</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/** ----------- 解释2 ----------- **/</span></span><br><span class="line">           configDao.updateProbability(<span class="string">"totalUpperLimit"</span>, totalUpperLimit - <span class="number">1</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">//奖品无剩余</span></span><br><span class="line">           res = -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       qualifyService.updateStatus(username, res);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>解释1.<br>在获取配置信息时会有for update加锁（悲观锁，根据主键查询会在主键字段加行锁），在某一时刻只有一个线程可以成功拿到到config信息，保证了之后步骤并发的正确性，即经过此步骤之后所有的并发请求会成串行执行<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/for%20update.png" alt="在这里插入图片描述"></p><p>拿出所有的config配置信息，其meta类如下：<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/config%20meta.png" alt="config"></p><p>解释2.<br>用户中奖则在数据库中将已获奖品数+ 1,同时将中奖范围-1；若用户未中奖，则将抽奖的上限-1，进而达到动态调整概率的目的，保证最后一个抽奖的用户抽中概率是1（初始的抽奖上限 = 所提供的可抽奖人数）</p><h3 id="不足之处："><a href="#不足之处：" class="headerlink" title="不足之处："></a>不足之处：</h3><h5 id="需求部分"><a href="#需求部分" class="headerlink" title="需求部分"></a>需求部分</h5><ul><li>此处config中只有一列数据，for update在大部分情况下是行锁，但这里因为数据只有一条就相当于表锁，性能较低，关于for update的相关内容，见<a href="https://blog.csdn.net/claram/article/details/54023216" target="_blank" rel="noopener">https://blog.csdn.net/claram/article/details/54023216</a></li><li>确认需求后，应改为抽奖概率固定，即使最后可能没人中奖（很小的概率）</li></ul><h5 id="代码规范部分"><a href="#代码规范部分" class="headerlink" title="代码规范部分"></a>代码规范部分</h5><ul><li>格式化日期不使用SimpleDateFormat（线程不安全），用相关的工具类完成（joda等）</li><li>日期转化成Long型时间戳进行存储，比较也要采用时间戳的方式，直接存的话会有日期不唯一的风险,同时存储日期字符串效率低</li><li>注意sql语句不能自己拼，有SQL注入的安全风险，要用封装好的方法</li><li>代码中别直接用数字/写死的String，不能出现magic number，（要用的时候通过public static final去定义相关的变量）</li><li>名称大写的规范：基本数据类型 + public</li><li>注意每一个controller的方法（GET/POST/DELETE），区别：get方式一般用于多次访问结果一致的场景，post则用于每次访问返回结果都不尽相同的场景</li><li>Controller的访问url用名词，Controller层不要有逻辑层面的判断（除去基本的检测登陆），一般来说controller中只调用一个service层的方法，达到解耦</li><li>Dao层只负责返回数据，不去做逻辑处理，对数据的一些筛选/处理可以在Dao完成</li><li>除基本数据类型以外的都要判空，注意保护条件(String与meta类)</li><li>使用 SLF4J 代替 Log4J 来做 Java 日志</li><li>while循环体里边不嵌套dao操作，太耗时</li><li>随机数相关用工具类，RandomStringUtils</li><li>一大串的判断条件提出一个boolean值，更清晰</li><li>用户完成某一操作后，记录数据时最好加上当前的时间戳</li><li>sql语句多次相同的话写成一句（多次查询同一张表的不同字段优化成一次全查出来，尽可能减少与数据库的交互）</li><li>涉及字符串拼接，String和StringBuffer主要有2个区别：<br>（1）String类对象为不可变对象，一旦你修改了String对象的值，隐性重新创建了一个新的对象，释放原String对象，StringBuffer类对象为可修改对象，可以通过append()方法来修改值<br>（2）String类对象的性能远不如StringBuffer类<br>（3）StringBuffer线程安全，StringBulider不安全，但速度比StringBuffer快。<ul><li>@Transaction事物回滚必须在调用的地方捕获RuntimeException</li><li>在字符串拼接时要小心中间字符串为null的话，直接就报空指针</li><li>object调用toString方法注意若object为null会报NPE</li><li>Service层要做好相关的参数合法性验证，一般Dao不再重复做</li></ul></li></ul><br><h3 id="2019-3-16更新"><a href="#2019-3-16更新" class="headerlink" title="2019.3.16更新"></a>2019.3.16更新</h3><p>昨天阿里一面在说悲观锁版本的时候，对Spring的事务机制有所遗忘，当时想for update 这个语句执行完锁不是释放了吗，怎么保证并发？然后想到所以要把它包在一个事务里边，即通过<code>@Transaction</code>注解。</p><p>当时不确定在一个标签内是否就会等跑完这一段事务才释放锁，现贴一个前人做的实验<a href="https://blog.csdn.net/qiuhan/article/details/51179808" target="_blank" rel="noopener">数据库中for update的使用</a>，证实@Transaction作用和数据库中的开始事务类似，而在代码结束之后会自动提交，因此如果在代码中加了for update的锁，这个锁会持续整个事务的生命周期。</p><blockquote><p>这也是为什么不推荐使用for update的原因，1.若在里面对多个资源加了锁，容易导致死锁；2.性能低，其实质是对索引加的锁，因此其他的地方如果想要通过这个索引获得别的行的数据也是会被阻塞的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易 </tag>
            
            <tag> Java </tag>
            
            <tag> 抽奖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 实现抽奖活动（1.设计部分）</title>
      <link href="/2018/10/25/2018-10-25/"/>
      <url>/2018/10/25/2018-10-25/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC-实现抽奖活动（1-设计部分）"><a href="#SpringMVC-实现抽奖活动（1-设计部分）" class="headerlink" title="SpringMVC 实现抽奖活动（1.设计部分）"></a>SpringMVC 实现抽奖活动（1.设计部分）</h1><p>抽奖活动的需求分析如下：</p><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E6%8A%BD%E5%A5%96%E6%B4%BB%E5%8A%A8%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.png" alt="抽奖活动需求分析"></p><h4 id="争议点："><a href="#争议点：" class="headerlink" title="争议点："></a>争议点：</h4><ul><li>是否需要保证奖品能抽完，若是则每次中奖的概率会越来越大，否则每次概率保持一样即可<blockquote><p>如果中奖的概率设为1%，则抽100次抽中的概率（样品数每次会减1）为：1 - 99/100 * 98/99*……1/2，大约为百分之八十几</p></blockquote></li></ul><h4 id="良好的可扩展性、可配置性："><a href="#良好的可扩展性、可配置性：" class="headerlink" title="良好的可扩展性、可配置性："></a>良好的可扩展性、可配置性：</h4><ul><li>每次用户参与抽奖应同时记录抽奖时间，方便以后需求的扩充</li><li>奖品种类和数量的扩充</li></ul><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ul><li>多实例并发控制，竞争资源（需考虑两个并发场景，1.单用户并发抢码；2.多用户并发抢码）</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>考虑到线上会部署多台实例，故不能在java代码中加锁，需要使用redis分布式锁或者数据库加锁的方式</p><ul><li>for update悲观锁</li><li>基于version的乐观锁</li></ul><p>具体实现见下文</p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易 </tag>
            
            <tag> Java </tag>
            
            <tag> 抽奖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子序列（LCS）与最长公共子串（DP）</title>
      <link href="/2018/08/23/2018-08-23/"/>
      <url>/2018/08/23/2018-08-23/</url>
      
        <content type="html"><![CDATA[<h3 id="最长公共子序列（LCS）与最长公共子串（DP）"><a href="#最长公共子序列（LCS）与最长公共子串（DP）" class="headerlink" title="最长公共子序列（LCS）与最长公共子串（DP）"></a>最长公共子序列（LCS）与最长公共子串（DP）</h3><h4 id="1-子串与子序列的区别"><a href="#1-子串与子序列的区别" class="headerlink" title="1.子串与子序列的区别"></a>1.子串与子序列的区别</h4><p>这里给出一个例子：有两个母串</p><ul><li>cnblogs</li><li>belong</li></ul><p>比如序列bo, bg, lg在母串cnblogs与belong中都出现过并且出现顺序与母串保持一致，我们将其称为公共子序列。最长公共子序列（Longest Common Subsequence,LCS），顾名思义，是指在所有的子序列中最长的那一个。子串是要求更严格的一种子序列，要求在母串中连续地出现。在上述例子的中，<strong>最长公共子序列为blog（cnblogs,belong），最长公共子串为lo（cnblogs, belong）</strong>。</p><h4 id="2-DP状态转移方程"><a href="#2-DP状态转移方程" class="headerlink" title="2.DP状态转移方程"></a>2.DP状态转移方程</h4><p>最长公共子序列（LCS）：</p><p>二维数组c[i][j]记录串x1x2⋯xi与y1y2⋯yj的LCS长度，得到转移方程</p><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2.jpg" alt="最长公共子序列"><br>核心代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int lcs(String str1, String str2) &#123;  </span><br><span class="line">    int len1 = str1.length();  </span><br><span class="line">    int len2 = str2.length();  </span><br><span class="line">    int c[][] = new int[len1+1][len2+1];  </span><br><span class="line">    for (int i = 0; i &lt;= len1; i++) &#123;  </span><br><span class="line">        for( int j = 0; j &lt;= len2; j++) &#123;  </span><br><span class="line">            if(i == 0 || j == 0) &#123;  </span><br><span class="line">                c[i][j] = 0;  </span><br><span class="line">            &#125; else if (str1[i-1] == str2[j-1])) &#123;  </span><br><span class="line">                c[i][j] = c[i-1][j-1] + 1;  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                c[i][j] = max(c[i - 1][j], c[i][j - 1]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return c[len1][len2];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度等于将所给两个字符串各扫一遍，故为o(m*n)</p><hr><h5 id="最长公共子串（DP）："><a href="#最长公共子串（DP）：" class="headerlink" title="最长公共子串（DP）："></a>最长公共子串（DP）：</h5><p>与子序列的不同仅在于当Xi不等于Yj时，对应的dp记为0<br>二维数组c[i][j]用来表示以XiYj为结尾的公共子串的长度（注意此处的dp还需要找其中公共子串的最大值），得到转移方程<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.jpg" alt="最长公共子串"><br>核心代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int lcs(String str1, String str2) &#123;  </span><br><span class="line">    int len1 = str1.length();  </span><br><span class="line">    int len2 = str2.length();  </span><br><span class="line">    int result = 0;     //记录最长公共子串长度  </span><br><span class="line">    int c[][] = new int[len1+1][len2+1];  </span><br><span class="line">    for (int i = 0; i &lt;= len1; i++) &#123;  </span><br><span class="line">        for( int j = 0; j &lt;= len2; j++) &#123;  </span><br><span class="line">            if(i == 0 || j == 0) &#123;  </span><br><span class="line">                c[i][j] = 0;  </span><br><span class="line">            &#125; else if (str1[i-1] == str2[j-1])) &#123;  </span><br><span class="line">                c[i][j] = c[i-1][j-1] + 1;</span><br><span class="line">                result = max(c[i][j], result);    </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                c[i][j] = 0;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="最长回文串问题"><a href="#最长回文串问题" class="headerlink" title="最长回文串问题"></a>最长回文串问题</h6><p>可转换为最长子串问题，即将原始序列reverse，再求解该序列和原序列的最长公共子串即可，例题见：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805446102073344" target="_blank" rel="noopener">PAT 1040</a></p><hr><h3 id="允许重复元素的LCS"><a href="#允许重复元素的LCS" class="headerlink" title="允许重复元素的LCS"></a>允许重复元素的LCS</h3><p>试题举例：<a href="https://blog.csdn.net/xyt8023y/article/details/46910283" target="_blank" rel="noopener">PAT 1045. Favorite Color Stripe (30)</a><br>此题按照正常的思路求解，应该使用最长公共子序列算法LCS，但与常规的LCS有所差别，常规LCS是从两个序列中按索引递增顺序，不重复的选取最大公共子列，而现在的问题是在序列B中按照A中的元素顺序可重复的找出最大子列，这样说起来比较抽象，下面举个例子，对于序列：</p><p>A=｛2,3,1,5,6｝ B={2,2,4,1,5,5,6,3,1,1,5,6}</p><p>如果是常规的LCS，我们找到的子列将会是{2,3,1,5,6}，因为B完全的包含了A（不必连续）<br>如果是<strong>可重复的LCS，我们完全可以选择{2,2,3,1,1,5,6}，这便是变种的LCS</strong>。</p><p>本题与LCS相比，唯一的差别在于最长公共子串的字符可以连续出现。故我们在x[i]==y[j]，即串尾匹配时，不应像LCS那样c[i][j]=c[i-1][j-1]+1，因为这样表明串尾字符不能参与前面的匹配了，即同一个字符不能连续进行匹配。应该c[i][j]=max(c[i-1][j],c[i][j-1])+1，x[i]和y[j]依然可以参与前面的匹配。</p><p>（这里要不要加和c[i-1][j-1]的比较都可以，从结果看不影响）</p><p>核心代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; c(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>])<span class="comment">//串尾相等</span></span><br><span class="line">c[i][j]=max(c[i<span class="number">-1</span>][j],c[i][j<span class="number">-1</span>])+<span class="number">1</span>;<span class="comment">//对于LCS，此处是c[i][j]=c[i-1][j-1]+1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">c[i][j]=max(c[i<span class="number">-1</span>][j],c[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c[n][m];</span><br></pre></td></tr></table></figure><hr><h3 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h3><p>给定一个序列为a1,a2,a3……an;</p><p>要求：求出这个序列里面找到一个子段和最大</p><p>dp[i]表示以第i个元素结束的最大子段和</p><p>如果dp[i-1]&gt;0,无论ai为何值，有dp[i]=dp[i-1]+ai;</p><p>如果dp[i-1]&lt;=0;舍弃，重新令dp[i]=ai;(因为dp[i-1]为负数无论ai为什么值加上去都会减少)</p><p>状态转移方程如下：</p><pre><code>dp[i]=dp[i-1]+ai (dp[i-1]&gt;0)dp[i]=ai(dp[i-1]&lt;=0)</code></pre><p>核心代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[0] = a[0];</span><br><span class="line">max = a[0];</span><br><span class="line">for (int i = 1; i&lt;n; i++) &#123;</span><br><span class="line">    if (dp[i-1] &gt; 0) &#123;</span><br><span class="line">        dp[i] = dp[i-1] + a[i];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        dp[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if (dp[i] &gt; max) &#123;</span><br><span class="line">        max = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br></pre></td></tr></table></figure><p>若需要记录子段的起始位置，则可如下方式记录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//此处省去了dp[i]数组，改用tmp去记录</span><br><span class="line">//通过lindex记录起始的子段位置，rindex记录终点的子段位置</span><br><span class="line"> while (cin &gt;&gt; n) &#123;</span><br><span class="line">     lindex = tmp = tmpindex = 0;</span><br><span class="line">     max = -1;//注意此处max应为-1；</span><br><span class="line">     rindex = n-1;</span><br><span class="line">     for (int i = 0; i&lt;n; i++) &#123;</span><br><span class="line">         cin &gt;&gt; a[i];</span><br><span class="line">         tmp += a[i];</span><br><span class="line">         if (tmp &lt; 0) &#123;</span><br><span class="line">             tmp = 0;</span><br><span class="line">             tmpindex = i+1;</span><br><span class="line">         &#125;else if (tmp &gt; max) &#123;//注意此处一定要是else if结构</span><br><span class="line">             max = tmp;</span><br><span class="line">             rindex = i;</span><br><span class="line">             lindex = tmpindex;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="最长递增子序列（LIS）"><a href="#最长递增子序列（LIS）" class="headerlink" title="最长递增子序列（LIS）"></a>最长递增子序列（LIS）</h3><p>给定一个序列，求解它的最长递增子序列 的长度。比如： arr[] = {3,1,4,1,5,9,2,6,5}   的最长递增子序列长度为4。即为：1,4,5,9</p><p>当 arr[i] &gt; arr[j]，lis[i] = max{lis[j]}+1 ；其中，j 的取值范围为：0,1…i-1</p><p>当 arr[i] &lt; arr[j]，lis[i] = max{lis[j]} ；其中，j 的取值范围为：0,1…i-1</p><p>dp[i]表示以第i个数字为结尾的最长递增子序列长度，最长递增子序列的递推公式为：</p><p>dp[1] = 1;<br>dp[i] = max{1, F[j] + 1 | aj &lt; ai &amp; &amp; j &lt; i};</p><p>核心代码：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  dp = [<span class="number">1</span>] * (len(nums) + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> range(i)://遍历其前所有数字</span><br><span class="line">  <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">  dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">  ans = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> dp: //找到以每一个元素结尾的最长递增子序列中的最大值,该最大值即为答案</span><br><span class="line">  ans = max(ans, i)</span><br><span class="line">  <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>若所需最长递减子序列，则同理，只需把求解tmax 的判断条件改写成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> if (list[i] &lt;= list[j]) &#123; </span><br><span class="line"> ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><hr><br><br><br>参考资料：<p><a href="https://blog.csdn.net/qq_31881469/article/details/77892324" target="_blank" rel="noopener">https://blog.csdn.net/qq_31881469/article/details/77892324</a></p><p><a href="https://blog.csdn.net/xyt8023y/article/details/46910283" target="_blank" rel="noopener">https://blog.csdn.net/xyt8023y/article/details/46910283</a></p><p><a href="https://blog.csdn.net/sun897949163/article/details/49559679" target="_blank" rel="noopener">https://blog.csdn.net/sun897949163/article/details/49559679</a></p><p>《王道计算机考研机试指南》</p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题总结【01，恰好/不超过，完全，多重，路径记录，应用】</title>
      <link href="/2018/08/17/2018-08-17/"/>
      <url>/2018/08/17/2018-08-17/</url>
      
        <content type="html"><![CDATA[<p>有N件物品和一个容量为V的背包。第i件物品的体积是w[i]，价值是v[i]。</p><h4 id="1-0-1-背包"><a href="#1-0-1-背包" class="headerlink" title="1.0-1 背包"></a>1.0-1 背包</h4><p>求解将哪些物品装入背包可使价值总和最大,<strong>每种物品至多只能选择一件</strong></p><p>dp[i][j]表示第i件物品放入容量为j的背包所得的最大价值</p><p>dp[i][j]=max{dp[i-1][j-w[i]]+v[i] , dp[i-1][j]};</p><p>这里我们从j=V倒推回来的话可以优化成</p><p>dp[j]=max{dp[j] , dp[j-w[i]]+v[i]};</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（i=<span class="number">0</span>;i&lt;=V;i++）&#123;</span><br><span class="line">    dp[i] = <span class="number">0</span>;<span class="comment">//初始化均为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>（i=<span class="number">1</span>;i&lt;=n;i++）&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=V;j&gt;=w[i];j--)&#123;<span class="comment">//倒序更新,对于重量w[i]小于j的不作更新</span></span><br><span class="line">        <span class="comment">//choice[i][j] = true;//如需记录，则可另创一个辅助数组(详见下文)</span></span><br><span class="line">        dp[j]=max&#123;dp[j],dp[j-w[i]]+v[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dp[V]即为最大的价值</p><hr><h5 id="2-恰好装满时"><a href="#2-恰好装满时" class="headerlink" title="2.恰好装满时"></a>2.恰好装满时</h5><p>此时只需改变初始值，即</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">for</span>（i=<span class="number">1</span>;i&lt;=V;i++）&#123;</span><br><span class="line">    dp[i] = INF;<span class="comment">//除dp[0]外，其余均初始化为无穷</span></span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>同时在状态转移前需加判断，if (dp[j - w[i]] != INF)  dp=……</p><p>可以这样理解：初始化的dp 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么也不装的状态下被 “恰好装满” ，此时背包价值为0。其他容量的背包均没有合法的解，属于未定义的状态，所以都应该被赋值为 −∞ 。当前的合法解，一定是从之前的合法状态推得的</p><p>如果背包并非必须被装满，那么任何容量的背包都有一个合法解 “什么也不装”，这个解的价值为0,所以初始化时状态的值也就全部为0了。</p><hr><h4 id="3-完全背包问题"><a href="#3-完全背包问题" class="headerlink" title="3.完全背包问题"></a>3.完全背包问题</h4><p>有N种物品和一个容量为V的背包，<strong>每种物品都有无限件</strong>。每件费用是v[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><p>这时候对于每件物品就不是放与不放的问题了，而是放0件、1件…….</p><p>dp[i][j]表示容量为ｊ的背包第i件物品是否要再一次放入所以我们要从0-Ｖ顺序循环</p><p>dp[i][j]=max{dp[i][j-w[i]]+v[i],dp[i-1][j]}(注意这里和01背包的区别，第i件物品可以多次放）</p><p>优化后：dp[j]=max{dp[j] , dp[j-w[i]]+v[i]};</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（i=<span class="number">1</span>;i&lt;=n;i++）&#123;</span><br><span class="line">      <span class="keyword">for</span>(j=w[i];j&lt;=V;j++)&#123;<span class="comment">//注意到与一般背包相比，改变的只是遍历的顺序</span></span><br><span class="line">          dp[j]=max&#123;dp[j],dp[j-w[i]]+v[i]&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>dp[V]即为最大的价值</p><hr><h4 id="4-多重背包问题"><a href="#4-多重背包问题" class="headerlink" title="4.多重背包问题"></a>4.多重背包问题</h4><p>有N种物品和一个容量为V的背包。<strong>第i种物品最多有n[i]件可用</strong>，每件费用是v[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><p>因为对于第i种物品有n[i]+1种策略：取0件，取1件……取n[i]件。</p><p><strong>拆分</strong>：多重背包问题限定了一种物品的个数，解决多重背包问题，只需要把它转化为0-1背包问题即可。比如，有2件价值为5，重量为2的同一物品，我们就可以分为物品a和物品b，a和b的价值都为5，重量都为2，但我们把它们视作不同的物品。</p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//拆分</span></span><br><span class="line">    <span class="keyword">while</span> (num[i] != <span class="number">1</span>) &#123;</span><br><span class="line">        weight[k] = weight[i];</span><br><span class="line">        value[k] = value[i];</span><br><span class="line">        k++;</span><br><span class="line">        num[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若对时间复杂度要求较高，则可采用以下的分解方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int c = 1;</span><br><span class="line">while(k-c&gt;0)&#123;//对物品的数量k，拆分成1，2，4，8……</span><br><span class="line">    k-=c;</span><br><span class="line">    list[++ cnt].w = c * w;</span><br><span class="line">list[cnt].v = c * v; //拆分后的物品重量和价格均为组成改物品的质量与价格总和           </span><br><span class="line">c *= 2;</span><br><span class="line">&#125;</span><br><span class="line">list[++ cnt].w = w * k;</span><br><span class="line">list[cnt].v = v * k;</span><br><span class="line"></span><br><span class="line">//接着对拆分后的所有物品进行0-1背包处理即可</span><br></pre></td></tr></table></figure><hr><h3 id="附：记录所选路径"><a href="#附：记录所选路径" class="headerlink" title="附：记录所选路径"></a>附：记录所选路径</h3><p>新增二维数组choice[i][j]，表示第i件物品是否已放入容量为j的背包</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（i=<span class="number">0</span>;i&lt;=V;i++）&#123;</span><br><span class="line">    dp[i] = <span class="number">0</span>;<span class="comment">//初始化均为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>（i=<span class="number">1</span>;i&lt;=n;i++）&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=V;j&gt;=w[i];j--)&#123;</span><br><span class="line">        choice[i][j] = <span class="literal">true</span>;<span class="comment">//记录所选结果</span></span><br><span class="line">        dp[j]=max&#123;dp[j],dp[j-w[i]]+v[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">int</span> v = m, index = n;</span><br><span class="line"><span class="keyword">while</span>(v &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(choice[index][v] == <span class="literal">true</span>) &#123;<span class="comment">//若第index个物品已放入</span></span><br><span class="line">        arr.push_back(w[index]);</span><br><span class="line">        v -= w[index];<span class="comment">//体积减去相应的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    index--;<span class="comment">//在index-1个物品中继续寻找(从后往前)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="背包问题小结"><a href="#背包问题小结" class="headerlink" title="背包问题小结"></a>背包问题小结</h2><p>1.一维的0-1背包为什么逆序而完全背包为什么顺序?</p><p>保证更新f[j]时，f[ j - weight[i] ]是没有放入物品i时的数据,即f[ i - 1 ][ j - weight[i] ]，因为0-1背包每个物品至多被选一次。而完全背包中，每个物品可以被选无限次，那么状态f[i][j]正好可以由可能已经放入物品i的状态f[ i - 1 ][ j - weight[i] ]转移而来。所以，遍历顺序改为顺序时，就是完全背包问题，其余都不用变</p><p>2.完全背包 和 01背包 的区别仅在于状态更新时的<strong>遍历顺序</strong>。01背包是逆序，完全背包是顺序</p><p>3.<strong>不超过容量</strong> 和 <strong>恰好装满</strong> 的区别仅在于二者的初始化</p><p>前者全0，后者一维：除dp[0]为0外，其余dp[j]都是负无穷；二维：dp[i][0] = 0（第一列),其余全为0x80000000</p><p>4.0-1背包循环边界  i:[1,N]，j:[V,weight[i]]</p><hr><h3 id="更多背包问题"><a href="#更多背包问题" class="headerlink" title="更多背包问题"></a>更多背包问题</h3><p>以下问题均可转化为背包问题进行求解(持续更新）:</p><p><a href="https://www.liuchuo.net/archives/2323" target="_blank" rel="noopener">https://www.liuchuo.net/archives/2323</a></p><p>Leetcode: 322,416,474,518,1049</p><br><br><br><hr><p>改编自：</p><p> <a href="https://blog.csdn.net/sun897949163/article/details/49559679" target="_blank" rel="noopener">https://blog.csdn.net/sun897949163/article/details/49559679</a> </p><p> <a href="https://blog.csdn.net/dr_unknown/article/details/51275471" target="_blank" rel="noopener">https://blog.csdn.net/dr_unknown/article/details/51275471</a></p><p>《王道计算机考研机试指南》</p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>High Sierra 版本下Xcode 9 无法注释问题（command + / 失效）</title>
      <link href="/2018/08/14/2018-08-14/"/>
      <url>/2018/08/14/2018-08-14/</url>
      
        <content type="html"><![CDATA[<p>将mac os版本更新至High Sierra 之后遇见Xcode的代码注释功能失效的问题，具体表现为<strong>快捷键失效，且不能从下图所示Editor - Structure处手动添加</strong>。</p><p>（此前红框部分为灰色不可用状态 ，此处解决后已恢复正常）</p><p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/Xcode%E6%B3%A8%E9%87%8A%E5%A4%B1%E6%95%88%E6%88%AA%E5%9B%BE.png" alt="Editor - Structure"></p><p>网上找了好多资料，解决方案如下：</p><p>1.如果系统版本较低，可采用如下方法（网上大部分是这样说的）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /usr/libexec/xpccachectl</span><br></pre></td></tr></table></figure><p>然而这个方法是历史的产物，在High Sierra的系统中已经没有了这个脚本。</p><p>笔者在执行时便会遇见 /usr/libexec/xpccachectl: command not found错误（当然，都没有这个脚本了怎么能执行  (<del>﹏</del>) ）</p><p>2.Rename is good（非常神奇的方法，如其所说）</p><p>打开Finder 中的Application文件夹，将其中的Xcode重命名，比如重命名成Acode，确定更改后打开，如果问题解决则大功告成，最后重新把名字改回来即可。</p><blockquote><p>参见Stack Overflow   <a href="https://stackoverflow.com/questions/38847530/cant-comment-selection" target="_blank" rel="noopener">https://stackoverflow.com/questions/38847530/cant-comment-selection</a></p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>归纳一下解决该问题的步骤，由简到难排列为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.重启Xcode</span><br><span class="line">2.重启电脑</span><br><span class="line">3.尝试 sudo /usr/libexec/xpccachectl</span><br><span class="line">4.重命名Xcode</span><br><span class="line">5.重新下载Xcode</span><br><span class="line">6.升级系统</span><br></pre></td></tr></table></figure><p>运气好的话到第四步即可解决此Bug，然而本人试了都不行，最后做到了第五步，含泪重装了Xcode解决（5.3个G用校园网下了好久 (..•˘_˘•..)）</p><br><br><p>改编自：</p><p>Stack Overflow中的相关问题：</p><p><a href="https://stackoverflow.com/questions/47101437/" target="_blank" rel="noopener">https://stackoverflow.com/questions/47101437/</a> </p><p><a href="https://stackoverflow.com/questions/38847530/" target="_blank" rel="noopener">https://stackoverflow.com/questions/38847530/</a></p><p>原鸣清的简书  <a href="https://www.jianshu.com/p/4494fb458edb" target="_blank" rel="noopener">https://www.jianshu.com/p/4494fb458edb</a></p><p>okerivy的简书 <a href="https://www.jianshu.com/p/e4b8aff61250" target="_blank" rel="noopener">https://www.jianshu.com/p/e4b8aff61250</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS High Sierra </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于github page搭建个人blog</title>
      <link href="/2017/09/01/2017-09-01/"/>
      <url>/2017/09/01/2017-09-01/</url>
      
        <content type="html"><![CDATA[<p>因为最近实习结束外加各种杂七杂八的琐事，又要忙着准备开学第一周的数模比赛（嗯，通俗来讲就是很忙：），系列的开篇博文就先说说这个博客的大致架构吧，大家可以先有个概念要做哪些事。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>经大多数乎友推荐选择了从<a href="https://sg.godaddy.com/zh?isc=gennbacn29&countrview=1&currencytype=CNY&mkwid=WFSMCUdy&cvosrc=ppc.baidu" target="_blank" rel="noopener">goDaddy</a>购买的顶级域名，包年大概也就￥58的样子，算是比较不错的选择（选购时记得搜索优惠码），不过后来在找服务器的时候发现国内一些公司提供的域名价格会更优惠，比如<a href="https://dnspod.qcloud.com/act/seckill?utm_source=portal&utm_medium=recommend&utm_campaign=recmd3&from=doufu3" target="_blank" rel="noopener">腾讯云</a>、<a href="https://wanwang.aliyun.com/?spm=5176.8142029.735711.56.23896dfa2q0NIq" target="_blank" rel="noopener">阿里云</a>、<a href="https://cloud.baidu.com/index.html?track=cp:npinzhuan|pf:pc|pp:left|ci:|pu:495" target="_blank" rel="noopener">百度云</a>，大家在选购时可以多加比较，域名种类有很多种，比较贵的就是.com/.cn/.net的顶级域名，具体选择可以看个人喜好。</p><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>托管在github-pages上，免费，300M空间，作为个人博客来说足够了，同时作为轻量级的博客系统，配置相对而言较简洁。缺点也比较明显，由于使用Jekyll模板系统，只能发布静态页，无法动态加载，所以如果页面元素过多，加载速度会较慢。</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>[GoodThingList/GoodJekyllBlogList.md at master · cnfeat/GoodThingList](GoodThingList/GoodJekyllBlogList.md at master · cnfeat/GoodThingList)上有各种风格的模板，有一定前端基础可以自己在模板基础上加以改动。</p><h4 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h4><p>安装好Jekyll环境后，可直接在本地加以编辑并测试，需注意Liquid语言模板的写法</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>github-page无需外接数据库</p><h4 id="博客引擎"><a href="#博客引擎" class="headerlink" title="博客引擎"></a>博客引擎</h4><p>Jekyll</p><h4 id="版本迭代"><a href="#版本迭代" class="headerlink" title="版本迭代"></a>版本迭代</h4><p>Git，通过GitHub Desk可在改动后直接发布commit</p><h4 id="流量统计"><a href="#流量统计" class="headerlink" title="流量统计"></a>流量统计</h4><p>Google Analytics（需翻墙）</p><h4 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h4><p>//推荐七牛云，10G免费流量</p><p>驳回上述⬆️</p><p>推荐腾讯云，依然有免费的流量</p><p>七牛云恶心的地方是需要绑一个通过备案的域名，它一开始会给你发一个测试域名，所以可以正常使用，但过段时间过期了图床就崩了，把上面的图片重新找回来还废了不少功夫</p><h4 id="SSL证书加密"><a href="#SSL证书加密" class="headerlink" title="SSL证书加密"></a>SSL证书加密</h4><p>因为用了七牛云的图床，顺便就在里边签了TrustAsia的证书，这里还是推荐用 Letsencrypt，知名度更高，不过后来签发下来之后发现github-page无法发布证书，如果想要加密还是需要用 CloudFlare，做一次代理，这个具体操作之后会详细说明（通过 CloudFlare其实不需要额外去注册证书）<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/SSL%E8%AF%81%E4%B9%A6.png" alt="SSL证书.png"></p><hr><p>完成上述内容你的博客就飞速地搭起来啦，总计成本就是买了域名，其余的用免费的均可实现。最花时间的部分其实在于模板的改动，需要花时间去理解模板作者的代码并加以更改，当然好的模板一般在配置文件_config里即可完成大部分元素的更改，但像我这样爱折腾的人总是不能挑出最心仪的模板，在现有基础上更改模板的css、html也就难以避免了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/08/31/2017-08-31/"/>
      <url>/2017/08/31/2017-08-31/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>耗时两天，基于github-page的个人blog就这样飞速地搭起来了，整个流程唯一花钱的地方就是买了.com的顶级域名，服务器则选择直接托管在github-page上，至于前端页面，本着“没有设计的本事就别干设计的活”的思想，果断从网上下一个模板下来自己改（改别人的代码果然比较花时间，改了2天才改成现在自己想要的样式），然后又花了2天找背景图片想标题写文章。至此，从决定要开始做一个个人网站到最后上线第一篇博文，历时6天。</p><h3 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h3><p>首先说说为什么想搭一个个人网站，最先是受启发于一个圈内的朋友，她在动态中发布了自己基于Django搭建的个人博客，我点进去一看，嗯，还不错。于是乎，我就想着我是不是也能搭一个网站出来，正好那段时间因为实习的关系，学习了大量的前端知识，html、css、svg、snap、javascript等等都略知一二，可苦于没有练手的机会，就这样，搭建个人网站的种子便种下了，由于实习的关系，这颗种子一直到最近才发芽。</p><p>开发个人blog的另一个原因是我比较崇尚自由，现在市面上盛名的博客网站很多，典型如CSDN、简书等等都能满足个人blog的需求，比起在这些大型网站注册账号去写博客，受缚与现有的网站框架、模板，我更倾向于搭建一个只属于自己的小窝，想改什么就改什么，没有各种悬浮的广告位，没有各种花里胡哨的令人眼花缭乱的元素，随时都能根据自己的喜好进行更改，无论是整个网站模板也好，背景图片也好，anything。</p><h3 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h3><p>博客的命名来源于张敬轩的<a href="https://y.qq.com/n/yqq/song/004X6J5V4Aldjg.html?ADTAG=baiduald&play=1" target="_blank" rel="noopener">《过客别墅》</a>，林夕作词。轩仔是我非常喜欢的一位港台歌手，喜欢粤语歌的旁友们不妨去听听他的歌，不会让你失望的<del>博客目前一共分为5个版块，即首页右上角的5个链接，Home首页，About写了些我个人的信息，Archieve则是目前为止按时间顺序罗列的文章目录，Memoirs是我个人的回忆录（还在开发中），Tags是每篇文章按标签分类汇总出的文章目录。如有bug还请各位看官多多包涵，功能还在不断完善</del>（特意留下了个404的入口，不知道是否有人能发现hhh）</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>嗯，鉴于网上的一些教程都已经比较老旧，这几年github的改动也较大，自己在搭建的过程中吃了不少苦头（忍不住吐槽某辣鸡X度，很多问题还是得靠google），前车之鉴，在接下来的系列博文中将为大家详细说说怎样基于github-page搭建一个成本极低的博客。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 Coding Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
