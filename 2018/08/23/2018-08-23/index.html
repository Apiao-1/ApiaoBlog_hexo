<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="本篇文章整理了所有字符串类的DP问题。"><meta name="keywords" content="算法,summary"><meta name="author" content="Apiao"><meta name="copyright" content="Apiao"><title>最长公共子序列（LCS）与最长公共子串（DP） | 过客别墅</title><link rel="shortcut icon" href="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/css_img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?9e24343494f127f2cc9e8c004fb20cbd";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#最长公共子序列（LCS）与最长公共子串（DP）"><span class="toc-number">1.</span> <span class="toc-text">最长公共子序列（LCS）与最长公共子串（DP）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-子串与子序列的区别"><span class="toc-number">1.1.</span> <span class="toc-text">1.子串与子序列的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-DP状态转移方程"><span class="toc-number">1.2.</span> <span class="toc-text">2.DP状态转移方程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#最长公共子串（DP）："><span class="toc-number">1.2.1.</span> <span class="toc-text">最长公共子串（DP）：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#最长回文串问题"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">最长回文串问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#允许重复元素的LCS"><span class="toc-number">2.</span> <span class="toc-text">允许重复元素的LCS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最大子段和"><span class="toc-number">3.</span> <span class="toc-text">最大子段和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长递增子序列（LIS）"><span class="toc-number">4.</span> <span class="toc-text">最长递增子序列（LIS）</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/css_img/profile1.jpg"></div><div class="author-info__name text-center">Apiao</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Apiao-1">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">35</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://yisaer.github.io/">Yisa</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/css_img/article3.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coding Life</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">最长公共子序列（LCS）与最长公共子串（DP）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技术类/">技术类</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.7k</span><span class="post-meta__separator">|</span><span>Reading time: 7 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="最长公共子序列（LCS）与最长公共子串（DP）"><a href="#最长公共子序列（LCS）与最长公共子串（DP）" class="headerlink" title="最长公共子序列（LCS）与最长公共子串（DP）"></a>最长公共子序列（LCS）与最长公共子串（DP）</h3><h4 id="1-子串与子序列的区别"><a href="#1-子串与子序列的区别" class="headerlink" title="1.子串与子序列的区别"></a>1.子串与子序列的区别</h4><p>这里给出一个例子：有两个母串</p>
<ul>
<li>cnblogs</li>
<li>belong</li>
</ul>
<p>比如序列bo, bg, lg在母串cnblogs与belong中都出现过并且出现顺序与母串保持一致，我们将其称为公共子序列。最长公共子序列（Longest Common Subsequence,LCS），顾名思义，是指在所有的子序列中最长的那一个。子串是要求更严格的一种子序列，要求在母串中连续地出现。在上述例子的中，<strong>最长公共子序列为blog（cnblogs,belong），最长公共子串为lo（cnblogs, belong）</strong>。</p>
<h4 id="2-DP状态转移方程"><a href="#2-DP状态转移方程" class="headerlink" title="2.DP状态转移方程"></a>2.DP状态转移方程</h4><p>最长公共子序列（LCS）：</p>
<p>二维数组c[i][j]记录串x1x2⋯xi与y1y2⋯yj的LCS长度，得到转移方程</p>
<p><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2.jpg" alt="最长公共子序列"><br>核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int lcs(String str1, String str2) &#123;  </span><br><span class="line">    int len1 = str1.length();  </span><br><span class="line">    int len2 = str2.length();  </span><br><span class="line">    int c[][] = new int[len1+1][len2+1];  </span><br><span class="line">    for (int i = 0; i &lt;= len1; i++) &#123;  </span><br><span class="line">        for( int j = 0; j &lt;= len2; j++) &#123;  </span><br><span class="line">            if(i == 0 || j == 0) &#123;  </span><br><span class="line">                c[i][j] = 0;  </span><br><span class="line">            &#125; else if (str1[i-1] == str2[j-1])) &#123;  </span><br><span class="line">                c[i][j] = c[i-1][j-1] + 1;  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                c[i][j] = max(c[i - 1][j], c[i][j - 1]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return c[len1][len2];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法复杂度等于将所给两个字符串各扫一遍，故为o(m*n)</p>
<hr>
<h5 id="最长公共子串（DP）："><a href="#最长公共子串（DP）：" class="headerlink" title="最长公共子串（DP）："></a>最长公共子串（DP）：</h5><p>与子序列的不同仅在于当Xi不等于Yj时，对应的dp记为0<br>二维数组c[i][j]用来表示以XiYj为结尾的公共子串的长度（注意此处的dp还需要找其中公共子串的最大值），得到转移方程<br><img src="https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.jpg" alt="最长公共子串"><br>核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int lcs(String str1, String str2) &#123;  </span><br><span class="line">    int len1 = str1.length();  </span><br><span class="line">    int len2 = str2.length();  </span><br><span class="line">    int result = 0;     //记录最长公共子串长度  </span><br><span class="line">    int c[][] = new int[len1+1][len2+1];  </span><br><span class="line">    for (int i = 0; i &lt;= len1; i++) &#123;  </span><br><span class="line">        for( int j = 0; j &lt;= len2; j++) &#123;  </span><br><span class="line">            if(i == 0 || j == 0) &#123;  </span><br><span class="line">                c[i][j] = 0;  </span><br><span class="line">            &#125; else if (str1[i-1] == str2[j-1])) &#123;  </span><br><span class="line">                c[i][j] = c[i-1][j-1] + 1;</span><br><span class="line">                result = max(c[i][j], result);    </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                c[i][j] = 0;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="最长回文串问题"><a href="#最长回文串问题" class="headerlink" title="最长回文串问题"></a>最长回文串问题</h6><p>可转换为最长子串问题，即将原始序列reverse，再求解该序列和原序列的最长公共子串即可，例题见：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805446102073344" target="_blank" rel="noopener">PAT 1040</a></p>
<hr>
<h3 id="允许重复元素的LCS"><a href="#允许重复元素的LCS" class="headerlink" title="允许重复元素的LCS"></a>允许重复元素的LCS</h3><p>试题举例：<a href="https://blog.csdn.net/xyt8023y/article/details/46910283" target="_blank" rel="noopener">PAT 1045. Favorite Color Stripe (30)</a><br>此题按照正常的思路求解，应该使用最长公共子序列算法LCS，但与常规的LCS有所差别，常规LCS是从两个序列中按索引递增顺序，不重复的选取最大公共子列，而现在的问题是在序列B中按照A中的元素顺序可重复的找出最大子列，这样说起来比较抽象，下面举个例子，对于序列：</p>
<p>A=｛2,3,1,5,6｝ B={2,2,4,1,5,5,6,3,1,1,5,6}</p>
<p>如果是常规的LCS，我们找到的子列将会是{2,3,1,5,6}，因为B完全的包含了A（不必连续）<br>如果是<strong>可重复的LCS，我们完全可以选择{2,2,3,1,1,5,6}，这便是变种的LCS</strong>。</p>
<p>本题与LCS相比，唯一的差别在于最长公共子串的字符可以连续出现。故我们在x[i]==y[j]，即串尾匹配时，不应像LCS那样c[i][j]=c[i-1][j-1]+1，因为这样表明串尾字符不能参与前面的匹配了，即同一个字符不能连续进行匹配。应该c[i][j]=max(c[i-1][j],c[i][j-1])+1，x[i]和y[j]依然可以参与前面的匹配。</p>
<p>（这里要不要加和c[i-1][j-1]的比较都可以，从结果看不影响）</p>
<p>核心代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; c(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>])<span class="comment">//串尾相等</span></span><br><span class="line">				c[i][j]=max(c[i<span class="number">-1</span>][j],c[i][j<span class="number">-1</span>])+<span class="number">1</span>;<span class="comment">//对于LCS，此处是c[i][j]=c[i-1][j-1]+1</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				c[i][j]=max(c[i<span class="number">-1</span>][j],c[i][j<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;c[n][m];</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h3><p>给定一个序列为a1,a2,a3……an;</p>
<p>要求：求出这个序列里面找到一个子段和最大</p>
<p>dp[i]表示以第i个元素结束的最大子段和</p>
<p>如果dp[i-1]&gt;0,无论ai为何值，有dp[i]=dp[i-1]+ai;</p>
<p>如果dp[i-1]&lt;=0;舍弃，重新令dp[i]=ai;(因为dp[i-1]为负数无论ai为什么值加上去都会减少)</p>
<p>状态转移方程如下：</p>
<pre><code>dp[i]=dp[i-1]+ai (dp[i-1]&gt;0)

dp[i]=ai(dp[i-1]&lt;=0)</code></pre><p>核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[0] = a[0];</span><br><span class="line">max = a[0];</span><br><span class="line">for (int i = 1; i&lt;n; i++) &#123;</span><br><span class="line">    if (dp[i-1] &gt; 0) &#123;</span><br><span class="line">        dp[i] = dp[i-1] + a[i];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        dp[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if (dp[i] &gt; max) &#123;</span><br><span class="line">        max = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br></pre></td></tr></table></figure>

<p>若需要记录子段的起始位置，则可如下方式记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//此处省去了dp[i]数组，改用tmp去记录</span><br><span class="line">//通过lindex记录起始的子段位置，rindex记录终点的子段位置</span><br><span class="line"> while (cin &gt;&gt; n) &#123;</span><br><span class="line">     lindex = tmp = tmpindex = 0;</span><br><span class="line">     max = -1;//注意此处max应为-1；</span><br><span class="line">     rindex = n-1;</span><br><span class="line">     for (int i = 0; i&lt;n; i++) &#123;</span><br><span class="line">         cin &gt;&gt; a[i];</span><br><span class="line">         tmp += a[i];</span><br><span class="line">         if (tmp &lt; 0) &#123;</span><br><span class="line">             tmp = 0;</span><br><span class="line">             tmpindex = i+1;</span><br><span class="line">         &#125;else if (tmp &gt; max) &#123;//注意此处一定要是else if结构</span><br><span class="line">             max = tmp;</span><br><span class="line">             rindex = i;</span><br><span class="line">             lindex = tmpindex;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="最长递增子序列（LIS）"><a href="#最长递增子序列（LIS）" class="headerlink" title="最长递增子序列（LIS）"></a>最长递增子序列（LIS）</h3><p>给定一个序列，求解它的最长递增子序列 的长度。比如： arr[] = {3,1,4,1,5,9,2,6,5}   的最长递增子序列长度为4。即为：1,4,5,9</p>
<p>当 arr[i] &gt; arr[j]，lis[i] = max{lis[j]}+1 ；其中，j 的取值范围为：0,1…i-1</p>
<p>当 arr[i] &lt; arr[j]，lis[i] = max{lis[j]} ；其中，j 的取值范围为：0,1…i-1</p>
<p>dp[i]表示以第i个数字为结尾的最长递增子序列长度，最长递增子序列的递推公式为：</p>
<p>dp[1] = 1;<br>dp[i] = max{1, F[j] + 1 | aj &lt; ai &amp; &amp; j &lt; i};</p>
<p>核心代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  dp = [<span class="number">1</span>] * (len(nums) + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">  	<span class="keyword">for</span> j <span class="keyword">in</span> range(i)://遍历其前所有数字</span><br><span class="line">  		<span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">  			dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">  ans = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> dp: //找到以每一个元素结尾的最长递增子序列中的最大值,该最大值即为答案</span><br><span class="line">  	ans = max(ans, i)</span><br><span class="line">  <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>若所需最长递减子序列，则同理，只需把求解tmax 的判断条件改写成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> if (list[i] &lt;= list[j]) &#123; </span><br><span class="line">	 ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>
<br>
<br>
参考资料：

<p><a href="https://blog.csdn.net/qq_31881469/article/details/77892324" target="_blank" rel="noopener">https://blog.csdn.net/qq_31881469/article/details/77892324</a></p>
<p><a href="https://blog.csdn.net/xyt8023y/article/details/46910283" target="_blank" rel="noopener">https://blog.csdn.net/xyt8023y/article/details/46910283</a></p>
<p><a href="https://blog.csdn.net/sun897949163/article/details/49559679" target="_blank" rel="noopener">https://blog.csdn.net/sun897949163/article/details/49559679</a></p>
<p>《王道计算机考研机试指南》</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Apiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://Apiao-1.github.io/2018/08/23/2018-08-23/">https://Apiao-1.github.io/2018/08/23/2018-08-23/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/算法/">算法</a><a class="post-meta__tags" href="/tags/summary/">summary</a></div><div class="social-share" data-disabled="diandian,google,facebook,twitter,douban,share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/10/25/2018-10-25/"><i class="fa fa-chevron-left">  </i><span>SpringMVC 实现抽奖活动（1.设计部分）</span></a></div><div class="next-post pull-right"><a href="/2018/08/17/2018-08-17/"><span>背包问题总结【01，恰好/不超过，完全，多重，路径记录，应用】</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'baf14b2c923df40b37c8',
  clientSecret: '989e5490466533378766304b304fa51a747285aa',
  repo: 'apiao-1.github.io',
  owner: 'Apiao-1',
  admin: 'Apiao-1',
  id: md5(decodeURI(location.pathname)),
  language: ''
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://apiao-1258505467.cos.ap-chengdu.myqcloud.com/blog_pic/css_img/article3.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2020 By Apiao</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">一直寻找道路的人最后会架起桥梁</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>